# Development Notes - T-02-01 Graph Builder

**Date**: 2025-10-24
**Task**: Graph Builder - AST Parsing & Construction
**Phase**: Specification Review & Analysis

---

## 1. Architecture Decisions

### 1.1 Graph Representation

**Decision**: Use `petgraph::Graph<Node, Edge>` (Rust equivalent of NetworkX MultiDiGraph)

**Rationale**:
- LocAgent uses NetworkX MultiDiGraph (allows multiple edges between nodes)
- Need to support multiple import edges from same source to target
- Petgraph provides similar API with better performance

**Alternative Considered**: Custom adjacency list
- Rejected: More implementation complexity, less standardized

### 1.2 AST Parsing Strategy

**Decision**: Use tree-sitter-python (following LocAgent approach)

**Rationale**:
- LocAgent uses Python's ast module (standard library)
- Tree-sitter provides equivalent AST parsing for Rust
- Can reuse query logic from LocAgent (documented in parity methodology)

**Key Tree-sitter Queries Needed**:
- Class definitions (`ClassDef`)
- Function definitions (`FunctionDef`, `AsyncFunctionDef`)
- Import statements (`Import`, `ImportFrom`)
- Function calls (`Call`)
- Inheritance (`bases` attribute)

### 1.3 Fully Qualified Name (FQN) Format

**Decision**: Match LocAgent format exactly: `filename:Class.method`

**Examples**:
- Top-level function: `utils/helpers.py:sanitize_input`
- Class method: `core/parser.py:CodeAnalyzer.visit_ClassDef`
- Nested class: `core/parser.py:Outer.Inner.method`
- File node: `utils/helpers.py`
- Directory node: `utils/`, `/`

**Critical**: Dot notation for class/function nesting, colon separator for file boundary

---

## 2. Implementation Details

### 2.1 Graph Schema (from Baseline Analysis)

**Node Types** (4):
1. `directory` - Directory in repo (e.g., `/`, `subdir/`)
2. `file` - Python source file (e.g., `main.py`, `utils/helpers.py`)
3. `class` - Class definition (e.g., `parser.py:CodeAnalyzer`)
4. `function` - Function/method (e.g., `parser.py:analyze_file`)

**Node Attributes**:
```rust
struct GraphNode {
    id: String,           // Fully qualified name
    node_type: NodeType,  // One of 4 types above
    name: String,         // Entity name (without path prefix)
    file: String,         // Source file path (empty for directories)
    line: u32,            // Line number (0 for directories)
    code: Option<String>, // Source code snippet (for classes/functions)
}
```

**Edge Types** (4):
1. `contains` - Containment relationship (dir→file, file→class, class→method)
2. `imports` - Import dependency (file→file, file→entity)
3. `invokes` - Function call (function→function)
4. `inherits` - Class inheritance (class→class)

**Edge Attributes**:
```rust
struct GraphEdge {
    source: String,  // Source node ID
    target: String,  // Target node ID
    edge_type: EdgeType,
    alias: Option<String>, // Import alias (for imports only)
}
```

### 2.2 Baseline Statistics (for Parity Validation)

| Repository | Nodes | Edges | Directories | Files | Classes | Functions |
|------------|-------|-------|-------------|-------|---------|-----------|
| LocAgent | 658 | 1,419 | 20 | 74 | 86 | 478 |
| Django | 6,876 | 9,982 | 602 | 500 | 1,598 | 4,176 |
| Matplotlib | 1,304 | 1,674 | 66 | 500 | 121 | 617 |
| Requests | 752 | 2,060 | 10 | 76 | 118 | 548 |
| Pytest | 5,991 | 8,634 | 64 | 249 | 648 | 5,030 |
| Scikit-learn | 6,613 | 55,638 | 89 | 500 | 556 | 5,468 |

**Parity Threshold**: ≤2% variance in node/edge counts

**Largest Test Case**: Scikit-learn (6,613 nodes, 55,638 edges)
- Stress test for performance (index build <5s target)
- Complex dependency graph (high edge count)

### 2.3 Skip Directory Logic (from LocAgent)

**Directories to Skip**:
```rust
const SKIP_DIRS: &[&str] = &[
    ".github", ".git", ".venv", "venv", "__pycache__",
    ".pytest_cache", "node_modules", "site-packages",
    ".tox", ".eggs", "build", "dist", ".mypy_cache", ".hypothesis"
];

fn is_skip_dir(dirname: &str) -> bool {
    SKIP_DIRS.iter().any(|skip| dirname.contains(skip))
}
```

**Rationale**: Exclude non-source directories to reduce graph noise

### 2.4 Graph Construction Pipeline (LocAgent Algorithm)

**Phase 1: Node Creation (os.walk equivalent)**
```
1. Initialize MultiDiGraph
2. Add root directory node "/"
3. For each directory in os.walk(repo_path):
   a. Skip if matches SKIP_DIRS
   b. Add directory node with type="directory"
   c. Create "contains" edge to parent directory
4. For each .py file in directory:
   a. Skip if symlink
   b. Read file content, add file node with full source code
   c. Parse AST with analyze_file()
   d. Extract classes/functions
   e. Add class/function nodes with FQN format
5. Cleanup: Remove empty directories (no .py files)
```

**Phase 2: Edge Creation - Contains**
```
1. Directory → File (contains)
2. File → Top-level class/function (contains)
3. For nested entities (e.g., Class.method):
   - Split FQN by dots
   - Create edge from parent to child
   - Example: "parser.py:CodeAnalyzer" → "parser.py:CodeAnalyzer.visit"
```

**Phase 3: Edge Creation - Imports**
```
1. For each file node:
   a. Parse all import statements (ast.Import, ast.ImportFrom)
   b. Handle absolute imports: "import os" → edge to os
   c. Handle relative imports: "from .utils import foo" → resolve to file path
   d. Handle "from X import Y":
      - Try to resolve Y as submodule
      - If not found, try "X:Y" (entity inside module X)
   e. Create "imports" edge with optional alias
```

**Phase 4: Edge Creation - Invokes & Inherits**
```
1. For each class/function node:
   a. Parse its code into AST
   b. Build "possible callee dict" from graph connectivity:
      - All nodes imported by this file
      - All nodes in same file
      - All nodes in parent classes (for methods)
   c. Walk AST to find function calls (ast.Call)
   d. Match call name to possible callees (fuzzy suffix matching)
   e. Create "invokes" edge
2. For class inheritance:
   a. Parse class bases (ast.ClassDef.bases)
   b. Resolve base class names
   c. Create "inherits" edge
```

### 2.5 JSON Output Format (for Parity Validation)

**Structure** (from baseline files):
```json
{
  "repository": "LocAgent",
  "total_nodes": 658,
  "total_edges": 1419,
  "node_counts_by_type": {
    "directory": 20,
    "file": 74,
    "class": 86,
    "function": 478
  },
  "edge_counts_by_type": {
    "contains": 1200,
    "imports": 150,
    "invokes": 60,
    "inherits": 9
  },
  "nodes": [
    {
      "id": "/",
      "type": "directory",
      "name": "",
      "file": "",
      "line": 0
    },
    {
      "id": "auto_search_main.py",
      "type": "file",
      "name": "auto_search_main.py",
      "file": "auto_search_main.py",
      "line": 0
    },
    {
      "id": "dependency_graph/build_graph.py:CodeAnalyzer",
      "type": "class",
      "name": "CodeAnalyzer",
      "file": "dependency_graph/build_graph.py",
      "line": 120
    },
    {
      "id": "dependency_graph/build_graph.py:CodeAnalyzer.visit_ClassDef",
      "type": "function",
      "name": "visit_ClassDef",
      "file": "dependency_graph/build_graph.py",
      "line": 127
    }
  ],
  "edges": [
    {
      "source": "/",
      "target": "auto_search_main.py",
      "type": "contains"
    },
    {
      "source": "auto_search_main.py",
      "target": "dependency_graph/build_graph.py",
      "type": "imports"
    }
  ],
  "graph_version": "v2.3",
  "extraction_metadata": {
    "timestamp": "2025-10-24T22:01:45Z",
    "python_version": "3.12",
    "extractor": "LocAgent build_graph.py"
  }
}
```

---

## 3. Research & Learning

### 3.1 LocAgent Reference Implementation

**File**: `tmp/LocAgent/dependency_graph/build_graph.py`
**Key Functions**:
- `build_graph(repo_path)` (line 285): Main entry point
- `analyze_file(filepath)` (line 177): AST parsing and entity extraction
- `find_imports(filepath, repo_path)` (line 51): Import statement parsing
- `add_imports(root_node, imports, graph, repo_path)` (line 211): Import edge creation
- `find_all_possible_callee(node, graph)` (not shown): Callee resolution for invokes

**Key Classes**:
- `CodeAnalyzer(ast.NodeVisitor)` (line 120): AST walker for classes/functions
  - `visit_ClassDef(node)`: Extract class definitions
  - `visit_FunctionDef(node)`: Extract functions
  - `visit_AsyncFunctionDef(node)`: Extract async functions
  - `_get_source_segment(node)`: Extract source code snippet

**Edge Cases Handled** (line 33-48):
- Unicode BOM (`\ufeff`)
- Python 2/3 compatibility (`constants.False` → `_False`)
- Exception syntax variations (`except Error, e` → `except Error as e`)
- Print statement to yield conversion (Python 2 → 3)

### 3.2 Parity Validation Methodology

**Document**: `docs/parity-validation-methodology.md`

**Module Mapping** (LocAgent → CDSAgent):
- `dependency_graph/build_graph.py` → `crates/cds-index/src/graph/builder.rs`
- `dependency_graph/traverse_graph.py` → `crates/cds-index/src/graph/traversal.rs`
- AST parsing → `crates/cds-index/src/graph/ast_parser/`

**Validation Strategy**:
1. **Graph Structure Variance**: ≤2% node/edge count difference
2. **Search Result Overlap@10**: ≥90% (9/10 results match)
3. **Traversal Exact Match**: 100% (10/10 scenarios)
4. **Performance Speedup**: 2-5x faster than Python

**Baseline Files Available**:
- `tests/fixtures/parity/golden_outputs/graph_locagent.json` (LocAgent itself)
- `tests/fixtures/parity/golden_outputs/graph_django__django-10914.json`
- `tests/fixtures/parity/golden_outputs/graph_matplotlib__matplotlib-18869.json`
- `tests/fixtures/parity/golden_outputs/graph_psf__requests-1963.json`
- `tests/fixtures/parity/golden_outputs/graph_pytest-dev__pytest-11143.json`
- `tests/fixtures/parity/golden_outputs/graph_scikit-learn__scikit-learn-10297.json`

---

## 4. Code Review Notes

### 4.1 LocAgent Algorithm Strengths

**Strengths to Preserve**:
1. **Robust Error Handling**: Gracefully skips unparseable files (UnicodeDecodeError, SyntaxError)
2. **Relative Import Resolution**: Correctly handles `.`, `..`, etc.
3. **Fuzzy Callee Matching**: Uses suffix matching for unresolved function calls
4. **Empty Directory Cleanup**: Removes directories with no .py files
5. **Symlink Skipping**: Avoids circular references

**Edge Cases**:
- Nested classes (e.g., `Outer.Inner.method`)
- Decorators (must be included in source snippet)
- Async functions (treated same as sync functions)
- `__init__` methods (skipped in LocAgent - line 145-146)

### 4.2 Potential Rust Improvements

**Performance Optimizations**:
1. **Parallel File Parsing**: Use rayon to parse files concurrently
2. **Lazy Code Loading**: Store file paths, load code on-demand
3. **Memoized AST Parsing**: Cache parsed ASTs during import resolution
4. **Fast String Interning**: Use string arena for FQN storage

**Safety Improvements**:
1. **Strong Typing**: Rust enums for NodeType, EdgeType (vs Python strings)
2. **ID Validation**: Ensure no duplicate node IDs in graph
3. **Path Normalization**: Consistent use of relative paths

---

## 5. Testing Notes

### 5.1 Unit Test Coverage Required

**Graph Builder Tests** (`crates/cds-index/tests/graph_builder_tests.rs`):
1. **Node Extraction**:
   - Test: Simple class extraction
   - Test: Nested class extraction (`Outer.Inner`)
   - Test: Function with decorators
   - Test: Async function
   - Test: Skip `__init__` methods
2. **Edge Creation**:
   - Test: Directory contains file
   - Test: File contains class
   - Test: Class contains method
   - Test: Absolute import
   - Test: Relative import (`.`, `..`)
   - Test: Wildcard import (`from X import *`)
   - Test: Class inheritance
   - Test: Function invocation
3. **FQN Format**:
   - Test: Top-level function FQN
   - Test: Class method FQN
   - Test: Nested class FQN
4. **Error Handling**:
   - Test: Skip unparseable file
   - Test: Skip symlink
   - Test: Skip non-.py file
   - Test: Skip SKIP_DIRS
5. **Graph Properties**:
   - Test: No duplicate nodes
   - Test: All edges reference existing nodes
   - Test: Root directory "/" exists

### 5.2 Parity Validation Tests

**Comparison Script** (`scripts/compare-graph-parity.sh`):
```bash
# Compare Rust output against LocAgent baseline
cargo run --bin cds-index -- build-graph \
  tests/fixtures/repos/locagent \
  -o output/graph_locagent_rust.json

# Validate parity
python scripts/validate-graph-parity.py \
  tests/fixtures/parity/golden_outputs/graph_locagent.json \
  output/graph_locagent_rust.json \
  --threshold 0.02  # ≤2% variance
```

**Metrics to Compare**:
1. Total node count
2. Total edge count
3. Node counts by type
4. Edge counts by type
5. Sample of FQN matches (10% random sample)

---

## 6. TODO / Follow-up

**Immediate Next Steps** (Day 1-2):
- [ ] Create Rust module skeleton (`crates/cds-index/src/graph/`)
- [ ] Add tree-sitter-python dependency to Cargo.toml
- [ ] Define GraphNode and GraphEdge structs
- [ ] Implement directory traversal with SKIP_DIRS logic
- [ ] Parse classes/functions with tree-sitter

**Medium-term** (Day 3-4):
- [ ] Implement import resolution
- [ ] Implement invoke/inherit edge creation
- [ ] Add JSON serialization for output
- [ ] Write unit tests (>80% coverage)

**Final Validation** (Day 5):
- [ ] Run parity validation against all 6 baselines
- [ ] Verify ≤2% variance
- [ ] Benchmark performance (<5s for 1K files)
- [ ] Document known variances (if any)

**Blocked By**:
- None (T-06-01 parity methodology complete with baselines available)

**Blocks**:
- T-02-02 (Sparse Index) - needs graph structure
- T-03-01 (CLI Commands) - needs graph traversal API

---

**Status**: Specification review complete. Ready to begin implementation.
