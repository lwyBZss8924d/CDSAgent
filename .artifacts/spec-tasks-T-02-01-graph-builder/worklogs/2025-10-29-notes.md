# Development Notes - 2025-10-29

**Task**: T-02-01-graph-builder  
**Author**: Rust Dev 1

---

## Architecture Decisions

### Decision 1: Traverse `if TYPE_CHECKING` blocks during AST lookup

PROBLEM:  
Mark decorator subclasses live under `if TYPE_CHECKING:` in `src/_pytest/mark/structures.py`. Our previous `find_in_block()` stopped at the first non-matching statement, so these classes never reached the behavior pipeline, leaving inherits edges missing.

CHANGES:
`find_in_block()` now recurses into `Stmt::If` bodies/orelse, allowing entity segments to resolve even when definitions are guarded by type-checking blocks.

IMPACT:

- Restores six inherits edges for `_Skip*` / `_MarkDecorator` subclasses.
- Enables future features that rely on static type-only declarations.

### Decision 2: Alias-labelled import edges for grouped `from ... import ...`

PROBLEM:  
Django fixtures import dozens of symbols via `from .models import (...)`. We only emitted a single module-level edge (alias `None`), so parity expected counts (e.g., 5 edges for `models`) collapsed to 1 after dedup.

CHANGES:  
When `resolve_module_spec()` cannot find a concrete submodule, we still add `add_file_import_edge(..., Some(alias))` for each entity, and we propagate the same alias to scoped indices. This mirrors LocAgentâ€™s multiplicity while keeping attribute edges to the actual class definitions.

IMPACT:

- Restores 19 missing import edges across Django SWE fixtures.
- Keeps alias map fidelity for downstream invoke resolution.

### Decision 3: Maintain alias-specific edges for scoped imports

PROBLEM:  
Nested imports (e.g., function-level `from chardet import detect`) produced only file-level edges, leaving invoke resolution without the correct alias context.

CHANGES:  
Scoped indices receive alias-labelled edges identical to their enclosing module so that symbol lookup inside a function/class remains precise.

IMPACT:

- Ensures both scoped entity and module file share the alias entry.
- Prevents regressions in function-level invoke matching (Requests fixture).

---

## Outstanding Questions

1. Pytest invoke variance sits at +1.29% (2442/2474). Remaining gaps cluster around `_pytest/config` and `_pytest/monkeypatch`. Need targeted diagnostics that do not rely on per-file printouts.
2. Should alias-labelled module edges be gated behind a config flag to avoid double-counting once we reconcile LocAgent vs CDSAgent import semantics?

---

## Action Items for Next Session

- Instrument invoke resolution for `_pytest/config/__init__.py` helpers to close the final 32-edge gap.
- Add regression tests covering:
  - `if TYPE_CHECKING` import scopes.
  - Function-level `from ... import ...`* alias propagation.
- Prepare commit once invoke audit is finished and tests are added.
