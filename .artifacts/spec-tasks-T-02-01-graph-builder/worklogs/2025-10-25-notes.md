# Development Notes - T-02-01 Graph Builder (Day 2)

**Date**: 2025-10-25
**Task**: Graph Builder - AST Parsing & Construction
**Phase**: Core Implementation

---

## Implementation Progress

### Session 1: Graph Foundations (04:40:00Z - 05:00:00Z)

**Objective**: Establish core graph types and initial parser/builder infrastructure

**Work Completed**:

1. **Graph Module Core** (crates/cds-index/src/graph/mod.rs):
   - Replaced placeholder API with concrete types matching task deliverables
   - Defined `NodeType` enum: Directory, File, Class, Function
   - Defined `EdgeKind` enum: Contains, Imports, Invokes, Inherits
   - Created `GraphNode` struct with FQN, type, name, file, line range, code
   - Created `GraphEdge` with kind field only (enhanced later)
   - Implemented `DependencyGraph` wrapper with petgraph backend
   - Added ID→index HashMap for efficient parity checks
   - Public API: `node_count()`, `edge_count()`, `nodes()`, `edges()`

2. **Python Parser** (crates/cds-index/src/graph/parser.rs):
   - Tree-sitter-python integration
   - `PythonEntityExtractor` with tree_sitter::Parser
   - Stack-based entity walker matching LocAgent algorithm
   - Entity extraction logic:
     - Skips `__init__` methods (LocAgent line 145-146)
     - Tracks nested classes/functions with parent stack
     - Preserves line ranges via SourceRange struct
   - FQN generation: `filename:Class.method` format
   - Helper: `extract_entities(repo_path, file_path) -> Vec<GraphNode>`

3. **Graph Builder** (crates/cds-index/src/graph/builder.rs):
   - `GraphBuilder` struct with options (skip_dirs)
   - Main entry: `build_graph(repo_path) -> DependencyGraph`
   - Repository traversal with `walkdir` crate
   - Directory/file node creation
   - LocAgent skip logic (SKIP_DIRS constant)
   - Contains edge wiring: dir→file, file→entity, class→method
   - FQN-based parent-child relationship detection
   - `GraphBuildStats` for metrics (node counts by type, edge counts)

4. **Traversal Helpers** (crates/cds-index/src/graph/traversal.rs):
   - `TraversalFilter` struct for node/edge type filtering
   - `bfs_traverse()` function
   - Foundation for future JSON-RPC traverse endpoint

**Key Decisions**:

- **petgraph::Graph<GraphNode, GraphEdge, Directed>**: Rust equivalent of NetworkX MultiDiGraph
- **FQN format exactly matches LocAgent**: Required for ≤2% parity variance
- **Stack-based walker**: Mirrors LocAgent's CodeAnalyzer.visit_* pattern
- **Deferred edge resolution**: Import/invoke/inherit edges need all nodes to exist first

**Verification**:
- ✅ `cargo check -p cds-index` passes

---

### Session 2: Import Pipeline (05:00:00Z - 05:13:20Z)

**Objective**: Implement import resolution with alias tracking

**Work Completed**:

1. **Enhanced Edge Types** (crates/cds-index/src/graph/mod.rs):
   - Extended `GraphEdge` struct with `Option<String>` alias field
   - Maintains lightweight contains edges (alias = None)
   - Supports import edges with alias metadata (alias = Some("Engine"))
   - Updated BFS traversal to use richer edge struct

**Rationale**: LocAgent tracks import aliases for callee resolution. Example:
```python
from service import Service as Engine
# Later: engine = Engine()  <- needs alias lookup
```

2. **Import Analysis Types** (crates/cds-index/src/graph/parser.rs):
   - `ModuleSpecifier`: Represents import path (absolute or relative with level)
   - `ImportDirective`: Complete import statement with alias
   - `ImportEntity`: Individual entity from "from X import Y" statement
   - `extract_import_directives()`: Single-pass import extraction
   - Supports:
     - `import os` → ModuleSpecifier("os", level=0)
     - `from . import foo` → ModuleSpecifier("foo", level=1)
     - `from pkg import Class as C` → alias="C"
     - `from module import *` → wildcard=true

3. **Import Resolution Pipeline** (crates/cds-index/src/graph/builder.rs):
   - `process_import_edges()` method (called after all nodes exist)
   - Queues import directives during `walk_repository()`
   - Resolves modules after directory walk finishes
   - Resolution logic:
     - **Relative imports**: Convert level (`.`, `..`) to repo-relative path
     - **Absolute imports**: Direct module lookup
     - **Entity imports**: Try `module/entity.py`, fallback to `module.py::Entity`
     - **Wildcard imports**: Create edges to file only (no entity-level edges)
   - `resolve_module_path()` helper:
     - Handles `__init__.py` package detection
     - Normalizes paths relative to repo root
     - Supports level-based relative imports

4. **Behavior Edge Placeholder**:
   - Added `process_behavior_edges()` stub for invoke/inherit (Phase 4)
   - Pipeline structure ready for next phase

**Key Decisions**:

- **Store alias in edge metadata**: Required for invoke edge resolution later
- **Single-pass parsing**: Extract entities and imports in one tree-sitter parse
- **Deferred import resolution**: Can't resolve imports until all file nodes exist
- **Fallback to entity nodes**: `from pkg import Class` tries `pkg/Class.py` first, then `pkg.py::Class`

**Verification**:
- ✅ `cargo check -p cds-index` passes
- ✅ `cargo fmt` applied

---

### Session 3: Behavior Edges & Tests (05:13:20Z - 05:26:00Z)

**Objective**: Implement invoke/inherit detection and add initial tests

**Work Completed**:

1. **API Compatibility Fixes** (crates/cds-index/src/graph/builder.rs):
   - **Problem**: rustpython_parser API differs from Python ast module
   - **Solutions**:
     - `find_in_block()`: Match on `pyast::Stmt` directly instead of suite traversal
     - Decorator/async helpers: Use shared `visit_block()` walker
     - Try/except handling: `pyast::ExceptHandler::ExceptHandler` with `.type_` field
     - Removed obsolete `collect_calls_in_suite()` (API changed)
   - Updated function signatures to match current rustpython_parser v0.3.x

2. **Tree-sitter Integration Fix** (crates/cds-index/src/graph/parser.rs):
   - **Problem**: Linker error `_tree_sitter_python` symbol not found
   - **Root cause**: Hand-written extern "C" block incompatible with packaged bindings
   - **Solution**: Use `tree_sitter_python::LANGUAGE.into()` from crate
   - Removed manual FFI declaration
   - Leverages packaged tree-sitter-python grammar

3. **Invoke/Inherit Detection** (crates/cds-index/src/graph/builder.rs):
   - `process_behavior_edges()` implementation:
     - For each class/function node, parse its code into AST
     - Build "possible callee dict" from graph connectivity:
       - All entities imported by this file
       - All entities in same file
       - All entities in parent classes (for methods)
     - Walk AST to find function calls (pyast::Expr::Call)
     - Match call name to possible callees with fuzzy suffix matching
     - Create invoke edges
   - Class inheritance:
     - Parse class bases from pyast::Stmt::ClassDef
     - Resolve base class names
     - Create inherits edges
   - Decorator handling:
     - `collect_decorators()`: Extract decorator expressions
     - Create invoke edges from function to decorator
     - Handles aliased decorator imports
   - Async function support:
     - `collect_async_funcs()`: Extract async def blocks
     - Treat same as sync functions for invoke detection

4. **Unit Tests** (crates/cds-index/tests/graph_builder_tests.rs):
   - **Test 1**: `test_invoke_edge_with_alias()`
     - Creates in-memory repo with two files
     - File 1: `from service import Service as Engine`
     - File 2: `engine = Engine()` (invoke call)
     - Validates invoke edge created from caller to Service (via alias)
   - **Test 2**: `test_decorator_alias_invoke()`
     - File 1: `from decorators import log as logger`
     - File 2: `@logger def foo(): pass`
     - Validates invoke edge created from foo to log function
   - Added `petgraph::visit::EdgeRef` import for edge inspection
   - Tests prove alias resolution works correctly

5. **Worklog TODO** (.artifacts/spec-tasks-T-02-01-graph-builder/worklogs/2025-10-24-work-summary.md):
   - Recorded user's request to expand unit tests after T-02-01 coding wraps
   - Line 131: "After completing all development goals of T-02-01, update and refine all relevant unit tests"

**Key Decisions**:

- **Use rustpython_parser for Python AST**: More mature than hand-rolling parser
- **Fuzzy suffix matching for callees**: Handles unresolved names (e.g., `self.method()`)
- **Decorator creates invoke edge**: Matches LocAgent behavior
- **Async functions treated same as sync**: No special graph representation

**Verification**:
- ✅ `cargo check -p cds-index` passes
- ✅ `cargo test -p cds-index graph_builder_tests -- --nocapture` passes (2/2 tests)
- ⏳ Test coverage still low (~15% estimated)

---

## Technical Deep Dives

### 1. FQN Generation Algorithm

**LocAgent Reference**: tmp/LocAgent/dependency_graph/build_graph.py:120-176

**CDSAgent Implementation**:

```rust
// Top-level function in utils/helpers.py
fn generate_fqn(file_path: &str, entity_name: &str, parent_stack: &[String]) -> String {
    if parent_stack.is_empty() {
        // Top-level entity
        format!("{}:{}", file_path, entity_name)
    } else {
        // Nested entity
        let parent_fqn = parent_stack.join(".");
        format!("{}:{}.{}", file_path, parent_fqn, entity_name)
    }
}

// Examples:
// utils/helpers.py:sanitize_input  (top-level function)
// parser.py:CodeAnalyzer  (top-level class)
// parser.py:CodeAnalyzer.visit_ClassDef  (method)
// parser.py:Outer.Inner.method  (nested class method)
```

**Key Points**:
- Colon (`:`) separates file from entity
- Dot (`.`) separates nested entities
- Matches LocAgent format exactly for parity validation

### 2. Import Resolution Algorithm

**LocAgent Reference**: tmp/LocAgent/dependency_graph/build_graph.py:211-243

**Resolution Steps**:

```rust
fn resolve_import(
    module_spec: &ModuleSpecifier,
    importing_file: &Path,
    repo_path: &Path,
) -> Option<String> {
    // Step 1: Convert relative imports to absolute
    let absolute_module = if module_spec.level > 0 {
        // Relative: from . import foo or from .. import bar
        let parent_dirs = importing_file.parent()?;
        parent_dirs.ancestors().nth(module_spec.level - 1)?
            .join(&module_spec.name)
    } else {
        // Absolute: from os import path
        PathBuf::from(&module_spec.name)
    };

    // Step 2: Try as file (module.py)
    let file_path = absolute_module.with_extension("py");
    if file_path.exists() {
        return Some(file_path.to_str()?.to_string());
    }

    // Step 3: Try as package (__init__.py)
    let package_init = absolute_module.join("__init__.py");
    if package_init.exists() {
        return Some(package_init.to_str()?.to_string());
    }

    // Step 4: Not found (stdlib or external module)
    None
}

// Entity imports (from X import Y):
// 1. Try Y as submodule: X/Y.py
// 2. Fallback to entity in X: X.py::Y
```

**Edge Cases Handled**:
- Relative imports with multiple levels (`..`, `...`)
- Package imports with `__init__.py`
- Wildcard imports (`from X import *`) - only file-level edge
- Missing imports (stdlib/external) - skip edge creation

### 3. Invoke Edge Detection Algorithm

**LocAgent Reference**: tmp/LocAgent/dependency_graph/build_graph.py (find_all_possible_callee function)

**CDSAgent Algorithm**:

```rust
fn find_possible_callees(node_id: &str, graph: &DependencyGraph) -> HashMap<String, String> {
    let mut callees = HashMap::new();

    // Step 1: All entities imported by this file
    for edge in graph.edges_from(node_id) {
        if edge.kind == EdgeKind::Imports {
            let target = edge.target;
            let alias = edge.alias.unwrap_or(target.clone());
            callees.insert(alias, target);
        }
    }

    // Step 2: All entities in same file
    let file_id = extract_file_from_fqn(node_id);
    for node in graph.nodes() {
        if extract_file_from_fqn(&node.id) == file_id {
            callees.insert(node.name.clone(), node.id.clone());
        }
    }

    // Step 3: All entities in parent classes (for methods)
    if is_method(node_id) {
        let class_id = extract_class_from_fqn(node_id);
        for edge in graph.edges_from(class_id) {
            if edge.kind == EdgeKind::Inherits {
                // Add all methods from base class
                for node in graph.nodes() {
                    if node.id.starts_with(&edge.target) {
                        callees.insert(node.name.clone(), node.id.clone());
                    }
                }
            }
        }
    }

    callees
}

// Then match calls with fuzzy suffix matching:
for call in ast_calls {
    let call_name = call.func.name;
    if let Some(target_id) = callees.get(call_name) {
        graph.add_edge(node_id, target_id, EdgeKind::Invokes);
    } else {
        // Fuzzy match: "self.method" → "method"
        for (alias, target) in &callees {
            if call_name.ends_with(alias) {
                graph.add_edge(node_id, target, EdgeKind::Invokes);
                break;
            }
        }
    }
}
```

**Key Points**:
- **Alias awareness**: `import Service as Engine` → callees["Engine"] = "service.py::Service"
- **Fuzzy matching**: Handles `self.method()`, `obj.method()` calls
- **Inheritance support**: Methods can call parent class methods

### 4. Tree-sitter Integration

**Parser Initialization**:

```rust
use tree_sitter::{Parser, Language};
use tree_sitter_python::LANGUAGE as PYTHON_LANGUAGE;

let mut parser = Parser::new();
parser.set_language(&PYTHON_LANGUAGE.into()).unwrap();

let tree = parser.parse(source_code, None).unwrap();
let root_node = tree.root_node();
```

**Entity Extraction**:

```rust
fn extract_entities_from_tree(tree: &Tree, source: &str) -> Vec<GraphNode> {
    let mut entities = Vec::new();
    let mut cursor = tree.walk();

    // Walk to class/function definitions
    visit_node(&root_node, &mut |node| {
        match node.kind() {
            "class_definition" => {
                let name = node.child_by_field_name("name").unwrap()
                    .utf8_text(source.as_bytes()).unwrap();
                let line = node.start_position().row + 1;
                entities.push(GraphNode {
                    node_type: NodeType::Class,
                    name: name.to_string(),
                    line,
                    // ...
                });
            }
            "function_definition" => {
                // Similar to class
            }
            _ => {}
        }
    });

    entities
}
```

**Advantages over hand-rolled parser**:
- Handles all Python syntax (including Python 3.12 features)
- Robust error recovery
- Fast parsing (C implementation)
- Reusable query patterns

---

## Architecture Notes

### Module Structure

```text
crates/cds-index/src/graph/
├── mod.rs          (202 lines) - Public API, types, DependencyGraph wrapper
├── parser.rs       (426 lines) - Tree-sitter Python parsing, entity/import extraction
├── builder.rs      (1040 lines) - 4-phase graph construction pipeline
└── traversal.rs    (64 lines) - BFS traversal helpers

Total: 1,732 lines of core graph code
```

### Dependency Flow

```text
builder.rs
  ↓ uses
parser.rs (extract_entities, extract_import_directives)
  ↓ uses
tree_sitter_python (AST parsing)

builder.rs
  ↓ uses
rustpython_parser (AST parsing for invoke/inherit)

builder.rs
  ↓ constructs
DependencyGraph (mod.rs)
  ↓ wraps
petgraph::Graph<GraphNode, GraphEdge, Directed>
```

### Performance Considerations

**Current Implementation**:
- **Single-threaded**: All parsing happens sequentially
- **Full code loading**: Entire file read into memory per parse
- **No caching**: AST parsed twice (entities + behavior edges)

**Future Optimizations** (deferred to later):
1. **Parallel file parsing** with rayon
2. **Lazy code loading** (store file paths, load on-demand)
3. **Memoized AST parsing** (cache parsed trees)
4. **String interning** for FQNs (reduce memory)

**Target**: <5s for 1K files (LocAgent baseline: ~10s)

---

## Next Steps

### Day 3 Tasks

1. **Parity Validation**:
   - Run `scripts/parity-check.sh` against all 6 baselines
   - Compare node/edge counts (≤2% threshold)
   - Validate FQN format matches LocAgent golden outputs
   - Document any variances

2. **Test Expansion**:
   - Parser tests (nested classes, async functions, decorators)
   - Edge creation tests (all 4 edge types)
   - FQN format validation tests
   - Error handling tests (unparseable files, symlinks)
   - Graph property tests (no duplicates, valid edge targets)
   - Target: >80% test coverage

3. **Bug Fixes**:
   - Address any parity validation failures
   - Fix edge cases discovered during testing

### Day 4-5 Tasks

1. **Performance Benchmarking**:
   - Measure index build time on 1K file repo
   - Compare with LocAgent Python baseline
   - Profile hotspots if needed

2. **Documentation**:
   - Update README with graph builder usage
   - Document known limitations
   - Add architecture diagram

3. **PR Preparation**:
   - Run `cargo fmt --all`
   - Run `cargo clippy --all-targets`
   - Ensure all tests pass
   - Write comprehensive PR description

---

## Known Limitations

1. **Test Coverage**: Currently ~15% (2 tests), needs expansion to >80%
2. **Parity Validation**: Not yet run against baselines
3. **Edge Cases**: Some complex scenarios may not be handled:
   - Dynamic imports (`importlib.import_module()`)
   - Complex relative imports (>2 levels: `...`)
   - Star imports with name conflicts
4. **Performance**: Not yet optimized (single-threaded, full code loading)

---

## References

**LocAgent Implementation**:
- tmp/LocAgent/dependency_graph/build_graph.py (400+ lines)
- tmp/LocAgent/dependency_graph/traverse_graph.py (graph traversal)

**Parity Baselines**:
- tests/fixtures/parity/golden_outputs/graph_*.json (6 repos)
- tests/fixtures/parity/golden_outputs/README.md (baseline documentation)

**PRD Requirements**:
- spacs/prd/0.1.0-MVP-PRDs-v0/02-cds-index-service.md (FR-CG-1, FR-CG-2)
- spacs/prd/0.1.0-MVP-PRDs-v0/06-rust-refactoring-plan.md (refactoring strategy)

**Task Specifications**:
- spacs/tasks/0.1.0-mvp/02-index-core/T-02-01-graph-builder.md (acceptance criteria)
- spacs/issues/04-0.1.0-mvp/02-index-core/01-graph-build.md (technical breakdown)

---

**Status**: Day 2 core implementation complete. Ready for parity validation and test expansion.
