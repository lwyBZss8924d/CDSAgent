# Development Notes - 2025-10-28

**Task**: T-02-01-graph-builder
**Author**: Rust Dev 1

---

## Architecture Decisions

### Decision 1: Multi-Target Alias Map

**Context**: Yesterday's single-target alias map (`HashMap<String, GraphNodeIndex>`) could only store one definition per name, causing missing invoke edges when multiple modules export the same function.

**Options Considered**:

1. **Keep single target, use first match** (current behavior yesterday)
   - ‚ùå Leads to false negatives (missing edges)
   - ‚ùå Non-deterministic (depends on import order)

2. **Use Vec `<GraphNodeIndex>` for all aliases**
   - ‚úÖ Ensures completeness (no false negatives)
   - ‚ö†Ô∏è May increase false positives if no filtering
   - ‚úÖ Deterministic (all reachable targets discovered)

3. **Use priority/scoring system** (LocAgent approach)
   - ‚ö†Ô∏è Complex to implement without LocAgent's context
   - ‚ö†Ô∏è May still miss legitimate edges

**Decision**: Chose **Option 2** - Vec `<GraphNodeIndex>` for multi-target support

**Rationale**:

- Prioritize completeness over precision initially
- Easier to filter out false positives than recover false negatives
- Can add heuristics later once we understand patterns

**Implementation**:

```rust
// Before (Day 3):
type AliasMap = HashMap<String, GraphNodeIndex>;

// After (Day 4):
type AliasMap = HashMap<String, Vec<GraphNodeIndex>>;

fn insert_alias(
    aliases: &mut HashMap<String, Vec<GraphNodeIndex>>,
    name: String,
    target: GraphNodeIndex,
) {
    if name.is_empty() {
        return;
    }
    let entry = aliases.entry(name).or_default();
    if !entry.contains(&target) {
        entry.push(target);
    }
}
```

**Impact**:

- ‚úÖ No missing edges due to alias conflicts
- ‚úÖ Test coverage confirms all candidates discovered
- ‚ö†Ô∏è Invoke variance increased +4.5% (from +1.9% to +6.4%)
- üìã Next: Add filtering to reduce false positives

---

### Decision 2: Deferred Wildcard Export Handling

**Context**: Wildcard imports (`from module import *`) need to know the target module's `__all__` list, but that module may not be parsed yet (dependency order).

**Problem**:

```python
# file A.py
from B import *  # What names does B export?

# file B.py (not parsed yet)
__all__ = ["func1", "func2"]
def func1(): pass
def func2(): pass
```

**Options Considered**:

1. **Two-pass processing** (parse all files, then resolve imports)
   - ‚úÖ Simple conceptually
   - ‚ùå Memory-intensive (hold all ASTs)
   - ‚ùå Doesn't handle cyclic dependencies

2. **Deferred queue with retry** (chosen)
   - ‚úÖ Memory-efficient (parse-as-you-go)
   - ‚úÖ Handles cyclic deps with max retries
   - ‚ö†Ô∏è Slightly more complex logic

3. **Fallback to all exported symbols** (no `__all__` check)
   - ‚ùå Too permissive (imports private symbols)
   - ‚ùå Doesn't match LocAgent behavior

**Decision**: Chose **Option 2** - Deferred queue with PendingWildcardExport

**Implementation**:

```rust
struct PendingWildcardExport {
    source_idx: GraphNodeIndex,
    module_path: PathBuf,
}

fn enqueue_wildcard_export(&mut self, source_idx: GraphNodeIndex, module_path: &Path) {
    // Only enqueue if target module not yet processed
    if self.module_exports.get(module_path).is_none() {
        self.pending_wildcard_exports.push(PendingWildcardExport {
            source_idx,
            module_path: module_path.to_path_buf(),
        });
    }
}

fn resolve_pending_wildcard_exports(&mut self) {
    let mut remaining = Vec::new();
    let mut progress = true;
    let mut attempts = 0;

    while progress && attempts < 4 {
        progress = false;
        attempts += 1;
        let pending = std::mem::take(&mut self.pending_wildcard_exports);
        for entry in pending {
            if self.add_wildcard_export_edges(entry.source_idx, &entry.module_path) {
                progress = true;  // Successfully processed
            } else {
                remaining.push(entry);  // Retry later
            }
        }
        self.pending_wildcard_exports = remaining;
        remaining = Vec::new();
    }
}
```

**Rationale**:

- Respects `__all__` constraints (matches LocAgent)
- Handles parse order independence
- Max 4 retries handles most cyclic dependency cases

**Impact**:

- ‚úÖ Wildcard imports now correctly respect `__all__`
- ‚úÖ No false imports of private symbols
- ‚ö†Ô∏è May leave some unresolved if cyclic depth > 4 (acceptable for now)

---

## Implementation Details

### Multi-Target Invoke Edge Wiring

**Location**: `crates/cds-index/src/graph/builder.rs:1076-1097`

**Key Changes**:

1. **Local deduplication** with `seen_targets: HashSet<GraphNodeIndex>`
   - Prevents duplicate edges within single caller's invocations
   - Example: `main()` calls `merge()` 3 times ‚Üí only 1 edge

2. **Global deduplication** with `behavior_edge_cache`
   - Prevents duplicate edges across entire graph
   - Example: two functions call same callee ‚Üí each gets 1 edge

3. **Iterate over all targets** from `resolve_targets()`
   - Old: `if let Some(target_idx) = alias_map.get(name)`
   - New: `for target_idx in self.resolve_targets(rel_path, alias_map, name)`

**Code**:

```rust
fn connect_behavior_edges(
    &mut self,
    caller_idx: GraphNodeIndex,
    rel_path: &Path,
    alias_map: &HashMap<String, Vec<GraphNodeIndex>>,
    names: &[String],
    kind: EdgeKind,
) {
    let mut seen_targets = HashSet::new();  // Local dedup
    for name in names {
        let targets = self.resolve_targets(rel_path, alias_map, name);
        for target_idx in targets {
            if seen_targets.insert(target_idx)  // First check local dedup
                && self.behavior_edge_cache.insert((caller_idx, target_idx, kind))  // Then global
            {
                self.graph.add_edge(caller_idx, target_idx, kind);
            }
        }
    }
}
```

**Edge Cases Handled**:

- ‚úÖ Same callee invoked multiple times ‚Üí 1 edge
- ‚úÖ Multiple callees with same name ‚Üí N edges (one per target)
- ‚úÖ Transitive imports (A imports B imports C) ‚Üí follows full chain

---

### resolve_targets() Method

**Purpose**: Unified target resolution for behavior edges (invoke/inherit)

**Logic**:

1. Check alias_map first (imported/wildcard names)
2. Fallback to file_symbols (local definitions in same file)
3. Return all candidates as Vec `<GraphNodeIndex>`

**Code**:

```rust
fn resolve_targets(
    &self,
    rel_path: &Path,
    alias_map: &HashMap<String, Vec<GraphNodeIndex>>,
    name: &str,
) -> Vec<GraphNodeIndex> {
    let mut result = Vec::new();

    // Check imports/wildcards
    if let Some(entries) = alias_map.get(name) {
        result.extend(entries.iter().copied());
    }

    // Check local definitions (fallback)
    if let Some(symbols) = self.file_symbols.get(rel_path) {
        if let Some(&idx) = symbols.get(name) {
            if !result.contains(&idx) {
                result.push(idx);
            }
        }
    }

    result
}
```

**Why separate method?**

- ‚úÖ Reusable for both invoke and inherit edges
- ‚úÖ Clear separation of concerns (resolution vs edge creation)
- ‚úÖ Easier to add filtering heuristics later (single place)

---

## Research & Learning

### LocAgent's find_all_possible_callee

**Location**: `tmp/LocAgent/dependency_graph/build_graph.py:~400-450`

**Key Observations** (from reading reference implementation):

1. **Prioritizes local definitions over imports**
   - First checks if name defined in same file
   - Only searches imports if not found locally

2. **Filters by import scope**
   - Only considers names explicitly imported
   - Doesn't traverse transitive wildcard imports

3. **Handles decorators specially**
   - Tracks decorator application as separate edge type
   - May explain why we have extra edges

4. **Recursive search limited**
   - Stops at package boundaries (doesn't cross to unrelated packages)
   - May use import distance heuristic

**Implications for CDSAgent**:

- We may be too permissive with wildcard traversal
- Need to add package boundary checks
- May need import distance metric

**Action Items**:

- [ ] Compare LocAgent's import resolution step-by-step
- [ ] Add unit tests for each heuristic before implementing
- [ ] Document differences in approach

---

## Testing Notes

### Unit Test: invoke_edges_include_all_alias_candidates

**Purpose**: Validate multi-target alias resolution for invoke edges

**Scenario Setup**:

```python
# pkg/a.py
def merge(x, y):
    return x + y

# pkg/b.py
def merge(x, y):
    return x * y

# client.py
from pkg.a import merge as merge_a
from pkg.b import merge as merge_b

def main():
    merge_a(1, 2)  # ‚Üí pkg/a.py::merge
    merge_b(3, 4)  # ‚Üí pkg/b.py::merge
```

**Expectations**:

- `client.py::main` has 2 invoke edges:
  1. ‚Üí `pkg/a.py::merge`
  2. ‚Üí `pkg/b.py::merge`

**Test Code** (lines 420-480):

```rust
#[test]
fn invoke_edges_include_all_alias_candidates() {
    let dir = create_temp_test_dir("multi_alias");
    // ... setup pkg/a.py, pkg/b.py, client.py ...

    let builder = GraphBuilder::new(&dir);
    let result = builder.build().unwrap();
    let graph = result.graph;

    // Find client::main node
    let main_idx = graph.get_index("client.py::main").unwrap();

    // Collect invoke edges
    let invokes: Vec<_> = graph
        .graph()
        .edges(main_idx)
        .filter(|e| e.weight().kind == EdgeKind::Invoke)
        .map(|e| e.target())
        .collect();

    // Assert both targets discovered
    assert_eq!(invokes.len(), 2);
    let has_merge_a = invokes.iter().any(|&idx| {
        graph.node(idx).unwrap().id.contains("pkg/a.py::merge")
    });
    let has_merge_b = invokes.iter().any(|&idx| {
        graph.node(idx).unwrap().id.contains("pkg/b.py::merge")
    });
    assert!(has_merge_a);
    assert!(has_merge_b);
}
```

**Result**: ‚úÖ Test passes - confirms multi-target resolution working

---

## Performance Notes

### Alias Map Memory Impact

**Before (Day 3)**:

- `HashMap<String, GraphNodeIndex>`
- Memory: ~16 bytes per entry (8 for String, 8 for u32 index)
- Typical graph (LocAgent): ~1,500 entries ‚Üí 24 KB

**After (Day 4)**:

- `HashMap<String, Vec<GraphNodeIndex>>`
- Memory: ~24 bytes per entry (8 for String, 16 for Vec allocation + capacity)
- Average Vec length: 1.2 targets per name (estimated)
- Typical graph: ~1,500 entries √ó 1.2 targets ‚Üí ~43 KB

**Impact**: ~+19 KB memory per graph (~80% increase)

**Assessment**:

- ‚úÖ Acceptable overhead for correctness
- ‚úÖ Still scales linearly with repo size
- ‚úÖ No performance degradation observed in tests

---

## TODO / Follow-up

### Immediate (Day 5)

- [ ] **Audit extra invoke edges**
  - Enable PARITY_DEBUG output
  - Categorize: self-recursive, cross-package, legitimate
  - Create spreadsheet with edge analysis

- [ ] **Implement filtering heuristics**
  - Self-recursion filter (same file calls)
  - Package boundary filter (cross-package constraints)
  - Import distance metric (prioritize direct imports)

- [ ] **Re-run parity after each filter**
  - Target: reduce variance from +6.4% to ‚â§2%
  - Document each filter's impact

### Near-term (Week 3)

- [ ] **Expand unit test coverage**
  - Add tests for each filtering heuristic
  - Property-based tests for alias resolution
  - Target >80% coverage

- [ ] **SWE-bench parity validation**
  - Run on django, scikit-learn, pytest, requests, matplotlib
  - Ensure variance ‚â§2% across all fixtures

### Long-term (Post-M2)

- [ ] **Performance optimization**
  - Profile alias map lookups
  - Consider more efficient data structure if needed
  - Benchmark on large repos (>10K files)

- [ ] **Code documentation**
  - Add rustdoc comments to all public methods
  - Document filtering heuristics rationale
  - Create architecture diagram for alias resolution

---

## Questions / Blockers

### Q1: Should we filter self-recursive calls?

**Context**: `auto_search_main.py::main ‚Üí auto_search_main.py::merge` (both in same file)

**Options**:

1. Filter all same-file calls ‚Üí May miss legitimate self-module dependencies
2. Filter only when caller == callee ‚Üí May still over-filter
3. Keep all ‚Üí Current behavior, leads to +6.4% variance

**Decision**: TBD - Need to check LocAgent's behavior

### Q2: How to handle decorators?

**Context**: LocAgent tracks decorator application separately, we currently treat as regular invoke

**Options**:

1. Add new edge type `EdgeKind::Decorate`
2. Filter decorator invokes from standard invoke edges
3. Keep current behavior

**Decision**: TBD - Need to analyze impact on parity

---

## Key Insights

1. **Completeness vs Precision Trade-off**
   - Multi-target approach prioritizes completeness (no false negatives)
   - Can filter down to improve precision later
   - Harder to recover from false negatives than filter false positives

2. **Deferred Resolution Pattern**
   - Works well for cyclic dependencies
   - Generalizable to other graph operations (e.g., inheritance chains)
   - Consider extracting as reusable pattern

3. **Test-Driven Edge Case Discovery**
   - Unit test discovered multi-alias scenario that wasn't in parity baseline
   - Regression tests prevent backsliding when adding filters
   - Consider fuzzing for discovering more edge cases

---

End of Day 4 Notes session-01
