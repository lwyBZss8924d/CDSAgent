# Development Notes - 2025-10-31

**Task**: T-02-02-sparse-index
**Date**: 2025-10-31

---

## Technical Notes

### Architecture Decisions

- **Decision 1**: Hierarchical two-tier index design
  - Upper tier: Name/ID HashMap for exact and prefix matching
  - Lower tier: BM25 full-text search for content-based retrieval
  - Rationale: Balances speed (HashMap O(1)) with recall (BM25 semantic ranking)

- **Decision 2**: Defer BM25 library choice until Phase 3
  - Options: Tantivy (full-featured) vs custom implementation
  - Need to evaluate: LocAgent parity requirements, memory footprint, latency targets

### Implementation Details

#### Phase 1: Upper Index (Name/ID HashMap) - Days 1-2

Not yet implemented. Planned structure:

```rust
pub struct NameIndex {
    // Exact name → entity ID mapping
    exact_map: HashMap<String, EntityId>,

    // Prefix → entity IDs mapping (for autocomplete/fuzzy search)
    prefix_trie: HashMap<String, Vec<EntityId>>,

    // Reverse lookup: entity ID → metadata
    entities: HashMap<EntityId, EntityMetadata>,
}
```

Design considerations:

- Use fully-qualified names from T-02-01 graph builder
- Support both exact match and prefix queries
- Optimize for low memory overhead (target: <100MB for 10K entities)

#### Phase 2: Tokenizer - Day 3

Custom tokenizer to match LocAgent behavior:

- Word-level tokenization with camelCase/snake_case splitting
- Stop word removal? (TBD - check LocAgent implementation)
- Stemming? (TBD - check LocAgent implementation)

### Dependencies

- **Internal**: `crates/cds-index/src/graph` (T-02-01 completed)
  - Provides entity metadata: name, type, file path, AST range
  - Graph traversal for context expansion (e.g., class context for methods)

- **External**: TBD based on BM25 implementation choice
  - Option A: `tantivy = "0.22"` (full Lucene-like features)
  - Option B: Custom BM25 with `rust-tokenizers` or `unicode-segmentation`

## Research & Learning

### Questions Investigated

1. **Question**: What BM25 parameters does LocAgent use?
   - **Answer**: Need to check `tmp/LocAgent/plugins/location_tools/retriever/bm25_retriever.py`
   - **Key Insight**: LocAgent likely uses default k1=1.5, b=0.75 (standard Okapi BM25)
   - **References**: Will document in Phase 3 after examining LocAgent code

2. **Question**: How to achieve 90% search overlap@10 target?
   - **Answer**: Requires:
     1. Matching LocAgent tokenization (critical!)
     2. Same BM25 parameters (k1, b)
     3. Same document chunking strategy (if any)
   - **References**: T-06-01 parity baselines in `tests/fixtures/parity/golden_outputs/search_queries.jsonl`

### New Learnings

- T-02-01 graph builder provides solid foundation: 4 node types, 4 edge types, <2% parity variance
- 50 search queries from LocAgent available as baseline (T-06-01 Phase 2)
- Performance target: <500ms p95 latency, <5s index build for 1K files

## Code Review Notes

### Self-Review Checklist

- [ ] Code follows project style guide (rustfmt)
- [ ] Unit tests added (target: >95% coverage)
- [ ] Documentation updated (inline docs + README)
- [ ] No commented-out code
- [ ] Error handling implemented
- [ ] Performance considerations addressed (benchmarks in place)

### Future Refactoring Opportunities

- Consider trait-based index abstraction for pluggable backends
- Explore incremental index updates (vs full rebuild)

## Testing Notes

### Test Strategy

1. **Unit tests** (crates/cds-index/tests/index_tests.rs):
   - Name index: exact match, prefix match, case sensitivity
   - BM25: scoring correctness, parameter tuning
   - Tokenizer: edge cases (unicode, punctuation, camelCase)

2. **Parity tests** (crates/cds-index/tests/search_parity_tests.rs):
   - Use 50 search queries from T-06-01 baselines
   - Measure overlap@10 against LocAgent results
   - Target: ≥90% overlap

3. **Benchmark tests** (crates/cds-index/benches/search_bench.rs):
   - Latency: p50, p95, p99 for various query types
   - Throughput: queries per second
   - Index build time: varies by repo size

### Test Coverage

Not yet measured. Will use `cargo tarpaulin` after Phase 1 implementation.

## Performance Notes

### Target Metrics (from acceptance criteria)

- Search latency: <500ms p95
- Index build: <5s for 1K files
- Memory: TBD (reasonable upper bound needed)

### Optimization Ideas

- Lazy index loading (mmap for large indices)
- Query result caching (LRU cache for frequent queries)
- Parallel index construction (rayon for multi-core utilization)

## TODO / Follow-up

- [ ] Review LocAgent BM25 implementation (`tmp/LocAgent/plugins/location_tools/retriever/bm25_retriever.py`)
- [ ] Review LocAgent tokenizer (`tmp/LocAgent/repo_index/utils/tokenization.py`)
- [ ] Design Upper Index API (search by name, search by prefix)
- [ ] Set up benchmark framework (criterion.rs)
- [ ] Create test fixtures for index tests

## References

- **PRD**: spacs/prd/0.1.0-MVP-PRDs-v0/02-cds-index-service.md (Section 3.2: Index Architecture)
- **Issue**: spacs/issues/04-0.1.0-mvp/02-index-core/02-sparse-index.md
- **Task**: spacs/tasks/0.1.0-mvp/02-index-core/T-02-02-sparse-index.md
- **Parity baseline**: tests/fixtures/parity/golden_outputs/search_queries.jsonl (50 queries from T-06-01)
- **LocAgent reference**: tmp/LocAgent/plugins/location_tools/retriever/bm25_retriever.py

---

**Session Duration**: 0.2 hours (12 minutes - Day 1 Session 1)
**Productivity**: High (documentation updates completed)
**Blockers**: None

---

## Session 02: Phase 0 Research Findings (10:22-10:55 UTC)

### Technical Decisions Finalized

#### Decision: Tantivy Integration Strategy

- **Primary Choice**: Use Tantivy with custom analyzer chain
- **Custom Analyzer Components**:
  - Lowercase transformer
  - Camel/snake case splitter (e.g., `getUserName` → `get`, `user`, `name`)
  - ASCII folding (unicode normalization)
  - English stemmer (Porter stemmer)
- **Parity Target**: Stay within ±5% of LocAgent BM25 rankings
- **Fallback Option**: Pluggable `BM25Backend` trait allows custom implementation if overlap@10 <90%

#### Decision: NameIndex Architecture

```rust
// Builder pattern for concurrent ingestion
struct NameIndexBuilder {
    // DashMap for thread-safe concurrent inserts during graph parsing
    names: DashMap<String, Vec<GraphNodeIndex>>,
    type_filters: DashMap<EntityType, HashSet<GraphNodeIndex>>,
}

// Compact immutable structure for queries
struct NameIndexInner {
    // Sorted keys for binary search + prefix scanning
    sorted_keys: Vec<String>,
    // Direct entity lookup
    entity_map: HashMap<String, Vec<EntityMetadata>>,
    // Type-based filtering support
    type_index: HashMap<EntityType, Vec<EntityMetadata>>,
}

pub struct NameIndex(Arc<NameIndexInner>);
```

**Performance Targets**:
- Exact lookup: O(log n) via binary search on sorted keys
- Prefix query: <10ms for typical prefixes (scan sorted region)
- Memory: ~100 bytes per entity (10K entities = ~1MB overhead)

#### Decision: Search Pipeline Hierarchy

1. **Upper Index Query** (UpperIndex - exact/prefix match)
   - Score: 1.0 for exact matches
   - Entity type filtering applied
   - Return up to 5 results (configurable threshold)

2. **Deduplication Gate**
   - Track seen entity IDs from upper index
   - Prevent BM25 from returning duplicates

3. **Lower Index Query** (BM25 - full-text semantic search)
   - Score: Normalized to (0.0, 1.0) range
   - Query expansion with stemming
   - Return top 10 after deduplication

4. **Merged Results**
   - Combine upper + lower results
   - Sort by score (desc), then by entity name (asc) for ties
   - Return final top-K

### Implementation Roadmap (Refined)

**Day 1 PM (Session 03 - ~4h):**
- Implement `NameIndex` builder + exact/prefix match
- Wire graph integration (consume `CodeGraph` entities)
- Unit tests in `tests/index_tests.rs` (exact, prefix, type filtering)
- Basic benchmarks in `benches/search_bench.rs`

**Day 2 AM (~3h):**
- Implement `tokenizer.rs` with LocAgent-compatible rules
- Extract LocAgent stop-word list → `tests/fixtures/parity/tokenizer/stop_words.txt`
- Integrate Tantivy with custom analyzer
- Create `BM25Backend` trait for pluggability

**Day 2 PM (~3h):**
- Implement hierarchical `SearchPipeline`
- Add parity tests loading `search_queries.jsonl`
- Measure overlap@10 against LocAgent baselines
- Tune BM25 parameters (k1, b) if needed

**Day 3 AM (~2h):**
- Criterion benchmarks with performance baselines
- Memory profiling (ensure <100MB for 10K entities)
- Documentation (inline docs + README updates)

### Parity Assets Catalogued

**Available Fixtures** (`tests/fixtures/parity/golden_outputs/`):
- `search_queries.jsonl`: 50 queries with expected top-10 entity IDs from LocAgent
- `performance_baselines.json`: Latency/throughput targets for CDSAgent vs LocAgent
- Graph fixtures: 6 repos (658 to 6,876 nodes each)

**Parity Validation Strategy**:
```rust
#[test]
fn test_search_parity_overlap_at_10() {
    let queries = load_fixture("search_queries.jsonl");
    let cds_engine = build_search_engine_from_graph();
    
    let mut overlaps = Vec::new();
    for query in queries {
        let cds_results = cds_engine.search(&query.text, 10);
        let locagent_expected = query.expected_top_10;
        let overlap = compute_overlap_at_k(cds_results, locagent_expected, 10);
        overlaps.push(overlap);
    }
    
    let avg_overlap = overlaps.iter().sum::<f64>() / overlaps.len() as f64;
    assert!(avg_overlap >= 0.90, "Average overlap@10: {:.2}%", avg_overlap * 100.0);
}
```

### Open Questions Resolved

1. **Q**: Tantivy vs custom BM25?  
   **A**: Start with Tantivy (proven, well-tested); retain trait-based abstraction for swapping.

2. **Q**: Tokenization match with LocAgent?  
   **A**: Port camel/snake splitting + stop-word trimming; back with golden fixtures to guarantee fidelity.

3. **Q**: Upper index prefix scan performance?  
   **A**: Sorted keys enable binary search (O(log n)) + linear scan of prefix region (<10ms target achievable).

4. **Q**: Search hierarchy threshold tuning?  
   **A**: Default 5 upper results before BM25 fallback; expose config knobs for CLI/service.

5. **Q**: Parity validation automation?  
   **A**: `tests/index_parity_tests.rs` loads `search_queries.jsonl`, gates CI on 90% overlap@10 average.

### Follow-up Action Items

**Due Day 1 EOD (2025-10-31):**
- [ ] Extract LocAgent stop-word list via Python script
- [ ] Create `tests/support/parity_loader.rs` helper module
- [ ] Define `TANTIVY_DATA_DIR` env var + config
- [ ] Scaffold `tests/index_parity_tests.rs` with fixture loader signature

**Due Day 2 AM (2025-11-01):**
- [ ] Confirm subset of sample repos for Criterion bench
- [ ] Document bench setup in `crates/cds-index/benches/README.md`
- [ ] Verify Tantivy version compatibility (target 0.22.x)

---

**Session Duration Updated**: 1.8 hours (Session 01: 0.2h + Session 02: 0.55h + setup: ~0.1h + checkpoint: ~0.95h)
**Phase 0 Status**: ✅ COMPLETE
**Next Phase**: Phase 1 (Upper Index Implementation) - Session 03

