# Development Notes - 2025-10-31 Session 03

**Task**: T-02-02-sparse-index
**Session**: 03 (Phase 1: Upper Index Implementation)
**Date**: 2025-10-31

---

## Technical Notes

### Architecture Decisions

#### Decision 1: NameIndex Data Structure Design

**Chosen Architecture**:

```rust
pub struct NameIndex {
    lookup: HashMap<Arc<str>, Arc<[NameEntry]>>,  // Normalized name → entries
    sorted_keys: Vec<Arc<str>>,                    // Binary search for prefix
    stats: NameIndexStats,                         // Aggregate metadata
}

pub struct NameIndexBuilder {
    entries: DashMap<String, Vec<PendingEntry>>,  // Concurrent ingestion
}
```

**Rationale**:

- **HashMap lookup**: O(1) exact match
- **Sorted keys**: O(log n) binary search for prefix queries
- **Arc sharing**: Minimize memory overhead (shared keys between lookup and sorted_keys)
- **DashMap builder**: Thread-safe concurrent inserts during graph parsing
- **Immutable compaction**: Arc<[NameEntry]> prevents mutation after build

**Trade-offs**:

- Memory: ~2x overhead for sorted_keys (acceptable for <10K entities)
- Build time: O(n log n) sort + dedup (2.287ms for 1,024 entities - well within budget)

#### Decision 2: Key Normalization Strategy

**Approach**: Simple lowercase + trim

```rust
fn normalize_key(value: &str) -> String {
    value.trim().to_lowercase()
}
```

**Rationale**:

- **Defer complexity**: Leave camel/snake splitting to Phase 2 tokenizer
- **Case-insensitive**: Matches LocAgent behavior for name queries
- **ASCII-only**: Sufficient for Python identifier rules (no unicode in names)

**Future Enhancement** (Phase 2):

```rust
// Will add camel/snake splitting:
// "getUserName" → ["get", "user", "name"]
// "parse_ast_node" → ["parse", "ast", "node"]
```

#### Decision 3: Prefix Query Implementation

**Algorithm**:

1. Normalize prefix → lowercase
2. Binary search sorted_keys for first matching key (lower_bound)
3. Linear scan forward while keys match prefix
4. Collect entries with optional NodeKind filtering
5. Truncate to limit

**Complexity**:

- Binary search: O(log n)
- Linear scan: O(k) where k = matching keys
- Overall: O(log n + k) ≈ O(log n) for typical queries

**Performance**: 699 ns median (far below 10ms target)

---

## Implementation Details

### Phase 1: Upper Index Core

#### NameEntry Structure

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct NameEntry {
    pub name: Arc<str>,                  // Display name (e.g., "getUserName")
    pub qualified_name: Option<Arc<str>>, // Fully-qualified (e.g., "pkg::auth::getUserName")
    pub node_id: GraphNodeIndex,         // Graph node reference
    pub kind: NodeKind,                  // Directory/File/Class/Function
}
```

**Design Notes**:

- `Arc<str>` for memory sharing across multiple entries with same name
- `qualified_name` optional for graph nodes without full paths (e.g., directories)
- `node_id` enables graph traversal from index results

#### Builder → Immutable Compaction

**Build Flow**:

```rust
// 1. Concurrent ingestion
let builder = NameIndexBuilder::with_capacity(graph.node_count());
for node in graph.nodes() {
    builder.insert_graph_node(node_idx, node);  // Thread-safe
}

// 2. Compact to immutable structure
let index = builder.finish();  // Sorts, deduplicates, wraps in Arc
```

**Compaction Steps**:

1. Extract all (normalized_key, entries) pairs from DashMap
2. Sort entries by name, then node_id
3. Deduplicate by node_id (handle concurrent duplicate inserts)
4. Sort pairs by normalized key
5. Wrap entries in Arc<[NameEntry]> for immutability
6. Build sorted_keys Vec for binary search

**Deduplication Logic**:

```rust
values.dedup_by_key(|entry| entry.node_id);
```

- Handles case where concurrent threads insert same entity multiple times
- Keeps first occurrence (stable sort guarantees predictable behavior)

#### Graph Integration

**from_graph() Helper**:

```rust
pub fn from_graph(graph: &DependencyGraph) -> Self {
    let builder = NameIndexBuilder::with_capacity(graph.node_count());

    for node_idx in graph.graph().node_indices() {
        if let Some(node) = graph.node(node_idx) {
            builder.insert_graph_node(node_idx, node);
        }
    }

    builder.finish()
}
```

**Graph Node Extraction**:

- Uses `display_name` from GraphNode (already normalized in graph builder)
- Skips empty display names (e.g., directory nodes without names)
- Preserves `qualified_name` from GraphNode.id

---

## Testing Strategy

### Unit Test Coverage

**Test Categories**:

1. **Normalization Tests**:
   - `normalize_lowercases_and_trims()`: "  AuthService  " → "authservice"

2. **Binary Search Tests**:
   - `lower_bound_locates_first_not_less_than_target()`: Verify O(log n) correctness

3. **Builder Tests**:
   - `builder_ignores_empty_names_and_deduplicates()`: Edge cases
   - Empty names skipped
   - Whitespace-only names skipped
   - Duplicate node_ids deduplicated

4. **Exact Match Tests**:
   - `exact_match_is_case_insensitive()`: "AUTHservice" matches "authservice"
   - Multiple entries with same normalized name returned

5. **Prefix Match Tests**:
   - `prefix_match_respects_limit_and_kind_filter()`: Filtering + truncation
   - `zero_limit_short_circuits_queries()`: Early exit optimization

6. **Graph Integration Tests**:
   - `from_graph_ingests_display_names()`: End-to-end graph → index flow
   - Empty display names ignored
   - Stats counts accurate

7. **Edge Case Tests**:
   - `new_index_is_empty()`: Default construction
   - `entries_for_exposes_underlying_entries()`: Direct access API

**Coverage Tools**:

```shell
cargo llvm-cov --package cds-index --tests --summary-only --no-clean
```

**Final Metrics**:

- **Lines**: 97.20% (target: >95%) ✅
- **Functions**: 95.35% (target: >95%) ✅

---

## Performance Notes

### Benchmark Methodology

**Tool**: Criterion.rs with statistical analysis

**Configuration**:

```shell
cargo bench --bench search_bench -- --sample-size=20 --warm-up-time=1
```

**Synthetic Data Generation**:

- 1,024 entities for build benchmark
- 4,096 entities for query benchmarks
- Mix of Directory/File/Function nodes
- Predictable naming: `module{i:04}`, `handle_module_{i:04}`

### Measured Performance

| Operation | Median | Target | Ratio |
|-----------|--------|--------|-------|
| Exact match | 68.42 ns | <10ms | 146,000x faster |
| Prefix match | 699.40 ns | <10ms | 14,000x faster |
| Index build (1,024) | 2.287 ms | <5s for 1K | 2,186x faster |

**Analysis**:

- **Exact match**: HashMap O(1) lookup → sub-microsecond
- **Prefix match**: Binary search + linear scan → still sub-microsecond
- **Index build**: Dominated by sorting (O(n log n)) → scales linearly

**Memory Usage** (estimated):

- NameEntry: ~80 bytes (2 `Arc<str>` + `GraphNodeIndex` + `NodeKind`)
- 1,024 entities: ~80 KB (negligible)
- 10,000 entities: ~800 KB (acceptable)
- 100,000 entities: ~8 MB (still acceptable)

### Optimization Opportunities

**Current Implementation** (Phase 1):

- Already exceeds targets by 4-5 orders of magnitude
- No optimization needed for MVP

**Future Enhancements** (Phase 5+):

- **Lazy index loading**: mmap for large indices (>1M entities)
- **Query result caching**: LRU cache for frequent queries
- **Parallel index construction**: Rayon for multi-core build
- **Compressed storage**: Dictionary encoding for repeated qualified names

---

## Code Review Notes

### Self-Review Checklist

- [x] Code follows Rust idioms (builder pattern, Arc for sharing)
- [x] Unit tests added (11 tests, 97.20% coverage)
- [x] Documentation updated (rustdoc for all public APIs)
- [x] No commented-out code
- [x] Error handling implemented (graceful empty/None returns)
- [x] Performance considerations addressed (benchmarks in place)

### Integration Points

**Graph Builder Integration**:

- Requires `pub(crate)` visibility on GraphNode fields
- Consumes `display_name` and `id` (qualified name)
- Preserves NodeKind for filtering

**Future Service Layer Integration** (Phase 3):

- NameIndex will be owned by SearchEngine
- exact_match/prefix_match exposed via JSON-RPC
- from_graph() called during index build phase

**Future BM25 Integration** (Phase 3):

- NameIndex = upper tier (exact/prefix)
- BM25 = lower tier (semantic/fuzzy)
- Deduplication gate prevents BM25 from returning upper tier results

---

## Debugging Notes

### Common Pitfalls Avoided

1. **`Arc<str>` vs `String`**: Use `Arc` for memory sharing across entries
2. **Normalization consistency**: Always normalize before lookup
3. **Deduplication**: Handle concurrent duplicate inserts via dedup_by_key
4. **Empty names**: Skip during insertion (not during query)
5. **Limit=0 early exit**: Avoid unnecessary work for zero-limit queries

### Visibility Issues Resolved

**Problem**: `GraphNode.display_name` was private

**Solution**: Made fields `pub(crate)` to allow access from index module:

```rust
// crates/cds-index/src/graph/mod.rs
pub struct GraphNode {
    pub(crate) display_name: String,
    pub(crate) id: String,
    pub(crate) kind: NodeKind,
    // ...
}
```

---

## TODO / Follow-up

### Immediate (Phase 2 - Tokenizer)

- [ ] Extract LocAgent stop-word list → `tests/fixtures/parity/tokenizer/stop_words.txt`
- [ ] Create `tests/support/parity_loader.rs` helper module
- [ ] Implement tokenizer.rs with camel/snake splitting
- [ ] Golden tokenizer fixtures for validation

### Near-term (Phase 3 - BM25)

- [ ] Define `TANTIVY_DATA_DIR` env var + config
- [ ] Integrate Tantivy with custom analyzer
- [ ] Create `BM25Backend` trait for pluggability
- [ ] Wire hierarchical search (upper → lower tier)

### Future (Phase 5 - Parity)

- [ ] Replace synthetic benchmark data with parity fixtures
- [ ] Measure overlap@10 against LocAgent baselines
- [ ] Tune BM25 parameters (k1, b) if needed

---

## References

- **PRD**: spacs/prd/0.1.0-MVP-PRDs-v0/02-cds-index-service.md (Section 3.2: Index Architecture)
- **Issue**: spacs/issues/04-0.1.0-mvp/02-index-core/02-sparse-index.md
- **Task**: spacs/tasks/0.1.0-mvp/02-index-core/T-02-02-sparse-index.md
- **Graph API**: crates/cds-index/src/graph/mod.rs (T-02-01 deliverable)
- **Parity baseline**: tests/fixtures/parity/golden_outputs/ (T-06-01 deliverable)

---

## Session Statistics

- **Session Duration**: 3.3 hours (12:02-15:17 UTC)
- **Productivity**: Very High (Phase 1 complete ahead of schedule)
- **Blockers**: None
- **Code Quality**: Excellent (97.20% coverage, all benchmarks pass)
- **Technical Debt**: None introduced

---

**Last Updated**: 2025-10-31 15:17 UTC
**Next Session**: Phase 2 - Custom Tokenizer
