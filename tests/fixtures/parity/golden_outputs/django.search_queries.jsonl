{"repo": "django", "query": "FILE_UPLOAD_PERMISSION default value in settings", "top_10": [{"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_setting_changed", "type": "codeblock", "score": 7.876918792724609, "line": 541, "text": "class FileStorageTests(SimpleTestCase):\n\n    @override_settings(\n        MEDIA_ROOT=\"media_root\",\n        MEDIA_URL=\"media_url/\",\n        FILE_UPLOAD_PERMISSIONS=0o777,\n        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777,\n    )\n    def test_setting_changed(self):\n        \"\"\"\n        Properties using settings values as defaults should be updated on\n        referenced settings change while specified values should be unchanged.\n        \"\"\"\n        storage = self.storage_class(\n            location=\"explicit_location\",\n            base_url=\"explicit_base_url/\",\n            file_permissions_mode=0o666,\n            directory_permissions_mode=0o666,\n        )\n        defaults_storage = self.storage_class()\n        settings = {\n            \"MEDIA_ROOT\": \"overridden_media_root\",\n            \"MEDIA_URL\": \"/overridden_media_url/\",\n            \"FILE_UPLOAD_PERMISSIONS\": 0o333,\n            \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\": 0o333,\n        }\n        with self.settings(**settings):\n            self.assertEqual(storage.base_location, \"explicit_location\")\n            self.assertIn(\"explicit_location\", storage.location)\n            self.assertEqual(storage.base_url, \"explicit_base_url/\")\n            self.assertEqual(storage.file_permissions_mode, 0o666)\n            self.assertEqual(storage.directory_permissions_mode, 0o666)\n            self.assertEqual(defaults_storage.base_location, settings[\"MEDIA_ROOT\"])\n            self.assertIn(settings[\"MEDIA_ROOT\"], defaults_storage.location)\n            self.assertEqual(defaults_storage.base_url, settings[\"MEDIA_URL\"])\n            self.assertEqual(\n                defaults_storage.file_permissions_mode,\n                settings[\"FILE_UPLOAD_PERMISSIONS\"],\n            )\n            self.assertEqual(\n                defaults_storage.directory_permissions_mode,\n                settings[\"FILE_UPLOAD_DIRECTORY_PERMISSIONS\"],\n            )"}, {"file": "django/core/files/storage/mixins.py", "name": "StorageSettingsMixin", "type": "codeblock", "score": 6.123697757720947, "line": 1, "text": "class StorageSettingsMixin:\n    def _clear_cached_properties(self, setting, **kwargs):\n        \"\"\"Reset setting based property values.\"\"\"\n        if setting == \"MEDIA_ROOT\":\n            self.__dict__.pop(\"base_location\", None)\n            self.__dict__.pop(\"location\", None)\n        elif setting == \"MEDIA_URL\":\n            self.__dict__.pop(\"base_url\", None)\n        elif setting == \"FILE_UPLOAD_PERMISSIONS\":\n            self.__dict__.pop(\"file_permissions_mode\", None)\n        elif setting == \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\":\n            self.__dict__.pop(\"directory_permissions_mode\", None)\n\n    def _value_or_setting(self, value, setting):\n        return setting if value is None else value"}, {"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_file_upload_permissions", "type": "codeblock", "score": 4.587795257568359, "line": 1861, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_media_root(self):\n        \"\"\"\n        Overriding the MEDIA_ROOT setting should be reflected in the\n        base_location attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_ROOT=\"test_value\"):\n            self.assertEqual(default_storage.base_location, \"test_value\")\n\n    def test_override_media_url(self):\n        \"\"\"\n        Overriding the MEDIA_URL setting should be reflected in the\n        base_url attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_URL=\"/test_value/\"):\n            self.assertEqual(default_storage.base_url, \"/test_value/\")\n\n    def test_override_file_upload_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n        the file_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n        with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.file_permissions_mode, 0o777)\n\n    def test_override_file_upload_directory_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n        reflected in the directory_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertIsNone(default_storage.directory_permissions_mode)\n        with self.settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.directory_permissions_mode, 0o777)\n\n    def test_override_database_routers(self):\n        \"\"\"\n        Overriding DATABASE_ROUTERS should update the base router.\n        \"\"\"\n        test_routers = [object()]\n        with self.settings(DATABASE_ROUTERS=test_routers):\n            self.assertEqual(router.routers, test_routers)\n\n    def test_override_static_url(self):\n        \"\"\"\n        Overriding the STATIC_URL setting should be reflected in the\n        base_url attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_URL=\"/test/\"):\n            self.assertEqual(staticfiles_storage.base_url, \"/test/\")\n\n    def test_override_static_root(self):\n        \"\"\"\n        Overriding the STATIC_ROOT setting should be reflected in the\n        location attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_ROOT=\"/tmp/test\"):\n            self.assertEqual(staticfiles_storage.location, os.path.abspath(\"/tmp/test\"))"}, {"file": "django/conf/global_settings.py", "name": "impl:107", "type": "codeblock", "score": 4.480478286743164, "line": 300, "text": "FILE_UPLOAD_HANDLERS = [\n    \"django.core.files.uploadhandler.MemoryFileUploadHandler\",\n    \"django.core.files.uploadhandler.TemporaryFileUploadHandler\",\n]\n\n# Maximum size, in bytes, of a request before it will be streamed to the\n# file system instead of into memory.\nFILE_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum size in bytes of request data (excluding file uploads) that will be\n# read before a SuspiciousOperation (RequestDataTooBig) is raised.\nDATA_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum number of GET/POST parameters that will be read before a\n# SuspiciousOperation (TooManyFieldsSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FIELDS = 1000\n\n# Maximum number of files encoded in a multipart upload that will be read\n# before a SuspiciousOperation (TooManyFilesSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FILES = 100\n\n# Directory in which upload streamed files will be temporarily saved. A value\n# of `None` will make Django use the operating system's default temporary\n# directory (i.e. \"/tmp\" on *nix systems).\nFILE_UPLOAD_TEMP_DIR = None\n\n# The numeric mode to set newly-uploaded files to. The value should be a mode\n# you'd pass directly to os.chmod; see\n# https://docs.python.org/library/os.html#files-and-directories.\nFILE_UPLOAD_PERMISSIONS = 0o644\n\n# The numeric mode to assign to newly-created directories, when uploading\n# files. The value should be a mode as you'd pass to os.chmod; see\n# https://docs.python.org/library/os.html#files-and-directories.\nFILE_UPLOAD_DIRECTORY_PERMISSIONS = None\n\n# Python module path where user will place custom format definition.\n# The directory where this setting is pointing should contain subdirectories\n# named as the locales, containing a formats.py file\n# (i.e. \"myproject.locale\" for myproject/locale/en/formats.py etc. use)\nFORMAT_MODULE_PATH = None\n\n# Default formatting for date objects. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"N j, Y\"\n\n# Default formatting for datetime objects. See all available format strings\n# here: https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATETIME_FORMAT = \"N j, Y, P\"\n\n# Default formatting for time objects. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nTIME_FORMAT = \"P\"\n\n# Default formatting for date objects when only the year and month are\n# relevant. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date"}, {"file": "django/core/management/commands/diffsettings.py", "name": "imports", "type": "codeblock", "score": 4.006436347961426, "line": 1, "text": "from django.core.management.base import BaseCommand\n\n\ndef module_to_dict(module, omittable=lambda k: k.startswith(\"_\") or not k.isupper()):\n    \"\"\"Convert a module namespace to a Python dictionary.\"\"\"\n    return {k: repr(getattr(module, k)) for k in dir(module) if not omittable(k)}\n\n\nclass Command(BaseCommand):\n    help = \"\"\"Displays differences between the current settings.py and Django's\n    default settings.\"\"\"\n\n    requires_system_checks = []\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"--all\",\n            action=\"store_true\",\n            help=(\n                'Display all settings, regardless of their value. In \"hash\" '\n                'mode, default values are prefixed by \"###\".'\n            ),\n        )\n        parser.add_argument(\n            \"--default\",\n            metavar=\"MODULE\",\n            help=(\n                \"The settings module to compare the current settings against. Leave \"\n                \"empty to compare against Django's default settings.\"\n            ),\n        )\n        parser.add_argument(\n            \"--output\",\n            default=\"hash\",\n            choices=(\"hash\", \"unified\"),\n            help=(\n                \"Selects the output format. 'hash' mode displays each changed \"\n                \"setting, with the settings that don't appear in the defaults \"\n                \"followed by ###. 'unified' mode prefixes the default setting \"\n                \"with a minus sign, followed by the changed setting prefixed \"\n                \"with a plus sign.\"\n            ),\n        )"}, {"file": "tests/cache/tests.py", "name": "DefaultNonExpiringCacheKeyTests.setUp", "type": "codeblock", "score": 3.899834156036377, "line": 1973, "text": "class DefaultNonExpiringCacheKeyTests(SimpleTestCase):\n    \"\"\"\n    Settings having Cache arguments with a TIMEOUT=None create Caches that will\n    set non-expiring keys.\n    \"\"\"\n\n    def setUp(self):\n        # The 5 minute (300 seconds) default expiration time for keys is\n        # defined in the implementation of the initializer method of the\n        # BaseCache type.\n        self.DEFAULT_TIMEOUT = caches[DEFAULT_CACHE_ALIAS].default_timeout\n\n    def tearDown(self):\n        del self.DEFAULT_TIMEOUT\n\n    def test_default_expiration_time_for_keys_is_5_minutes(self):\n        \"\"\"The default expiration time of a cache key is 5 minutes.\n\n        This value is defined in\n        django.core.cache.backends.base.BaseCache.__init__().\n        \"\"\"\n        self.assertEqual(300, self.DEFAULT_TIMEOUT)\n\n    def test_caches_with_unset_timeout_has_correct_default_timeout(self):\n        \"\"\"Caches that have the TIMEOUT parameter undefined in the default\n        settings will use the default 5 minute timeout.\n        \"\"\"\n        cache = caches[DEFAULT_CACHE_ALIAS]\n        self.assertEqual(self.DEFAULT_TIMEOUT, cache.default_timeout)\n\n    @override_settings(CACHES=NEVER_EXPIRING_CACHES_SETTINGS)\n    def test_caches_set_with_timeout_as_none_has_correct_default_timeout(self):\n        \"\"\"Memory caches that have the TIMEOUT parameter set to `None` in the\n        default settings with have `None` as the default timeout.\n\n        This means \"no timeout\".\n        \"\"\"\n        cache = caches[DEFAULT_CACHE_ALIAS]\n        self.assertIsNone(cache.default_timeout)\n        self.assertIsNone(cache.get_backend_timeout())\n\n    @override_settings(CACHES=DEFAULT_MEMORY_CACHES_SETTINGS)\n    def test_caches_with_unset_timeout_set_expiring_key(self):\n        \"\"\"Memory caches that have the TIMEOUT parameter unset will set cache\n        keys having the default 5 minute timeout.\n        \"\"\"\n        key = \"my-key\"\n        value = \"my-value\"\n        cache = caches[DEFAULT_CACHE_ALIAS]\n        cache.set(key, value)\n        cache_key = cache.make_key(key)\n        self.assertIsNotNone(cache._expire_info[cache_key])"}, {"file": "tests/cache/tests.py", "name": "BaseCacheTests", "type": "codeblock", "score": 3.838217258453369, "line": 322, "text": "class BaseCacheTests:\n    # A common set of tests to apply to all cache backends\n    factory = RequestFactory()\n\n    # Some clients raise custom exceptions when .incr() or .decr() are called\n    # with a non-integer value.\n    incr_decr_type_error = TypeError\n\n    def tearDown(self):\n        cache.clear()\n\n    def test_simple(self):\n        # Simple cache set/get works\n        cache.set(\"key\", \"value\")\n        self.assertEqual(cache.get(\"key\"), \"value\")\n\n    def test_default_used_when_none_is_set(self):\n        \"\"\"If None is cached, get() returns it instead of the default.\"\"\"\n        cache.set(\"key_default_none\", None)\n        self.assertIsNone(cache.get(\"key_default_none\", default=\"default\"))\n\n    def test_add(self):\n        # A key can be added to a cache\n        self.assertIs(cache.add(\"addkey1\", \"value\"), True)\n        self.assertIs(cache.add(\"addkey1\", \"newvalue\"), False)\n        self.assertEqual(cache.get(\"addkey1\"), \"value\")\n\n    def test_prefix(self):\n        # Test for same cache key conflicts between shared backend\n        cache.set(\"somekey\", \"value\")\n\n        # should not be set in the prefixed cache\n        self.assertIs(caches[\"prefix\"].has_key(\"somekey\"), False)\n\n        caches[\"prefix\"].set(\"somekey\", \"value2\")\n\n        self.assertEqual(cache.get(\"somekey\"), \"value\")\n        self.assertEqual(caches[\"prefix\"].get(\"somekey\"), \"value2\")\n\n    def test_non_existent(self):\n        \"\"\"Nonexistent cache keys return as None/default.\"\"\"\n        self.assertIsNone(cache.get(\"does_not_exist\"))\n        self.assertEqual(cache.get(\"does_not_exist\", \"bang!\"), \"bang!\")"}, {"file": "tests/cache/tests.py", "name": "BaseMemcachedTests.test_memcached_deletes_key_on_failed_set", "type": "codeblock", "score": 3.780930280685425, "line": 1569, "text": "class BaseMemcachedTests(BaseCacheTests):\n    # By default it's assumed that the client doesn't clean up connections\n\n    def test_memcached_deletes_key_on_failed_set(self):\n        # By default memcached allows objects up to 1MB. For the cache_db\n        # session backend to always use the current session, memcached needs to\n        # delete the old key if it fails to set.\n        max_value_length = 2**20\n\n        cache.set(\"small_value\", \"a\")\n        self.assertEqual(cache.get(\"small_value\"), \"a\")\n\n        large_value = \"a\" * (max_value_length + 1)\n        try:\n            cache.set(\"small_value\", large_value)\n        except Exception:\n            # Most clients (e.g. pymemcache or pylibmc) raise when the value is\n            # too large. This test is primarily checking that the key was\n            # deleted, so the return/exception behavior for the set() itself is\n            # not important.\n            pass\n        # small_value should be deleted, or set if configured to accept larger\n        # values\n        value = cache.get(\"small_value\")\n        self.assertTrue(value is None or value == large_value)"}, {"file": "django/contrib/gis/gdal/raster/base.py", "name": "GDALRasterBase.metadata_1", "type": "codeblock", "score": 3.749173402786255, "line": 60, "text": "class GDALRasterBase(GDALBase):\n\n    @metadata.setter\n    def metadata(self, value):\n        \"\"\"\n        Set the metadata. Update only the domains that are contained in the\n        value dictionary.\n        \"\"\"\n        # Loop through domains.\n        for domain, metadata in value.items():\n            # Set the domain to None for the default, otherwise encode.\n            domain = None if domain == \"DEFAULT\" else domain.encode()\n            # Set each metadata entry separately.\n            for meta_name, meta_value in metadata.items():\n                capi.set_ds_metadata_item(\n                    self._ptr,\n                    meta_name.encode(),\n                    meta_value.encode() if meta_value else None,\n                    domain,\n                )"}, {"file": "django/core/cache/backends/base.py", "name": "BaseCache.validate_key", "type": "codeblock", "score": 3.7489447593688965, "line": 112, "text": "class BaseCache:\n\n    def validate_key(self, key):\n        \"\"\"\n        Warn about keys that would not be portable to the memcached\n        backend. This encourages (but does not force) writing backend-portable\n        cache code.\n        \"\"\"\n        for warning in memcache_key_warnings(key):\n            warnings.warn(warning, CacheKeyWarning)\n\n    def make_and_validate_key(self, key, version=None):\n        \"\"\"Helper to make and validate keys.\"\"\"\n        key = self.make_key(key, version=version)\n        self.validate_key(key)\n        return key\n\n    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n        \"\"\"\n        Set a value in the cache if the key does not already exist. If\n        timeout is given, use that timeout for the key; otherwise use the\n        default cache timeout.\n\n        Return True if the value was stored, False otherwise.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of BaseCache must provide an add() method\"\n        )\n\n    async def aadd(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n        return await sync_to_async(self.add, thread_sensitive=True)(\n            key, value, timeout, version\n        )\n\n    def get(self, key, default=None, version=None):\n        \"\"\"\n        Fetch a given key from the cache. If the key does not exist, return\n        default, which itself defaults to None.\n        \"\"\"\n        raise NotImplementedError(\"subclasses of BaseCache must provide a get() method\")\n\n    async def aget(self, key, default=None, version=None):\n        return await sync_to_async(self.get, thread_sensitive=True)(\n            key, default, version\n        )\n\n    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n        \"\"\"\n        Set a value in the cache. If timeout is given, use that timeout for the\n        key; otherwise use the default cache timeout.\n        \"\"\"\n        raise NotImplementedError(\"subclasses of BaseCache must provide a set() method\")\n\n    async def aset(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n        return await sync_to_async(self.set, thread_sensitive=True)(\n            key, value, timeout, version\n        )\n\n    def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n        \"\"\"\n        Update the key's expiry time using timeout. Return True if successful\n        or False if the key does not exist.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of BaseCache must provide a touch() method\"\n        )"}], "total_results": 10}
{"repo": "django", "query": "TemporaryUploadedFile applies FILE_UPLOAD_PERMISSION", "top_10": [{"file": "django/core/files/uploadedfile.py", "name": "TemporaryUploadedFile.__init__", "type": "codeblock", "score": 5.479353904724121, "line": 71, "text": "class TemporaryUploadedFile(UploadedFile):\n    \"\"\"\n    A file uploaded to a temporary location (i.e. stream-to-disk).\n    \"\"\"\n\n    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n        _, ext = os.path.splitext(name)\n        file = tempfile.NamedTemporaryFile(\n            suffix=\".upload\" + ext, dir=settings.FILE_UPLOAD_TEMP_DIR\n        )\n        super().__init__(file, name, content_type, size, charset, content_type_extra)\n\n    def temporary_file_path(self):\n        \"\"\"Return the full path of this file.\"\"\"\n        return self.file.name\n\n    def close(self):\n        try:\n            return self.file.close()\n        except FileNotFoundError:\n            # The file was moved or deleted before the tempfile could unlink\n            # it. Still sets self.file.close_called and calls\n            # self.file.file.close() before the exception.\n            pass"}, {"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_setting_changed", "type": "codeblock", "score": 4.711771011352539, "line": 541, "text": "class FileStorageTests(SimpleTestCase):\n\n    @override_settings(\n        MEDIA_ROOT=\"media_root\",\n        MEDIA_URL=\"media_url/\",\n        FILE_UPLOAD_PERMISSIONS=0o777,\n        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777,\n    )\n    def test_setting_changed(self):\n        \"\"\"\n        Properties using settings values as defaults should be updated on\n        referenced settings change while specified values should be unchanged.\n        \"\"\"\n        storage = self.storage_class(\n            location=\"explicit_location\",\n            base_url=\"explicit_base_url/\",\n            file_permissions_mode=0o666,\n            directory_permissions_mode=0o666,\n        )\n        defaults_storage = self.storage_class()\n        settings = {\n            \"MEDIA_ROOT\": \"overridden_media_root\",\n            \"MEDIA_URL\": \"/overridden_media_url/\",\n            \"FILE_UPLOAD_PERMISSIONS\": 0o333,\n            \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\": 0o333,\n        }\n        with self.settings(**settings):\n            self.assertEqual(storage.base_location, \"explicit_location\")\n            self.assertIn(\"explicit_location\", storage.location)\n            self.assertEqual(storage.base_url, \"explicit_base_url/\")\n            self.assertEqual(storage.file_permissions_mode, 0o666)\n            self.assertEqual(storage.directory_permissions_mode, 0o666)\n            self.assertEqual(defaults_storage.base_location, settings[\"MEDIA_ROOT\"])\n            self.assertIn(settings[\"MEDIA_ROOT\"], defaults_storage.location)\n            self.assertEqual(defaults_storage.base_url, settings[\"MEDIA_URL\"])\n            self.assertEqual(\n                defaults_storage.file_permissions_mode,\n                settings[\"FILE_UPLOAD_PERMISSIONS\"],\n            )\n            self.assertEqual(\n                defaults_storage.directory_permissions_mode,\n                settings[\"FILE_UPLOAD_DIRECTORY_PERMISSIONS\"],\n            )"}, {"file": "tests/files/tests.py", "name": "TemporaryUploadedFileTests.test_file_upload_temp_dir_pathlib", "type": "codeblock", "score": 4.227845668792725, "line": 274, "text": "class InMemoryUploadedFileTests(unittest.TestCase):\n    def test_open_resets_file_to_start_and_returns_context_manager(self):\n        uf = InMemoryUploadedFile(StringIO(\"1\"), \"\", \"test\", \"text/plain\", 1, \"utf8\")\n        uf.read()\n        with uf.open() as f:\n            self.assertEqual(f.read(), \"1\")\n\n\nclass TemporaryUploadedFileTests(unittest.TestCase):\n    def test_extension_kept(self):\n        \"\"\"The temporary file name has the same suffix as the original file.\"\"\"\n        with TemporaryUploadedFile(\"test.txt\", \"text/plain\", 1, \"utf8\") as temp_file:\n            self.assertTrue(temp_file.file.name.endswith(\".upload.txt\"))\n\n    def test_file_upload_temp_dir_pathlib(self):\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            with override_settings(FILE_UPLOAD_TEMP_DIR=Path(tmp_dir)):\n                with TemporaryUploadedFile(\n                    \"test.txt\", \"text/plain\", 1, \"utf-8\"\n                ) as temp_file:\n                    self.assertTrue(os.path.exists(temp_file.file.name))"}, {"file": "django/core/files/uploadedfile.py", "name": "UploadedFile", "type": "codeblock", "score": 3.784362316131592, "line": 1, "text": "\"\"\"\nClasses representing uploaded files.\n\"\"\"\n\nimport os\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.files import temp as tempfile\nfrom django.core.files.base import File\nfrom django.core.files.utils import validate_file_name\n\n__all__ = (\n    \"UploadedFile\",\n    \"TemporaryUploadedFile\",\n    \"InMemoryUploadedFile\",\n    \"SimpleUploadedFile\",\n)\n\n\nclass UploadedFile(File):\n    \"\"\"\n    An abstract uploaded file (``TemporaryUploadedFile`` and\n    ``InMemoryUploadedFile`` are the built-in concrete subclasses).\n\n    An ``UploadedFile`` object behaves somewhat like a file object and\n    represents some file data that the user submitted with a form.\n    \"\"\"\n\n    def __init__(\n        self,\n        file=None,\n        name=None,\n        content_type=None,\n        size=None,\n        charset=None,\n        content_type_extra=None,\n    ):\n        super().__init__(file, name)\n        self.size = size\n        self.content_type = content_type\n        self.charset = charset\n        self.content_type_extra = content_type_extra\n\n    def __repr__(self):\n        return \"<%s: %s (%s)>\" % (self.__class__.__name__, self.name, self.content_type)\n\n    def _get_name(self):\n        return self._name"}, {"file": "tests/file_storage/tests.py", "name": "OverwritingStorageTests.test_save_overwrite_behavior_temp_file", "type": "codeblock", "score": 3.784362316131592, "line": 667, "text": "class OverwritingStorageTests(FileStorageTests):\n\n    def test_save_overwrite_behavior_temp_file(self):\n        \"\"\"Saving to same file name twice overwrites the first file.\"\"\"\n        name = \"test.file\"\n        self.assertFalse(self.storage.exists(name))\n        content_1 = b\"content one\"\n        content_2 = b\"second content\"\n        f_1 = TemporaryUploadedFile(\"tmp1\", \"text/plain\", 11, \"utf8\")\n        f_1.write(content_1)\n        f_1.seek(0)\n        f_2 = TemporaryUploadedFile(\"tmp2\", \"text/plain\", 14, \"utf8\")\n        f_2.write(content_2)\n        f_2.seek(0)\n        stored_name_1 = self.storage.save(name, f_1)\n        try:\n            self.assertEqual(stored_name_1, name)\n            self.assertTrue(os.path.exists(os.path.join(self.temp_dir, name)))\n            with self.storage.open(name) as fp:\n                self.assertEqual(fp.read(), content_1)\n            stored_name_2 = self.storage.save(name, f_2)\n            self.assertEqual(stored_name_2, name)\n            self.assertTrue(os.path.exists(os.path.join(self.temp_dir, name)))\n            with self.storage.open(name) as fp:\n                self.assertEqual(fp.read(), content_2)\n        finally:\n            self.storage.delete(name)"}, {"file": "django/db/migrations/executor.py", "name": "MigrationExecutor.check_replacements", "type": "codeblock", "score": 3.637784481048584, "line": 294, "text": "class MigrationExecutor:\n\n    def check_replacements(self):\n        \"\"\"\n        Mark replacement migrations applied if their replaced set all are.\n\n        Do this unconditionally on every migrate, rather than just when\n        migrations are applied or unapplied, to correctly handle the case\n        when a new squash migration is pushed to a deployment that already had\n        all its replaced migrations applied. In this case no new migration will\n        be applied, but the applied state of the squashed migration must be\n        maintained.\n        \"\"\"\n        applied = self.recorder.applied_migrations()\n        for key, migration in self.loader.replacements.items():\n            all_applied = all(m in applied for m in migration.replaces)\n            if all_applied and key not in applied:\n                self.recorder.record_applied(*key)"}, {"file": "tests/file_storage/tests.py", "name": "FileStoragePermissions.test_file_upload_permissions", "type": "codeblock", "score": 3.6031692028045654, "line": 1104, "text": "@unittest.skipIf(\n    sys.platform == \"win32\", \"Windows only partially supports umasks and chmod.\"\n)\nclass FileStoragePermissions(unittest.TestCase):\n    def setUp(self):\n        self.umask = 0o027\n        old_umask = os.umask(self.umask)\n        self.addCleanup(os.umask, old_umask)\n        self.storage_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.storage_dir)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=0o654)\n    def test_file_upload_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_file\", ContentFile(\"data\"))\n        actual_mode = os.stat(self.storage.path(name))[0] & 0o777\n        self.assertEqual(actual_mode, 0o654)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=None)\n    def test_file_upload_default_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        fname = self.storage.save(\"some_file\", ContentFile(\"data\"))\n        mode = os.stat(self.storage.path(fname))[0] & 0o777\n        self.assertEqual(mode, 0o666 & ~self.umask)\n\n    @override_settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765)\n    def test_file_upload_directory_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_directory/subdir/the_file\", ContentFile(\"data\"))\n        file_path = Path(self.storage.path(name))\n        self.assertEqual(file_path.parent.stat().st_mode & 0o777, 0o765)\n        self.assertEqual(file_path.parent.parent.stat().st_mode & 0o777, 0o765)"}, {"file": "django/db/migrations/loader.py", "name": "MigrationLoader.check_consistent_history", "type": "codeblock", "score": 3.572009563446045, "line": 344, "text": "class MigrationLoader:\n\n    def check_consistent_history(self, connection):\n        \"\"\"\n        Raise InconsistentMigrationHistory if any applied migrations have\n        unapplied dependencies.\n        \"\"\"\n        recorder = MigrationRecorder(connection)\n        applied = recorder.applied_migrations()\n        for migration in applied:\n            # If the migration is unknown, skip it.\n            if migration not in self.graph.nodes:\n                continue\n            for parent in self.graph.node_map[migration].parents:\n                if parent not in applied:\n                    # Skip unapplied squashed migrations that have all of their\n                    # `replaces` applied.\n                    if parent in self.replacements:\n                        if all(\n                            m in applied for m in self.replacements[parent].replaces\n                        ):\n                            continue\n                    raise InconsistentMigrationHistory(\n                        \"Migration {}.{} is applied before its dependency \"\n                        \"{}.{} on database '{}'.\".format(\n                            migration[0],\n                            migration[1],\n                            parent[0],\n                            parent[1],\n                            connection.alias,\n                        )\n                    )"}, {"file": "django/core/files/uploadhandler.py", "name": "UploadFileException", "type": "codeblock", "score": 3.475675106048584, "line": 1, "text": "\"\"\"\nBase file upload handler classes, and the built-in concrete subclasses\n\"\"\"\n\nimport os\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile\nfrom django.utils.module_loading import import_string\n\n__all__ = [\n    \"UploadFileException\",\n    \"StopUpload\",\n    \"SkipFile\",\n    \"FileUploadHandler\",\n    \"TemporaryFileUploadHandler\",\n    \"MemoryFileUploadHandler\",\n    \"load_handler\",\n    \"StopFutureHandlers\",\n]\n\n\nclass UploadFileException(Exception):\n    \"\"\"\n    Any error having to do with uploading files.\n    \"\"\"\n\n    pass"}, {"file": "django/core/files/storage/mixins.py", "name": "StorageSettingsMixin", "type": "codeblock", "score": 3.408830404281616, "line": 1, "text": "class StorageSettingsMixin:\n    def _clear_cached_properties(self, setting, **kwargs):\n        \"\"\"Reset setting based property values.\"\"\"\n        if setting == \"MEDIA_ROOT\":\n            self.__dict__.pop(\"base_location\", None)\n            self.__dict__.pop(\"location\", None)\n        elif setting == \"MEDIA_URL\":\n            self.__dict__.pop(\"base_url\", None)\n        elif setting == \"FILE_UPLOAD_PERMISSIONS\":\n            self.__dict__.pop(\"file_permissions_mode\", None)\n        elif setting == \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\":\n            self.__dict__.pop(\"directory_permissions_mode\", None)\n\n    def _value_or_setting(self, value, setting):\n        return setting if value is None else value"}], "total_results": 10}
{"repo": "django", "query": "FileSystemStorage file permission handling", "top_10": [{"file": "tests/file_uploads/tests.py", "name": "DirectoryCreationTests.test_readonly_root", "type": "codeblock", "score": 6.737936973571777, "line": 852, "text": "@override_settings(MEDIA_ROOT=MEDIA_ROOT)\nclass DirectoryCreationTests(SimpleTestCase):\n    \"\"\"\n    Tests for error handling during directory creation\n    via _save_FIELD_file (ticket #6450)\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        os.makedirs(MEDIA_ROOT, exist_ok=True)\n        cls.addClassCleanup(shutil.rmtree, MEDIA_ROOT)\n\n    def setUp(self):\n        self.obj = FileModel()\n\n    @unittest.skipIf(\n        sys.platform == \"win32\", \"Python on Windows doesn't have working os.chmod().\"\n    )\n    @override_settings(\n        STORAGES={\n            DEFAULT_STORAGE_ALIAS: {\n                \"BACKEND\": \"django.core.files.storage.FileSystemStorage\",\n            }\n        }\n    )\n    def test_readonly_root(self):\n        \"\"\"Permission errors are not swallowed\"\"\"\n        os.chmod(MEDIA_ROOT, 0o500)\n        self.addCleanup(os.chmod, MEDIA_ROOT, 0o700)\n        with self.assertRaises(PermissionError):\n            self.obj.testfile.save(\n                \"foo.txt\", SimpleUploadedFile(\"foo.txt\", b\"x\"), save=False\n            )"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage.get_accessed_time", "type": "codeblock", "score": 6.554405689239502, "line": 151, "text": "@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n\n    def _ensure_location_group_id(self, full_path):\n        if os.name == \"posix\":\n            file_gid = os.stat(full_path).st_gid\n            location_gid = os.stat(self.location).st_gid\n            if file_gid != location_gid:\n                try:\n                    os.chown(full_path, uid=-1, gid=location_gid)\n                except PermissionError:\n                    pass\n\n    def delete(self, name):\n        if not name:\n            raise ValueError(\"The name must be given to delete().\")\n        name = self.path(name)\n        # If the file or directory exists, delete it from the filesystem.\n        try:\n            if os.path.isdir(name):\n                os.rmdir(name)\n            else:\n                os.remove(name)\n        except FileNotFoundError:\n            # FileNotFoundError is raised if the file or directory was removed\n            # concurrently.\n            pass\n\n    def is_name_available(self, name, max_length=None):\n        if self._allow_overwrite:\n            return not (max_length and len(name) > max_length)\n        return super().is_name_available(name, max_length=max_length)\n\n    def get_alternative_name(self, file_root, file_ext):\n        if self._allow_overwrite:\n            return f\"{file_root}{file_ext}\"\n        return super().get_alternative_name(file_root, file_ext)\n\n    def exists(self, name):\n        return os.path.lexists(self.path(name))\n\n    def listdir(self, path):\n        path = self.path(path)\n        directories, files = [], []\n        with os.scandir(path) as entries:\n            for entry in entries:\n                if entry.is_dir():\n                    directories.append(entry.name)\n                else:\n                    files.append(entry.name)\n        return directories, files\n\n    def path(self, name):\n        return safe_join(self.location, name)\n\n    def size(self, name):\n        return os.path.getsize(self.path(name))\n\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip(\"/\")\n        return urljoin(self.base_url, url)\n\n    def _datetime_from_timestamp(self, ts):\n        \"\"\"\n        If timezone support is enabled, make an aware datetime object in UTC;\n        otherwise make a naive one in the local timezone.\n        \"\"\"\n        tz = UTC if settings.USE_TZ else None\n        return datetime.fromtimestamp(ts, tz=tz)\n\n    def get_accessed_time(self, name):\n        return self._datetime_from_timestamp(os.path.getatime(self.path(name)))\n\n    def get_created_time(self, name):\n        return self._datetime_from_timestamp(os.path.getctime(self.path(name)))\n\n    def get_modified_time(self, name):\n        return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage.location", "type": "codeblock", "score": 6.486894607543945, "line": 1, "text": "import os\nfrom datetime import UTC, datetime\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom django.core.files import File, locks\nfrom django.core.files.move import file_move_safe\nfrom django.core.signals import setting_changed\nfrom django.utils._os import safe_join\nfrom django.utils.deconstruct import deconstructible\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.functional import cached_property\n\nfrom .base import Storage\nfrom .mixins import StorageSettingsMixin\n\n\n@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n    \"\"\"\n    Standard filesystem storage\n    \"\"\"\n\n    def __init__(\n        self,\n        location=None,\n        base_url=None,\n        file_permissions_mode=None,\n        directory_permissions_mode=None,\n        allow_overwrite=False,\n    ):\n        self._location = location\n        self._base_url = base_url\n        self._file_permissions_mode = file_permissions_mode\n        self._directory_permissions_mode = directory_permissions_mode\n        self._allow_overwrite = allow_overwrite\n        setting_changed.connect(self._clear_cached_properties)\n\n    @cached_property\n    def base_location(self):\n        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n\n    @cached_property\n    def location(self):\n        return os.path.abspath(self.base_location)\n\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith(\"/\"):\n            self._base_url += \"/\"\n        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n\n    @cached_property\n    def file_permissions_mode(self):\n        return self._value_or_setting(\n            self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS\n        )\n\n    @cached_property\n    def directory_permissions_mode(self):\n        return self._value_or_setting(\n            self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS\n        )\n\n    def _open(self, name, mode=\"rb\"):\n        return File(open(self.path(name), mode))"}, {"file": "tests/file_storage/models.py", "name": "CallableStorage", "type": "codeblock", "score": 5.959860324859619, "line": 1, "text": "\"\"\"\nStoring files according to a custom storage system\n\n``FileField`` and its variations can take a ``storage`` argument to specify how\nand where files should be stored.\n\"\"\"\n\nimport random\nimport tempfile\nfrom pathlib import Path\n\nfrom django.core.files.storage import FileSystemStorage, default_storage\nfrom django.db import models\nfrom django.utils.functional import LazyObject\n\n\nclass CustomValidNameStorage(FileSystemStorage):\n    def get_valid_name(self, name):\n        # mark the name to show that this was called\n        return name + \"_valid\"\n\n\ntemp_storage_location = tempfile.mkdtemp()\ntemp_storage = FileSystemStorage(location=temp_storage_location)\n\n\ndef callable_storage():\n    return temp_storage\n\n\ndef callable_default_storage():\n    return default_storage\n\n\nclass CallableStorage(FileSystemStorage):\n    def __call__(self):\n        # no-op implementation.\n        return self\n\n\nclass LazyTempStorage(LazyObject):\n    def _setup(self):\n        self._wrapped = temp_storage"}, {"file": "tests/model_fields/storage.py", "name": "imports", "type": "codeblock", "score": 5.774317741394043, "line": 1, "text": "from django.core.files.storage.filesystem import FileSystemStorage\n\n\nclass NoReadFileSystemStorage(FileSystemStorage):\n    def open(self, *args, **kwargs):\n        raise AssertionError(\"This storage class does not support reading.\")"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage._save", "type": "codeblock", "score": 5.6512250900268555, "line": 68, "text": "@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n\n    def _save(self, name, content):\n        full_path = self.path(name)\n\n        # Create any intermediate directories that do not exist.\n        directory = os.path.dirname(full_path)\n        try:\n            if self.directory_permissions_mode is not None:\n                # Set the umask because os.makedirs() doesn't apply the \"mode\"\n                # argument to intermediate-level directories.\n                old_umask = os.umask(0o777 & ~self.directory_permissions_mode)\n                try:\n                    os.makedirs(\n                        directory, self.directory_permissions_mode, exist_ok=True\n                    )\n                finally:\n                    os.umask(old_umask)\n            else:\n                os.makedirs(directory, exist_ok=True)\n        except FileExistsError:\n            raise FileExistsError(\"%s exists and is not a directory.\" % directory)\n\n        # There's a potential race condition between get_available_name and\n        # saving the file; it's possible that two threads might return the\n        # same name, at which point all sorts of fun happens. So we need to\n        # try to create the file, but if it already exists we have to go back\n        # to get_available_name() and try again.\n        # ... other code"}, {"file": "tests/file_storage/tests.py", "name": "FileSystemStorageTests.test_lazy_base_url_init", "type": "codeblock", "score": 5.630369663238525, "line": 45, "text": "class FileSystemStorageTests(unittest.TestCase):\n    def test_deconstruction(self):\n        path, args, kwargs = temp_storage.deconstruct()\n        self.assertEqual(path, \"django.core.files.storage.FileSystemStorage\")\n        self.assertEqual(args, ())\n        self.assertEqual(kwargs, {\"location\": temp_storage_location})\n\n        kwargs_orig = {\n            \"location\": temp_storage_location,\n            \"base_url\": \"http://myfiles.example.com/\",\n        }\n        storage = FileSystemStorage(**kwargs_orig)\n        path, args, kwargs = storage.deconstruct()\n        self.assertEqual(kwargs, kwargs_orig)\n\n    def test_lazy_base_url_init(self):\n        \"\"\"\n        FileSystemStorage.__init__() shouldn't evaluate base_url.\n        \"\"\"\n        storage = FileSystemStorage(base_url=reverse_lazy(\"app:url\"))\n        with self.assertRaises(NoReverseMatch):\n            storage.url(storage.base_url)"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage._save", "type": "codeblock", "score": 5.336725234985352, "line": 95, "text": "@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n\n    def _save(self, name, content):\n        # ... other code\n\n        while True:\n            try:\n                # This file has a file path that we can move.\n                if hasattr(content, \"temporary_file_path\"):\n                    file_move_safe(\n                        content.temporary_file_path(),\n                        full_path,\n                        allow_overwrite=self._allow_overwrite,\n                    )\n\n                # This is a normal uploadedfile that we can stream.\n                else:\n                    # The combination of O_CREAT and O_EXCL makes os.open()\n                    # raises an OSError if the file already exists before it's\n                    # opened.\n                    open_flags = (\n                        os.O_WRONLY\n                        | os.O_CREAT\n                        | os.O_EXCL\n                        | getattr(os, \"O_BINARY\", 0)\n                    )\n                    if self._allow_overwrite:\n                        open_flags = open_flags & ~os.O_EXCL | os.O_TRUNC\n                    fd = os.open(full_path, open_flags, 0o666)\n                    _file = None\n                    try:\n                        locks.lock(fd, locks.LOCK_EX)\n                        for chunk in content.chunks():\n                            if _file is None:\n                                mode = \"wb\" if isinstance(chunk, bytes) else \"wt\"\n                                _file = os.fdopen(fd, mode)\n                            _file.write(chunk)\n                    finally:\n                        locks.unlock(fd)\n                        if _file is not None:\n                            _file.close()\n                        else:\n                            os.close(fd)\n            except FileExistsError:\n                # A new name is needed if the file exists.\n                name = self.get_available_name(name)\n                full_path = self.path(name)\n            else:\n                # OK, the file save worked. Break out of the loop.\n                break\n\n        if self.file_permissions_mode is not None:\n            os.chmod(full_path, self.file_permissions_mode)\n\n        # Ensure the saved path is always relative to the storage root.\n        name = os.path.relpath(full_path, self.location)\n        # Ensure the moved file has the same gid as the storage root.\n        self._ensure_location_group_id(full_path)\n        # Store filenames with forward slashes, even on Windows.\n        return str(name).replace(\"\\\\\", \"/\")"}, {"file": "django/contrib/staticfiles/storage.py", "name": "imports", "type": "codeblock", "score": 5.311969757080078, "line": 1, "text": "import json\nimport os\nimport posixpath\nimport re\nfrom hashlib import md5\nfrom urllib.parse import unquote, urldefrag, urlsplit, urlunsplit\n\nfrom django.conf import STATICFILES_STORAGE_ALIAS, settings\nfrom django.contrib.staticfiles.utils import check_settings, matches_patterns\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import FileSystemStorage, storages\nfrom django.utils.functional import LazyObject\n\n\nclass StaticFilesStorage(FileSystemStorage):\n    \"\"\"\n    Standard file system storage for static files.\n\n    The defaults for ``location`` and ``base_url`` are\n    ``STATIC_ROOT`` and ``STATIC_URL``.\n    \"\"\"\n\n    def __init__(self, location=None, base_url=None, *args, **kwargs):\n        if location is None:\n            location = settings.STATIC_ROOT\n        if base_url is None:\n            base_url = settings.STATIC_URL\n        check_settings(base_url)\n        super().__init__(location, base_url, *args, **kwargs)\n        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n        # is empty, so we restore the empty value.\n        if not location:\n            self.base_location = None\n            self.location = None\n\n    def path(self, name):\n        if not self.location:\n            raise ImproperlyConfigured(\n                \"You're using the staticfiles app \"\n                \"without having set the STATIC_ROOT \"\n                \"setting to a filesystem path.\"\n            )\n        return super().path(name)"}, {"file": "django/core/files/storage/__init__.py", "name": "imports", "type": "codeblock", "score": 5.108969211578369, "line": 1, "text": "from django.conf import DEFAULT_STORAGE_ALIAS\nfrom django.utils.functional import LazyObject\n\nfrom .base import Storage\nfrom .filesystem import FileSystemStorage\nfrom .handler import InvalidStorageError, StorageHandler\nfrom .memory import InMemoryStorage\n\n__all__ = (\n    \"FileSystemStorage\",\n    \"InMemoryStorage\",\n    \"Storage\",\n    \"DefaultStorage\",\n    \"default_storage\",\n    \"InvalidStorageError\",\n    \"StorageHandler\",\n    \"storages\",\n)\n\n\nclass DefaultStorage(LazyObject):\n    def _setup(self):\n        self._wrapped = storages[DEFAULT_STORAGE_ALIAS]\n\n\nstorages = StorageHandler()\ndefault_storage = DefaultStorage()"}], "total_results": 10}
{"repo": "django", "query": "memory storage FILE_UPLOAD_PERMISSION override", "top_10": [{"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_file_upload_permissions", "type": "codeblock", "score": 8.59913444519043, "line": 1861, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_media_root(self):\n        \"\"\"\n        Overriding the MEDIA_ROOT setting should be reflected in the\n        base_location attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_ROOT=\"test_value\"):\n            self.assertEqual(default_storage.base_location, \"test_value\")\n\n    def test_override_media_url(self):\n        \"\"\"\n        Overriding the MEDIA_URL setting should be reflected in the\n        base_url attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_URL=\"/test_value/\"):\n            self.assertEqual(default_storage.base_url, \"/test_value/\")\n\n    def test_override_file_upload_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n        the file_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n        with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.file_permissions_mode, 0o777)\n\n    def test_override_file_upload_directory_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n        reflected in the directory_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertIsNone(default_storage.directory_permissions_mode)\n        with self.settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.directory_permissions_mode, 0o777)\n\n    def test_override_database_routers(self):\n        \"\"\"\n        Overriding DATABASE_ROUTERS should update the base router.\n        \"\"\"\n        test_routers = [object()]\n        with self.settings(DATABASE_ROUTERS=test_routers):\n            self.assertEqual(router.routers, test_routers)\n\n    def test_override_static_url(self):\n        \"\"\"\n        Overriding the STATIC_URL setting should be reflected in the\n        base_url attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_URL=\"/test/\"):\n            self.assertEqual(staticfiles_storage.base_url, \"/test/\")\n\n    def test_override_static_root(self):\n        \"\"\"\n        Overriding the STATIC_ROOT setting should be reflected in the\n        location attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_ROOT=\"/tmp/test\"):\n            self.assertEqual(staticfiles_storage.location, os.path.abspath(\"/tmp/test\"))"}, {"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_setting_changed", "type": "codeblock", "score": 7.8191022872924805, "line": 541, "text": "class FileStorageTests(SimpleTestCase):\n\n    @override_settings(\n        MEDIA_ROOT=\"media_root\",\n        MEDIA_URL=\"media_url/\",\n        FILE_UPLOAD_PERMISSIONS=0o777,\n        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777,\n    )\n    def test_setting_changed(self):\n        \"\"\"\n        Properties using settings values as defaults should be updated on\n        referenced settings change while specified values should be unchanged.\n        \"\"\"\n        storage = self.storage_class(\n            location=\"explicit_location\",\n            base_url=\"explicit_base_url/\",\n            file_permissions_mode=0o666,\n            directory_permissions_mode=0o666,\n        )\n        defaults_storage = self.storage_class()\n        settings = {\n            \"MEDIA_ROOT\": \"overridden_media_root\",\n            \"MEDIA_URL\": \"/overridden_media_url/\",\n            \"FILE_UPLOAD_PERMISSIONS\": 0o333,\n            \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\": 0o333,\n        }\n        with self.settings(**settings):\n            self.assertEqual(storage.base_location, \"explicit_location\")\n            self.assertIn(\"explicit_location\", storage.location)\n            self.assertEqual(storage.base_url, \"explicit_base_url/\")\n            self.assertEqual(storage.file_permissions_mode, 0o666)\n            self.assertEqual(storage.directory_permissions_mode, 0o666)\n            self.assertEqual(defaults_storage.base_location, settings[\"MEDIA_ROOT\"])\n            self.assertIn(settings[\"MEDIA_ROOT\"], defaults_storage.location)\n            self.assertEqual(defaults_storage.base_url, settings[\"MEDIA_URL\"])\n            self.assertEqual(\n                defaults_storage.file_permissions_mode,\n                settings[\"FILE_UPLOAD_PERMISSIONS\"],\n            )\n            self.assertEqual(\n                defaults_storage.directory_permissions_mode,\n                settings[\"FILE_UPLOAD_DIRECTORY_PERMISSIONS\"],\n            )"}, {"file": "tests/file_storage/tests.py", "name": "FileStoragePermissions.test_file_upload_permissions", "type": "codeblock", "score": 6.8151750564575195, "line": 1104, "text": "@unittest.skipIf(\n    sys.platform == \"win32\", \"Windows only partially supports umasks and chmod.\"\n)\nclass FileStoragePermissions(unittest.TestCase):\n    def setUp(self):\n        self.umask = 0o027\n        old_umask = os.umask(self.umask)\n        self.addCleanup(os.umask, old_umask)\n        self.storage_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.storage_dir)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=0o654)\n    def test_file_upload_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_file\", ContentFile(\"data\"))\n        actual_mode = os.stat(self.storage.path(name))[0] & 0o777\n        self.assertEqual(actual_mode, 0o654)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=None)\n    def test_file_upload_default_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        fname = self.storage.save(\"some_file\", ContentFile(\"data\"))\n        mode = os.stat(self.storage.path(fname))[0] & 0o777\n        self.assertEqual(mode, 0o666 & ~self.umask)\n\n    @override_settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765)\n    def test_file_upload_directory_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_directory/subdir/the_file\", ContentFile(\"data\"))\n        file_path = Path(self.storage.path(name))\n        self.assertEqual(file_path.parent.stat().st_mode & 0o777, 0o765)\n        self.assertEqual(file_path.parent.parent.stat().st_mode & 0o777, 0o765)"}, {"file": "django/core/files/storage/memory.py", "name": "InMemoryStorage.file_permissions_mode", "type": "codeblock", "score": 6.554988861083984, "line": 167, "text": "@deconstructible(path=\"django.core.files.storage.InMemoryStorage\")\nclass InMemoryStorage(Storage, StorageSettingsMixin):\n    \"\"\"A storage saving files in memory.\"\"\"\n\n    def __init__(\n        self,\n        location=None,\n        base_url=None,\n        file_permissions_mode=None,\n        directory_permissions_mode=None,\n    ):\n        self._location = location\n        self._base_url = base_url\n        self._file_permissions_mode = file_permissions_mode\n        self._directory_permissions_mode = directory_permissions_mode\n        self._root = InMemoryDirNode()\n        self._resolve(\n            self.base_location, create_if_missing=True, leaf_cls=InMemoryDirNode\n        )\n        setting_changed.connect(self._clear_cached_properties)\n\n    @cached_property\n    def base_location(self):\n        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n\n    @cached_property\n    def location(self):\n        return os.path.abspath(self.base_location)\n\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith(\"/\"):\n            self._base_url += \"/\"\n        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n\n    @cached_property\n    def file_permissions_mode(self):\n        return self._value_or_setting(\n            self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS\n        )\n\n    @cached_property\n    def directory_permissions_mode(self):\n        return self._value_or_setting(\n            self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS\n        )\n\n    def _relative_path(self, name):\n        full_path = self.path(name)\n        return os.path.relpath(full_path, self.location)\n\n    def _resolve(self, name, create_if_missing=False, leaf_cls=None, check_exists=True):\n        try:\n            relative_path = self._relative_path(name)\n            return self._root.resolve(\n                relative_path,\n                create_if_missing=create_if_missing,\n                leaf_cls=leaf_cls,\n                check_exists=check_exists,\n            )\n        except NotADirectoryError as exc:\n            absolute_path = self.path(exc.filename)\n            raise FileExistsError(f\"{absolute_path} exists and is not a directory.\")\n\n    def _open(self, name, mode=\"rb\"):\n        create_if_missing = \"w\" in mode\n        file_node = self._resolve(\n            name, create_if_missing=create_if_missing, leaf_cls=InMemoryFileNode\n        )\n        return file_node.open(mode)"}, {"file": "django/core/files/storage/__init__.py", "name": "imports", "type": "codeblock", "score": 5.71127462387085, "line": 1, "text": "from django.conf import DEFAULT_STORAGE_ALIAS\nfrom django.utils.functional import LazyObject\n\nfrom .base import Storage\nfrom .filesystem import FileSystemStorage\nfrom .handler import InvalidStorageError, StorageHandler\nfrom .memory import InMemoryStorage\n\n__all__ = (\n    \"FileSystemStorage\",\n    \"InMemoryStorage\",\n    \"Storage\",\n    \"DefaultStorage\",\n    \"default_storage\",\n    \"InvalidStorageError\",\n    \"StorageHandler\",\n    \"storages\",\n)\n\n\nclass DefaultStorage(LazyObject):\n    def _setup(self):\n        self._wrapped = storages[DEFAULT_STORAGE_ALIAS]\n\n\nstorages = StorageHandler()\ndefault_storage = DefaultStorage()"}, {"file": "django/core/files/storage/mixins.py", "name": "StorageSettingsMixin", "type": "codeblock", "score": 5.270992755889893, "line": 1, "text": "class StorageSettingsMixin:\n    def _clear_cached_properties(self, setting, **kwargs):\n        \"\"\"Reset setting based property values.\"\"\"\n        if setting == \"MEDIA_ROOT\":\n            self.__dict__.pop(\"base_location\", None)\n            self.__dict__.pop(\"location\", None)\n        elif setting == \"MEDIA_URL\":\n            self.__dict__.pop(\"base_url\", None)\n        elif setting == \"FILE_UPLOAD_PERMISSIONS\":\n            self.__dict__.pop(\"file_permissions_mode\", None)\n        elif setting == \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\":\n            self.__dict__.pop(\"directory_permissions_mode\", None)\n\n    def _value_or_setting(self, value, setting):\n        return setting if value is None else value"}, {"file": "django/core/files/storage/memory.py", "name": "InMemoryStorage._save", "type": "codeblock", "score": 5.175370216369629, "line": 238, "text": "@deconstructible(path=\"django.core.files.storage.InMemoryStorage\")\nclass InMemoryStorage(Storage, StorageSettingsMixin):\n\n    def _save(self, name, content):\n        file_node = self._resolve(\n            name, create_if_missing=True, leaf_cls=InMemoryFileNode\n        )\n        fd = None\n        for chunk in content.chunks():\n            if fd is None:\n                mode = \"wb\" if isinstance(chunk, bytes) else \"wt\"\n                fd = file_node.open(mode)\n            fd.write(chunk)\n\n        if hasattr(content, \"temporary_file_path\"):\n            os.remove(content.temporary_file_path())\n\n        file_node.modified_time = now()\n        return self._relative_path(name).replace(\"\\\\\", \"/\")"}, {"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_staticfiles_storage", "type": "codeblock", "score": 5.1359429359436035, "line": 1925, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_staticfiles_storage(self):\n        \"\"\"\n        Overriding the STORAGES setting should be reflected in\n        the value of django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        new_class = \"ManifestStaticFilesStorage\"\n        new_storage = \"django.contrib.staticfiles.storage.\" + new_class\n        with self.settings(\n            STORAGES={STATICFILES_STORAGE_ALIAS: {\"BACKEND\": new_storage}}\n        ):\n            self.assertEqual(staticfiles_storage.__class__.__name__, new_class)\n\n    def test_override_staticfiles_finders(self):\n        \"\"\"\n        Overriding the STATICFILES_FINDERS setting should be reflected in\n        the return value of django.contrib.staticfiles.finders.get_finders.\n        \"\"\"\n        current = get_finders()\n        self.assertGreater(len(list(current)), 1)\n        finders = [\"django.contrib.staticfiles.finders.FileSystemFinder\"]\n        with self.settings(STATICFILES_FINDERS=finders):\n            self.assertEqual(len(list(get_finders())), len(finders))"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage.location", "type": "codeblock", "score": 4.658048629760742, "line": 1, "text": "import os\nfrom datetime import UTC, datetime\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom django.core.files import File, locks\nfrom django.core.files.move import file_move_safe\nfrom django.core.signals import setting_changed\nfrom django.utils._os import safe_join\nfrom django.utils.deconstruct import deconstructible\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.functional import cached_property\n\nfrom .base import Storage\nfrom .mixins import StorageSettingsMixin\n\n\n@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n    \"\"\"\n    Standard filesystem storage\n    \"\"\"\n\n    def __init__(\n        self,\n        location=None,\n        base_url=None,\n        file_permissions_mode=None,\n        directory_permissions_mode=None,\n        allow_overwrite=False,\n    ):\n        self._location = location\n        self._base_url = base_url\n        self._file_permissions_mode = file_permissions_mode\n        self._directory_permissions_mode = directory_permissions_mode\n        self._allow_overwrite = allow_overwrite\n        setting_changed.connect(self._clear_cached_properties)\n\n    @cached_property\n    def base_location(self):\n        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n\n    @cached_property\n    def location(self):\n        return os.path.abspath(self.base_location)\n\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith(\"/\"):\n            self._base_url += \"/\"\n        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n\n    @cached_property\n    def file_permissions_mode(self):\n        return self._value_or_setting(\n            self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS\n        )\n\n    @cached_property\n    def directory_permissions_mode(self):\n        return self._value_or_setting(\n            self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS\n        )\n\n    def _open(self, name, mode=\"rb\"):\n        return File(open(self.path(name), mode))"}, {"file": "django/core/files/storage/base.py", "name": "imports", "type": "codeblock", "score": 4.247868537902832, "line": 1, "text": "import os\nimport pathlib\n\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.core.files import File\nfrom django.core.files.utils import validate_file_name\nfrom django.utils.crypto import get_random_string\nfrom django.utils.text import get_valid_filename\n\n\nclass Storage:\n    \"\"\"\n    A base storage class, providing some default behaviors that all other\n    storage systems can inherit or override, as necessary.\n    \"\"\"\n\n    # The following methods represent a public interface to private methods.\n    # These shouldn't be overridden by subclasses unless absolutely necessary.\n\n    def open(self, name, mode=\"rb\"):\n        \"\"\"Retrieve the specified file from storage.\"\"\"\n        return self._open(name, mode)\n\n    def save(self, name, content, max_length=None):\n        \"\"\"\n        Save new content to the file specified by name. The content should be\n        a proper File object or any Python file-like object, ready to be read\n        from the beginning.\n        \"\"\"\n        # Get the proper name for the file, as it will actually be saved.\n        if name is None:\n            name = content.name\n\n        if not hasattr(content, \"chunks\"):\n            content = File(content, name)\n\n        # Ensure that the name is valid, before and after having the storage\n        # system potentially modifying the name. This duplicates the check made\n        # inside `get_available_name` but it's necessary for those cases where\n        # `get_available_name` is overridden and validation is lost.\n        validate_file_name(name, allow_relative_path=True)\n\n        # Potentially find a different name depending on storage constraints.\n        name = self.get_available_name(name, max_length=max_length)\n        # Validate the (potentially) new name.\n        validate_file_name(name, allow_relative_path=True)\n\n        # The save operation should return the actual name of the file saved.\n        name = self._save(name, content)\n        # Ensure that the name returned from the storage system is still valid.\n        validate_file_name(name, allow_relative_path=True)\n        return name"}], "total_results": 10}
{"repo": "django", "query": "collectstatic default permission warning", "top_10": [{"file": "django/contrib/auth/migrations/0011_update_proxy_permissions.py", "name": "imports", "type": "codeblock", "score": 5.4442009925842285, "line": 1, "text": "import sys\n\nfrom django.core.management.color import color_style\nfrom django.db import IntegrityError, migrations, transaction\nfrom django.db.models import Q\n\nWARNING = \"\"\"\n    A problem arose migrating proxy model permissions for {old} to {new}.\n\n      Permission(s) for {new} already existed.\n      Codenames Q: {query}\n\n    Ensure to audit ALL permissions for {old} and {new}.\n\"\"\"\n\n\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model(\"auth\", \"Permission\")\n    ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n    alias = schema_editor.connection.alias\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            \"%s_%s\" % (action, opts.model_name) for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query |= Q(codename=codename, name=name)\n        content_type_manager = ContentType.objects.db_manager(alias)\n        concrete_content_type = content_type_manager.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = content_type_manager.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        try:\n            with transaction.atomic(using=alias):\n                Permission.objects.using(alias).filter(\n                    permissions_query,\n                    content_type=old_content_type,\n                ).update(content_type=new_content_type)\n        except IntegrityError:\n            old = \"{}_{}\".format(old_content_type.app_label, old_content_type.model)\n            new = \"{}_{}\".format(new_content_type.app_label, new_content_type.model)\n            sys.stdout.write(\n                style.WARNING(WARNING.format(old=old, new=new, query=permissions_query))\n            )"}, {"file": "django/contrib/auth/migrations/0001_initial.py", "name": "imports", "type": "codeblock", "score": 4.355393886566162, "line": 1, "text": "import django.contrib.auth.models\nfrom django.contrib.auth import validators\nfrom django.db import migrations, models\nfrom django.utils import timezone\n\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        (\"contenttypes\", \"__first__\"),\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name=\"Permission\",\n            fields=[\n                (\n                    \"id\",\n                    models.AutoField(\n                        verbose_name=\"ID\",\n                        serialize=False,\n                        auto_created=True,\n                        primary_key=True,\n                    ),\n                ),\n                (\"name\", models.CharField(max_length=50, verbose_name=\"name\")),\n                (\n                    \"content_type\",\n                    models.ForeignKey(\n                        to=\"contenttypes.ContentType\",\n                        on_delete=models.CASCADE,\n                        verbose_name=\"content type\",\n                    ),\n                ),\n                (\"codename\", models.CharField(max_length=100, verbose_name=\"codename\")),\n            ],\n            options={\n                \"ordering\": [\n                    \"content_type__app_label\",\n                    \"content_type__model\",\n                    \"codename\",\n                ],\n                \"unique_together\": {(\"content_type\", \"codename\")},\n                \"verbose_name\": \"permission\",\n                \"verbose_name_plural\": \"permissions\",\n            },\n            managers=[\n                (\"objects\", django.contrib.auth.models.PermissionManager()),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"Group\",\n            fields=[\n                (\n                    \"id\",\n                    models.AutoField(\n                        verbose_name=\"ID\",\n                        serialize=False,\n                        auto_created=True,\n                        primary_key=True,\n                    ),\n                ),\n                (\n                    \"name\",\n                    models.CharField(unique=True, max_length=80, verbose_name=\"name\"),\n                ),\n                (\n                    \"permissions\",\n                    models.ManyToManyField(\n                        to=\"auth.Permission\", verbose_name=\"permissions\", blank=True\n                    ),\n                ),\n            ],\n            options={\n                \"verbose_name\": \"group\",\n                \"verbose_name_plural\": \"groups\",\n            },\n            managers=[\n                (\"objects\", django.contrib.auth.models.GroupManager()),\n            ],\n        ),\n        migrations.CreateModel(\n            name=\"User\",\n            fields=[\n                (\n                    \"id\",\n                    models.AutoField(\n                        verbose_name=\"ID\",\n                        serialize=False,\n                        auto_created=True,\n                        primary_key=True,\n                    ),\n                ),\n                (\"password\", models.CharField(max_length=128, verbose_name=\"password\")),\n                (\n                    \"last_login\",\n                    models.DateTimeField(\n                        default=timezone.now, verbose_name=\"last login\"\n                    ),\n                ),\n                (\n                    \"is_superuser\",\n                    models.BooleanField(\n                        default=False,\n                        help_text=(\n                            \"Designates that this user has all permissions without \"\n                            \"explicitly assigning them.\"\n                        ),\n                        verbose_name=\"superuser status\",\n                    ),\n                ),\n                (\n                    \"username\",\n                    models.CharField(\n                        help_text=(\n                            \"Required. 30 characters or fewer. Letters, digits and \"\n                            \"@/./+/-/_ only.\"\n                        ),\n                        unique=True,\n                        max_length=30,\n                        verbose_name=\"username\",\n                        validators=[validators.UnicodeUsernameValidator()],\n                    ),\n                ),\n                (\n                    \"first_name\",\n                    models.CharField(\n                        max_length=30, verbose_name=\"first name\", blank=True\n                    ),\n                ),\n                (\n                    \"last_name\",\n                    models.CharField(\n                        max_length=30, verbose_name=\"last name\", blank=True\n                    ),\n                ),\n                (\n                    \"email\",\n                    models.EmailField(\n                        max_length=75, verbose_name=\"email address\", blank=True\n                    ),\n                ),\n                (\n                    \"is_staff\",\n                    models.BooleanField(\n                        default=False,\n                        help_text=(\n                            \"Designates whether the user can log into this admin site.\"\n                        ),\n                        verbose_name=\"staff status\",\n                    ),\n                ),\n                (\n                    \"is_active\",\n                    models.BooleanField(\n                        default=True,\n                        verbose_name=\"active\",\n                        help_text=(\n                            \"Designates whether this user should be treated as active. \"\n                            \"Unselect this instead of deleting accounts.\"\n                        ),\n                    ),\n                ),\n                (\n                    \"date_joined\",\n                    models.DateTimeField(\n                        default=timezone.now, verbose_name=\"date joined\"\n                    ),\n                ),\n                (\n                    \"groups\",\n                    models.ManyToManyField(\n                        to=\"auth.Group\",\n                        verbose_name=\"groups\",\n                        blank=True,\n                        related_name=\"user_set\",\n                        related_query_name=\"user\",\n                        help_text=(\n                            \"The groups this user belongs to. A user will get all \"\n                            \"permissions granted to each of their groups.\"\n                        ),\n                    ),\n                ),\n                (\n                    \"user_permissions\",\n                    models.ManyToManyField(\n                        to=\"auth.Permission\",\n                        verbose_name=\"user permissions\",\n                        blank=True,\n                        help_text=\"Specific permissions for this user.\",\n                        related_name=\"user_set\",\n                        related_query_name=\"user\",\n                    ),\n                ),\n            ],\n            options={\n                \"swappable\": \"AUTH_USER_MODEL\",\n                \"verbose_name\": \"user\",\n                \"verbose_name_plural\": \"users\",\n            },\n            managers=[\n                (\"objects\", django.contrib.auth.models.UserManager()),\n            ],\n        ),\n    ]"}, {"file": "tests/logging_tests/tests.py", "name": "HandlerLoggingTests.test_internal_server_error_599", "type": "codeblock", "score": 4.214171409606934, "line": 204, "text": "@override_settings(DEBUG=True, ROOT_URLCONF=\"logging_tests.urls\")\nclass HandlerLoggingTests(\n    SetupDefaultLoggingMixin, LoggingAssertionMixin, LoggingCaptureMixin, SimpleTestCase\n):\n\n    def test_internal_server_error_599(self):\n        self.assertLogsRequest(\n            url=\"/internal_server_error/?status=599\",\n            level=\"ERROR\",\n            status_code=599,\n            msg=\"Unknown Status Code: /internal_server_error/\",\n        )\n\n    def test_permission_denied(self):\n        self.assertLogsRequest(\n            url=\"/permission_denied/\",\n            level=\"WARNING\",\n            status_code=403,\n            msg=\"Forbidden (Permission denied): /permission_denied/\",\n            exc_class=PermissionDenied,\n        )\n\n    def test_multi_part_parser_error(self):\n        self.assertLogsRequest(\n            url=\"/multi_part_parser_error/\",\n            level=\"WARNING\",\n            status_code=400,\n            msg=\"Bad request (Unable to parse request body): /multi_part_parser_error/\",\n            exc_class=MultiPartParserError,\n        )"}, {"file": "django/contrib/auth/admin.py", "name": "UserAdmin._add_view", "type": "codeblock", "score": 4.213878631591797, "line": 113, "text": "@admin.register(User)\nclass UserAdmin(admin.ModelAdmin):\n\n    @method_decorator([sensitive_post_parameters(), csrf_protect])\n    def add_view(self, request, form_url=\"\", extra_context=None):\n        if request.method in (\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"):\n            return self._add_view(request, form_url, extra_context)\n\n        with transaction.atomic(using=router.db_for_write(self.model)):\n            return self._add_view(request, form_url, extra_context)\n\n    def _add_view(self, request, form_url=\"\", extra_context=None):\n        # It's an error for a user to have add permission but NOT change\n        # permission for users. If we allowed such users to add users, they\n        # could create superusers, which would mean they would essentially have\n        # the permission to change users. To avoid the problem entirely, we\n        # disallow users from adding users if they don't have change\n        # permission.\n        if not self.has_change_permission(request):\n            if self.has_add_permission(request) and settings.DEBUG:\n                # Raise Http404 in debug mode so that the user gets a helpful\n                # error message.\n                raise Http404(\n                    'Your user does not have the \"Change user\" permission. In '\n                    \"order to add users, Django requires that your user \"\n                    'account have both the \"Add user\" and \"Change user\" '\n                    \"permissions set.\"\n                )\n            raise PermissionDenied\n        if extra_context is None:\n            extra_context = {}\n        username_field = self.opts.get_field(self.model.USERNAME_FIELD)\n        defaults = {\n            \"auto_populated_fields\": (),\n            \"username_help_text\": username_field.help_text,\n        }\n        extra_context.update(defaults)\n        return super().add_view(request, form_url, extra_context)"}, {"file": "django/contrib/auth/management/__init__.py", "name": "_get_all_permissions", "type": "codeblock", "score": 4.13219690322876, "line": 1, "text": "\"\"\"\nCreates permissions for all installed apps that need permissions.\n\"\"\"\n\nimport getpass\nimport unicodedata\n\nfrom django.apps import apps as global_apps\nfrom django.contrib.auth import get_permission_codename\nfrom django.contrib.contenttypes.management import create_contenttypes\nfrom django.core import exceptions\nfrom django.db import DEFAULT_DB_ALIAS, migrations, router, transaction\nfrom django.db.utils import IntegrityError\nfrom django.utils.text import camel_case_to_spaces\n\n\ndef _get_all_permissions(opts):\n    \"\"\"\n    Return (codename, name) for all permissions in the given opts.\n    \"\"\"\n    return [*_get_builtin_permissions(opts), *opts.permissions]\n\n\ndef _get_builtin_permissions(opts):\n    \"\"\"\n    Return (codename, name) for all autogenerated permissions.\n    By default, this is ('add', 'change', 'delete', 'view')\n    \"\"\"\n    perms = []\n    for action in opts.default_permissions:\n        perms.append(\n            (\n                get_permission_codename(action, opts),\n                \"Can %s %s\" % (action, opts.verbose_name_raw),\n            )\n        )\n    return perms"}, {"file": "django/contrib/auth/models.py", "name": "PermissionsMixin.aget_user_permissions", "type": "codeblock", "score": 4.041224479675293, "line": 317, "text": "class PermissionsMixin(models.Model):\n    \"\"\"\n    Add the fields and methods necessary to support the Group and Permission\n    models using the ModelBackend.\n    \"\"\"\n\n    is_superuser = models.BooleanField(\n        _(\"superuser status\"),\n        default=False,\n        help_text=_(\n            \"Designates that this user has all permissions without \"\n            \"explicitly assigning them.\"\n        ),\n    )\n    groups = models.ManyToManyField(\n        Group,\n        verbose_name=_(\"groups\"),\n        blank=True,\n        help_text=_(\n            \"The groups this user belongs to. A user will get all permissions \"\n            \"granted to each of their groups.\"\n        ),\n        related_name=\"user_set\",\n        related_query_name=\"user\",\n    )\n    user_permissions = models.ManyToManyField(\n        Permission,\n        verbose_name=_(\"user permissions\"),\n        blank=True,\n        help_text=_(\"Specific permissions for this user.\"),\n        related_name=\"user_set\",\n        related_query_name=\"user\",\n    )\n\n    class Meta:\n        abstract = True\n\n    def get_user_permissions(self, obj=None):\n        \"\"\"\n        Return a list of permission strings that this user has directly.\n        Query all available auth backends. If an object is passed in,\n        return only permissions matching this object.\n        \"\"\"\n        return _user_get_permissions(self, obj, \"user\")\n\n    async def aget_user_permissions(self, obj=None):\n        \"\"\"See get_user_permissions()\"\"\"\n        return await _auser_get_permissions(self, obj, \"user\")\n\n    def get_group_permissions(self, obj=None):\n        \"\"\"\n        Return a list of permission strings that this user has through their\n        groups. Query all available auth backends. If an object is passed in,\n        return only permissions matching this object.\n        \"\"\"\n        return _user_get_permissions(self, obj, \"group\")\n\n    async def aget_group_permissions(self, obj=None):\n        \"\"\"See get_group_permissions()\"\"\"\n        return await _auser_get_permissions(self, obj, \"group\")\n\n    def get_all_permissions(self, obj=None):\n        return _user_get_permissions(self, obj, \"all\")\n\n    async def aget_all_permissions(self, obj=None):\n        return await _auser_get_permissions(self, obj, \"all\")"}, {"file": "django/contrib/admin/options.py", "name": "BaseModelAdmin.has_delete_permission", "type": "codeblock", "score": 4.001637935638428, "line": 583, "text": "class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n\n    def has_delete_permission(self, request, obj=None):\n        \"\"\"\n        Return True if the given request has permission to delete the given\n        Django model instance, the default implementation doesn't examine the\n        `obj` parameter.\n\n        Can be overridden by the user in subclasses. In such case it should\n        return True if the given request has permission to delete the `obj`\n        model instance. If `obj` is None, this should return True if the given\n        request has permission to delete *any* object of the given type.\n        \"\"\"\n        opts = self.opts\n        codename = get_permission_codename(\"delete\", opts)\n        return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))"}, {"file": "django/contrib/admin/options.py", "name": "BaseModelAdmin.has_change_permission", "type": "codeblock", "score": 3.9277701377868652, "line": 559, "text": "class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n\n    def has_add_permission(self, request):\n        \"\"\"\n        Return True if the given request has permission to add an object.\n        Can be overridden by the user in subclasses.\n        \"\"\"\n        opts = self.opts\n        codename = get_permission_codename(\"add\", opts)\n        return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n\n    def has_change_permission(self, request, obj=None):\n        \"\"\"\n        Return True if the given request has permission to change the given\n        Django model instance, the default implementation doesn't examine the\n        `obj` parameter.\n\n        Can be overridden by the user in subclasses. In such case it should\n        return True if the given request has permission to change the `obj`\n        model instance. If `obj` is None, this should return True if the given\n        request has permission to change *any* object of the given type.\n        \"\"\"\n        opts = self.opts\n        codename = get_permission_codename(\"change\", opts)\n        return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))"}, {"file": "django/contrib/admin/options.py", "name": "BaseModelAdmin.has_view_permission", "type": "codeblock", "score": 3.9232301712036133, "line": 598, "text": "class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n\n    def has_view_permission(self, request, obj=None):\n        \"\"\"\n        Return True if the given request has permission to view the given\n        Django model instance. The default implementation doesn't examine the\n        `obj` parameter.\n\n        If overridden by the user in subclasses, it should return True if the\n        given request has permission to view the `obj` model instance. If `obj`\n        is None, it should return True if the request has permission to view\n        any object of the given type.\n        \"\"\"\n        opts = self.opts\n        codename_view = get_permission_codename(\"view\", opts)\n        codename_change = get_permission_codename(\"change\", opts)\n        return request.user.has_perm(\n            \"%s.%s\" % (opts.app_label, codename_view)\n        ) or request.user.has_perm(\"%s.%s\" % (opts.app_label, codename_change))"}, {"file": "django/contrib/auth/backends.py", "name": "ModelBackend.aget_user", "type": "codeblock", "score": 3.89886474609375, "line": 195, "text": "class ModelBackend(BaseBackend):\n\n    def with_perm(self, perm, is_active=True, include_superusers=True, obj=None):\n        \"\"\"\n        Return users that have permission \"perm\". By default, filter out\n        inactive users and include superusers.\n        \"\"\"\n        if isinstance(perm, str):\n            try:\n                app_label, codename = perm.split(\".\")\n            except ValueError:\n                raise ValueError(\n                    \"Permission name should be in the form \"\n                    \"app_label.permission_codename.\"\n                )\n        elif not isinstance(perm, Permission):\n            raise TypeError(\n                \"The `perm` argument must be a string or a permission instance.\"\n            )\n\n        if obj is not None:\n            return UserModel._default_manager.none()\n\n        permission_q = Q(group__user=OuterRef(\"pk\")) | Q(user=OuterRef(\"pk\"))\n        if isinstance(perm, Permission):\n            permission_q &= Q(pk=perm.pk)\n        else:\n            permission_q &= Q(codename=codename, content_type__app_label=app_label)\n\n        user_q = Exists(Permission.objects.filter(permission_q))\n        if include_superusers:\n            user_q |= Q(is_superuser=True)\n        if is_active is not None:\n            user_q &= Q(is_active=is_active)\n\n        return UserModel._default_manager.filter(user_q)\n\n    def get_user(self, user_id):\n        try:\n            user = UserModel._default_manager.get(pk=user_id)\n        except UserModel.DoesNotExist:\n            return None\n        return user if self.user_can_authenticate(user) else None\n\n    async def aget_user(self, user_id):\n        try:\n            user = await UserModel._default_manager.aget(pk=user_id)\n        except UserModel.DoesNotExist:\n            return None\n        return user if self.user_can_authenticate(user) else None"}], "total_results": 10}
{"repo": "django", "query": "file_storage tests for FILE_UPLOAD_PERMISSION", "top_10": [{"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_setting_changed", "type": "codeblock", "score": 7.066770076751709, "line": 541, "text": "class FileStorageTests(SimpleTestCase):\n\n    @override_settings(\n        MEDIA_ROOT=\"media_root\",\n        MEDIA_URL=\"media_url/\",\n        FILE_UPLOAD_PERMISSIONS=0o777,\n        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777,\n    )\n    def test_setting_changed(self):\n        \"\"\"\n        Properties using settings values as defaults should be updated on\n        referenced settings change while specified values should be unchanged.\n        \"\"\"\n        storage = self.storage_class(\n            location=\"explicit_location\",\n            base_url=\"explicit_base_url/\",\n            file_permissions_mode=0o666,\n            directory_permissions_mode=0o666,\n        )\n        defaults_storage = self.storage_class()\n        settings = {\n            \"MEDIA_ROOT\": \"overridden_media_root\",\n            \"MEDIA_URL\": \"/overridden_media_url/\",\n            \"FILE_UPLOAD_PERMISSIONS\": 0o333,\n            \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\": 0o333,\n        }\n        with self.settings(**settings):\n            self.assertEqual(storage.base_location, \"explicit_location\")\n            self.assertIn(\"explicit_location\", storage.location)\n            self.assertEqual(storage.base_url, \"explicit_base_url/\")\n            self.assertEqual(storage.file_permissions_mode, 0o666)\n            self.assertEqual(storage.directory_permissions_mode, 0o666)\n            self.assertEqual(defaults_storage.base_location, settings[\"MEDIA_ROOT\"])\n            self.assertIn(settings[\"MEDIA_ROOT\"], defaults_storage.location)\n            self.assertEqual(defaults_storage.base_url, settings[\"MEDIA_URL\"])\n            self.assertEqual(\n                defaults_storage.file_permissions_mode,\n                settings[\"FILE_UPLOAD_PERMISSIONS\"],\n            )\n            self.assertEqual(\n                defaults_storage.directory_permissions_mode,\n                settings[\"FILE_UPLOAD_DIRECTORY_PERMISSIONS\"],\n            )"}, {"file": "tests/file_storage/tests.py", "name": "FileStoragePermissions.test_file_upload_permissions", "type": "codeblock", "score": 5.641693115234375, "line": 1104, "text": "@unittest.skipIf(\n    sys.platform == \"win32\", \"Windows only partially supports umasks and chmod.\"\n)\nclass FileStoragePermissions(unittest.TestCase):\n    def setUp(self):\n        self.umask = 0o027\n        old_umask = os.umask(self.umask)\n        self.addCleanup(os.umask, old_umask)\n        self.storage_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.storage_dir)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=0o654)\n    def test_file_upload_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_file\", ContentFile(\"data\"))\n        actual_mode = os.stat(self.storage.path(name))[0] & 0o777\n        self.assertEqual(actual_mode, 0o654)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=None)\n    def test_file_upload_default_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        fname = self.storage.save(\"some_file\", ContentFile(\"data\"))\n        mode = os.stat(self.storage.path(fname))[0] & 0o777\n        self.assertEqual(mode, 0o666 & ~self.umask)\n\n    @override_settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765)\n    def test_file_upload_directory_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_directory/subdir/the_file\", ContentFile(\"data\"))\n        file_path = Path(self.storage.path(name))\n        self.assertEqual(file_path.parent.stat().st_mode & 0o777, 0o765)\n        self.assertEqual(file_path.parent.parent.stat().st_mode & 0o777, 0o765)"}, {"file": "tests/file_storage/tests.py", "name": "FileLikeObjectTestCase.test_urllib_request_urlopen", "type": "codeblock", "score": 3.6733241081237793, "line": 1197, "text": "@override_settings(ROOT_URLCONF=\"file_storage.urls\")\nclass FileLikeObjectTestCase(LiveServerTestCase):\n    \"\"\"\n    Test file-like objects (#15644).\n    \"\"\"\n\n    available_apps = []\n\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n        self.storage = FileSystemStorage(location=self.temp_dir)\n\n    def test_urllib_request_urlopen(self):\n        \"\"\"\n        Test the File storage API with a file-like object coming from\n        urllib.request.urlopen().\n        \"\"\"\n        file_like_object = urlopen(self.live_server_url + \"/\")\n        f = File(file_like_object)\n        stored_filename = self.storage.save(\"remote_file.html\", f)\n\n        remote_file = urlopen(self.live_server_url + \"/\")\n        with self.storage.open(stored_filename) as stored_file:\n            self.assertEqual(stored_file.read(), remote_file.read())"}, {"file": "tests/file_storage/urls.py", "name": "imports", "type": "codeblock", "score": 3.56146502494812, "line": 1, "text": "from django.http import HttpResponse\nfrom django.urls import path\n\nurlpatterns = [\n    path(\"\", lambda req: HttpResponse(\"example view\")),\n]"}, {"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_file_upload_permissions", "type": "codeblock", "score": 3.54014253616333, "line": 1861, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_media_root(self):\n        \"\"\"\n        Overriding the MEDIA_ROOT setting should be reflected in the\n        base_location attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_ROOT=\"test_value\"):\n            self.assertEqual(default_storage.base_location, \"test_value\")\n\n    def test_override_media_url(self):\n        \"\"\"\n        Overriding the MEDIA_URL setting should be reflected in the\n        base_url attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_URL=\"/test_value/\"):\n            self.assertEqual(default_storage.base_url, \"/test_value/\")\n\n    def test_override_file_upload_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n        the file_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n        with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.file_permissions_mode, 0o777)\n\n    def test_override_file_upload_directory_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n        reflected in the directory_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertIsNone(default_storage.directory_permissions_mode)\n        with self.settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.directory_permissions_mode, 0o777)\n\n    def test_override_database_routers(self):\n        \"\"\"\n        Overriding DATABASE_ROUTERS should update the base router.\n        \"\"\"\n        test_routers = [object()]\n        with self.settings(DATABASE_ROUTERS=test_routers):\n            self.assertEqual(router.routers, test_routers)\n\n    def test_override_static_url(self):\n        \"\"\"\n        Overriding the STATIC_URL setting should be reflected in the\n        base_url attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_URL=\"/test/\"):\n            self.assertEqual(staticfiles_storage.base_url, \"/test/\")\n\n    def test_override_static_root(self):\n        \"\"\"\n        Overriding the STATIC_ROOT setting should be reflected in the\n        location attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_ROOT=\"/tmp/test\"):\n            self.assertEqual(staticfiles_storage.location, os.path.abspath(\"/tmp/test\"))"}, {"file": "django/core/files/storage/mixins.py", "name": "StorageSettingsMixin", "type": "codeblock", "score": 3.408830404281616, "line": 1, "text": "class StorageSettingsMixin:\n    def _clear_cached_properties(self, setting, **kwargs):\n        \"\"\"Reset setting based property values.\"\"\"\n        if setting == \"MEDIA_ROOT\":\n            self.__dict__.pop(\"base_location\", None)\n            self.__dict__.pop(\"location\", None)\n        elif setting == \"MEDIA_URL\":\n            self.__dict__.pop(\"base_url\", None)\n        elif setting == \"FILE_UPLOAD_PERMISSIONS\":\n            self.__dict__.pop(\"file_permissions_mode\", None)\n        elif setting == \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\":\n            self.__dict__.pop(\"directory_permissions_mode\", None)\n\n    def _value_or_setting(self, value, setting):\n        return setting if value is None else value"}, {"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_base_url", "type": "codeblock", "score": 3.077251672744751, "line": 372, "text": "class FileStorageTests(SimpleTestCase):\n\n    def test_base_url(self):\n        \"\"\"\n        File storage returns a url even when its base_url is unset or modified.\n        \"\"\"\n        self.storage.base_url = None\n        with self.assertRaises(ValueError):\n            self.storage.url(\"test.file\")\n\n        # #22717: missing ending slash in base_url should be auto-corrected\n        storage = self.storage_class(\n            location=self.temp_dir, base_url=\"/no_ending_slash\"\n        )\n        self.assertEqual(\n            storage.url(\"test.file\"), \"%s%s\" % (storage.base_url, \"test.file\")\n        )"}, {"file": "tests/file_storage/tests.py", "name": "FileFieldStorageTests.test_filefield_read", "type": "codeblock", "score": 3.0587849617004395, "line": 794, "text": "class FileFieldStorageTests(TestCase):\n\n    def test_filefield_read(self):\n        # Files can be read in a little at a time, if necessary.\n        obj = Storage.objects.create(\n            normal=SimpleUploadedFile(\"assignment.txt\", b\"content\")\n        )\n        obj.normal.open()\n        self.assertEqual(obj.normal.read(3), b\"con\")\n        self.assertEqual(obj.normal.read(), b\"tent\")\n        self.assertEqual(\n            list(obj.normal.chunks(chunk_size=2)), [b\"co\", b\"nt\", b\"en\", b\"t\"]\n        )\n        obj.normal.close()"}, {"file": "tests/file_storage/tests.py", "name": "ContentFileStorageTestCase.test_content_saving", "type": "codeblock", "score": 3.044065475463867, "line": 1182, "text": "class ContentFileStorageTestCase(unittest.TestCase):\n    def setUp(self):\n        storage_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, storage_dir)\n        self.storage = FileSystemStorage(storage_dir)\n\n    def test_content_saving(self):\n        \"\"\"\n        ContentFile can be saved correctly with the filesystem storage,\n        if it was initialized with either bytes or unicode content.\n        \"\"\"\n        self.storage.save(\"bytes.txt\", ContentFile(b\"content\"))\n        self.storage.save(\"unicode.txt\", ContentFile(\"espa\u00f1ol\"))"}, {"file": "tests/file_storage/tests.py", "name": "FileFieldStorageTests.test_duplicate_filename", "type": "codeblock", "score": 3.023975372314453, "line": 829, "text": "class FileFieldStorageTests(TestCase):\n\n    def test_duplicate_filename(self):\n        # Multiple files with the same name get _(7 random chars) appended to\n        # them.\n        tests = [\n            (\"multiple_files\", \"txt\"),\n            (\"multiple_files_many_extensions\", \"tar.gz\"),\n        ]\n        for filename, extension in tests:\n            with self.subTest(filename=filename):\n                objs = [Storage() for i in range(2)]\n                for o in objs:\n                    o.normal.save(f\"{filename}.{extension}\", ContentFile(\"Content\"))\n                try:\n                    names = [o.normal.name for o in objs]\n                    self.assertEqual(names[0], f\"tests/{filename}.{extension}\")\n                    self.assertRegex(\n                        names[1], f\"tests/{filename}_{FILE_SUFFIX_REGEX}.{extension}\"\n                    )\n                finally:\n                    for o in objs:\n                        o.delete()"}], "total_results": 10}
{"repo": "django", "query": "storage mixins reading FILE_UPLOAD_PERMISSION", "top_10": [{"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_setting_changed", "type": "codeblock", "score": 7.8191022872924805, "line": 541, "text": "class FileStorageTests(SimpleTestCase):\n\n    @override_settings(\n        MEDIA_ROOT=\"media_root\",\n        MEDIA_URL=\"media_url/\",\n        FILE_UPLOAD_PERMISSIONS=0o777,\n        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777,\n    )\n    def test_setting_changed(self):\n        \"\"\"\n        Properties using settings values as defaults should be updated on\n        referenced settings change while specified values should be unchanged.\n        \"\"\"\n        storage = self.storage_class(\n            location=\"explicit_location\",\n            base_url=\"explicit_base_url/\",\n            file_permissions_mode=0o666,\n            directory_permissions_mode=0o666,\n        )\n        defaults_storage = self.storage_class()\n        settings = {\n            \"MEDIA_ROOT\": \"overridden_media_root\",\n            \"MEDIA_URL\": \"/overridden_media_url/\",\n            \"FILE_UPLOAD_PERMISSIONS\": 0o333,\n            \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\": 0o333,\n        }\n        with self.settings(**settings):\n            self.assertEqual(storage.base_location, \"explicit_location\")\n            self.assertIn(\"explicit_location\", storage.location)\n            self.assertEqual(storage.base_url, \"explicit_base_url/\")\n            self.assertEqual(storage.file_permissions_mode, 0o666)\n            self.assertEqual(storage.directory_permissions_mode, 0o666)\n            self.assertEqual(defaults_storage.base_location, settings[\"MEDIA_ROOT\"])\n            self.assertIn(settings[\"MEDIA_ROOT\"], defaults_storage.location)\n            self.assertEqual(defaults_storage.base_url, settings[\"MEDIA_URL\"])\n            self.assertEqual(\n                defaults_storage.file_permissions_mode,\n                settings[\"FILE_UPLOAD_PERMISSIONS\"],\n            )\n            self.assertEqual(\n                defaults_storage.directory_permissions_mode,\n                settings[\"FILE_UPLOAD_DIRECTORY_PERMISSIONS\"],\n            )"}, {"file": "django/core/files/storage/mixins.py", "name": "StorageSettingsMixin", "type": "codeblock", "score": 7.712121963500977, "line": 1, "text": "class StorageSettingsMixin:\n    def _clear_cached_properties(self, setting, **kwargs):\n        \"\"\"Reset setting based property values.\"\"\"\n        if setting == \"MEDIA_ROOT\":\n            self.__dict__.pop(\"base_location\", None)\n            self.__dict__.pop(\"location\", None)\n        elif setting == \"MEDIA_URL\":\n            self.__dict__.pop(\"base_url\", None)\n        elif setting == \"FILE_UPLOAD_PERMISSIONS\":\n            self.__dict__.pop(\"file_permissions_mode\", None)\n        elif setting == \"FILE_UPLOAD_DIRECTORY_PERMISSIONS\":\n            self.__dict__.pop(\"directory_permissions_mode\", None)\n\n    def _value_or_setting(self, value, setting):\n        return setting if value is None else value"}, {"file": "tests/file_storage/tests.py", "name": "FileStoragePermissions.test_file_upload_permissions", "type": "codeblock", "score": 6.8151750564575195, "line": 1104, "text": "@unittest.skipIf(\n    sys.platform == \"win32\", \"Windows only partially supports umasks and chmod.\"\n)\nclass FileStoragePermissions(unittest.TestCase):\n    def setUp(self):\n        self.umask = 0o027\n        old_umask = os.umask(self.umask)\n        self.addCleanup(os.umask, old_umask)\n        self.storage_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.storage_dir)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=0o654)\n    def test_file_upload_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_file\", ContentFile(\"data\"))\n        actual_mode = os.stat(self.storage.path(name))[0] & 0o777\n        self.assertEqual(actual_mode, 0o654)\n\n    @override_settings(FILE_UPLOAD_PERMISSIONS=None)\n    def test_file_upload_default_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        fname = self.storage.save(\"some_file\", ContentFile(\"data\"))\n        mode = os.stat(self.storage.path(fname))[0] & 0o777\n        self.assertEqual(mode, 0o666 & ~self.umask)\n\n    @override_settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765)\n    def test_file_upload_directory_permissions(self):\n        self.storage = FileSystemStorage(self.storage_dir)\n        name = self.storage.save(\"the_directory/subdir/the_file\", ContentFile(\"data\"))\n        file_path = Path(self.storage.path(name))\n        self.assertEqual(file_path.parent.stat().st_mode & 0o777, 0o765)\n        self.assertEqual(file_path.parent.parent.stat().st_mode & 0o777, 0o765)"}, {"file": "django/core/files/storage/filesystem.py", "name": "FileSystemStorage.location", "type": "codeblock", "score": 6.123849868774414, "line": 1, "text": "import os\nfrom datetime import UTC, datetime\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom django.core.files import File, locks\nfrom django.core.files.move import file_move_safe\nfrom django.core.signals import setting_changed\nfrom django.utils._os import safe_join\nfrom django.utils.deconstruct import deconstructible\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.functional import cached_property\n\nfrom .base import Storage\nfrom .mixins import StorageSettingsMixin\n\n\n@deconstructible(path=\"django.core.files.storage.FileSystemStorage\")\nclass FileSystemStorage(Storage, StorageSettingsMixin):\n    \"\"\"\n    Standard filesystem storage\n    \"\"\"\n\n    def __init__(\n        self,\n        location=None,\n        base_url=None,\n        file_permissions_mode=None,\n        directory_permissions_mode=None,\n        allow_overwrite=False,\n    ):\n        self._location = location\n        self._base_url = base_url\n        self._file_permissions_mode = file_permissions_mode\n        self._directory_permissions_mode = directory_permissions_mode\n        self._allow_overwrite = allow_overwrite\n        setting_changed.connect(self._clear_cached_properties)\n\n    @cached_property\n    def base_location(self):\n        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n\n    @cached_property\n    def location(self):\n        return os.path.abspath(self.base_location)\n\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith(\"/\"):\n            self._base_url += \"/\"\n        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n\n    @cached_property\n    def file_permissions_mode(self):\n        return self._value_or_setting(\n            self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS\n        )\n\n    @cached_property\n    def directory_permissions_mode(self):\n        return self._value_or_setting(\n            self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS\n        )\n\n    def _open(self, name, mode=\"rb\"):\n        return File(open(self.path(name), mode))"}, {"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_file_upload_permissions", "type": "codeblock", "score": 5.869889259338379, "line": 1861, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_media_root(self):\n        \"\"\"\n        Overriding the MEDIA_ROOT setting should be reflected in the\n        base_location attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_ROOT=\"test_value\"):\n            self.assertEqual(default_storage.base_location, \"test_value\")\n\n    def test_override_media_url(self):\n        \"\"\"\n        Overriding the MEDIA_URL setting should be reflected in the\n        base_url attribute of django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.base_location, \"\")\n        with self.settings(MEDIA_URL=\"/test_value/\"):\n            self.assertEqual(default_storage.base_url, \"/test_value/\")\n\n    def test_override_file_upload_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n        the file_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n        with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.file_permissions_mode, 0o777)\n\n    def test_override_file_upload_directory_permissions(self):\n        \"\"\"\n        Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n        reflected in the directory_permissions_mode attribute of\n        django.core.files.storage.default_storage.\n        \"\"\"\n        self.assertIsNone(default_storage.directory_permissions_mode)\n        with self.settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777):\n            self.assertEqual(default_storage.directory_permissions_mode, 0o777)\n\n    def test_override_database_routers(self):\n        \"\"\"\n        Overriding DATABASE_ROUTERS should update the base router.\n        \"\"\"\n        test_routers = [object()]\n        with self.settings(DATABASE_ROUTERS=test_routers):\n            self.assertEqual(router.routers, test_routers)\n\n    def test_override_static_url(self):\n        \"\"\"\n        Overriding the STATIC_URL setting should be reflected in the\n        base_url attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_URL=\"/test/\"):\n            self.assertEqual(staticfiles_storage.base_url, \"/test/\")\n\n    def test_override_static_root(self):\n        \"\"\"\n        Overriding the STATIC_ROOT setting should be reflected in the\n        location attribute of\n        django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        with self.settings(STATIC_ROOT=\"/tmp/test\"):\n            self.assertEqual(staticfiles_storage.location, os.path.abspath(\"/tmp/test\"))"}, {"file": "tests/file_storage/tests.py", "name": "FileFieldStorageTests.test_stringio", "type": "codeblock", "score": 5.84661865234375, "line": 979, "text": "class FileFieldStorageTests(TestCase):\n\n    def test_stringio(self):\n        # Test passing StringIO instance as content argument to save\n        output = StringIO()\n        output.write(\"content\")\n        output.seek(0)\n\n        # Save it and read written file\n        temp_storage.save(\"tests/stringio\", output)\n        self.assertTrue(temp_storage.exists(\"tests/stringio\"))\n        with temp_storage.open(\"tests/stringio\") as f:\n            self.assertEqual(f.read(), b\"content\")\n\n    @override_settings(\n        STORAGES={\n            DEFAULT_STORAGE_ALIAS: {\n                \"BACKEND\": \"django.core.files.storage.InMemoryStorage\"\n            }\n        }\n    )\n    def test_create_file_field_from_another_file_field_in_memory_storage(self):\n        f = ContentFile(\"content\", \"file.txt\")\n        obj = Storage.objects.create(storage_callable_default=f)\n        new_obj = Storage.objects.create(\n            storage_callable_default=obj.storage_callable_default.file\n        )\n        storage = callable_default_storage()\n        with storage.open(new_obj.storage_callable_default.name) as f:\n            self.assertEqual(f.read(), b\"content\")"}, {"file": "tests/file_storage/tests.py", "name": "OverwritingStorageTests.test_save_overwrite_behavior_truncate", "type": "codeblock", "score": 5.5977067947387695, "line": 623, "text": "class OverwritingStorageTests(FileStorageTests):\n    storage_class = FileSystemStorage\n\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n        self.storage = self.storage_class(\n            location=self.temp_dir, base_url=\"/test_media_url/\", allow_overwrite=True\n        )\n\n    def test_save_overwrite_behavior(self):\n        \"\"\"Saving to same file name twice overwrites the first file.\"\"\"\n        name = \"test.file\"\n        self.assertFalse(self.storage.exists(name))\n        content_1 = b\"content one\"\n        content_2 = b\"second content\"\n        f_1 = ContentFile(content_1)\n        f_2 = ContentFile(content_2)\n        stored_name_1 = self.storage.save(name, f_1)\n        try:\n            self.assertEqual(stored_name_1, name)\n            self.assertTrue(self.storage.exists(name))\n            with self.storage.open(name) as fp:\n                self.assertEqual(fp.read(), content_1)\n            stored_name_2 = self.storage.save(name, f_2)\n            self.assertEqual(stored_name_2, name)\n            self.assertTrue(self.storage.exists(name))\n            with self.storage.open(name) as fp:\n                self.assertEqual(fp.read(), content_2)\n        finally:\n            self.storage.delete(name)\n\n    def test_save_overwrite_behavior_truncate(self):\n        name = \"test.file\"\n        original_content = b\"content extra extra extra\"\n        new_smaller_content = b\"content\"\n        self.storage.save(name, ContentFile(original_content))\n        try:\n            self.storage.save(name, ContentFile(new_smaller_content))\n            with self.storage.open(name) as fp:\n                self.assertEqual(fp.read(), new_smaller_content)\n        finally:\n            self.storage.delete(name)"}, {"file": "tests/file_storage/tests.py", "name": "FileStorageTests.test_makedirs_race_handling", "type": "codeblock", "score": 5.544200897216797, "line": 458, "text": "class FileStorageTests(SimpleTestCase):\n\n    def test_makedirs_race_handling(self):\n        # ... other code\n\n        try:\n            os.makedirs = fake_makedirs\n\n            self.storage.save(\"normal/test.file\", ContentFile(\"saved normally\"))\n            with self.storage.open(\"normal/test.file\") as f:\n                self.assertEqual(f.read(), b\"saved normally\")\n\n            self.storage.save(\"raced/test.file\", ContentFile(\"saved with race\"))\n            with self.storage.open(\"raced/test.file\") as f:\n                self.assertEqual(f.read(), b\"saved with race\")\n\n            # Exceptions aside from FileExistsError are raised.\n            with self.assertRaises(PermissionError):\n                self.storage.save(\"error/test.file\", ContentFile(\"not saved\"))\n        finally:\n            os.makedirs = real_makedirs"}, {"file": "tests/model_fields/storage.py", "name": "imports", "type": "codeblock", "score": 5.358566761016846, "line": 1, "text": "from django.core.files.storage.filesystem import FileSystemStorage\n\n\nclass NoReadFileSystemStorage(FileSystemStorage):\n    def open(self, *args, **kwargs):\n        raise AssertionError(\"This storage class does not support reading.\")"}, {"file": "tests/file_storage/tests.py", "name": "FileLikeObjectTestCase.test_urllib_request_urlopen", "type": "codeblock", "score": 5.334725379943848, "line": 1197, "text": "@override_settings(ROOT_URLCONF=\"file_storage.urls\")\nclass FileLikeObjectTestCase(LiveServerTestCase):\n    \"\"\"\n    Test file-like objects (#15644).\n    \"\"\"\n\n    available_apps = []\n\n    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, self.temp_dir)\n        self.storage = FileSystemStorage(location=self.temp_dir)\n\n    def test_urllib_request_urlopen(self):\n        \"\"\"\n        Test the File storage API with a file-like object coming from\n        urllib.request.urlopen().\n        \"\"\"\n        file_like_object = urlopen(self.live_server_url + \"/\")\n        f = File(file_like_object)\n        stored_filename = self.storage.save(\"remote_file.html\", f)\n\n        remote_file = urlopen(self.live_server_url + \"/\")\n        with self.storage.open(stored_filename) as stored_file:\n            self.assertEqual(stored_file.read(), remote_file.read())"}], "total_results": 10}
{"repo": "django", "query": "docs mention chmod on uploaded files", "top_10": [{"file": "django/conf/global_settings.py", "name": "impl:107", "type": "codeblock", "score": 10.65800666809082, "line": 300, "text": "FILE_UPLOAD_HANDLERS = [\n    \"django.core.files.uploadhandler.MemoryFileUploadHandler\",\n    \"django.core.files.uploadhandler.TemporaryFileUploadHandler\",\n]\n\n# Maximum size, in bytes, of a request before it will be streamed to the\n# file system instead of into memory.\nFILE_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum size in bytes of request data (excluding file uploads) that will be\n# read before a SuspiciousOperation (RequestDataTooBig) is raised.\nDATA_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB\n\n# Maximum number of GET/POST parameters that will be read before a\n# SuspiciousOperation (TooManyFieldsSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FIELDS = 1000\n\n# Maximum number of files encoded in a multipart upload that will be read\n# before a SuspiciousOperation (TooManyFilesSent) is raised.\nDATA_UPLOAD_MAX_NUMBER_FILES = 100\n\n# Directory in which upload streamed files will be temporarily saved. A value\n# of `None` will make Django use the operating system's default temporary\n# directory (i.e. \"/tmp\" on *nix systems).\nFILE_UPLOAD_TEMP_DIR = None\n\n# The numeric mode to set newly-uploaded files to. The value should be a mode\n# you'd pass directly to os.chmod; see\n# https://docs.python.org/library/os.html#files-and-directories.\nFILE_UPLOAD_PERMISSIONS = 0o644\n\n# The numeric mode to assign to newly-created directories, when uploading\n# files. The value should be a mode as you'd pass to os.chmod; see\n# https://docs.python.org/library/os.html#files-and-directories.\nFILE_UPLOAD_DIRECTORY_PERMISSIONS = None\n\n# Python module path where user will place custom format definition.\n# The directory where this setting is pointing should contain subdirectories\n# named as the locales, containing a formats.py file\n# (i.e. \"myproject.locale\" for myproject/locale/en/formats.py etc. use)\nFORMAT_MODULE_PATH = None\n\n# Default formatting for date objects. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATE_FORMAT = \"N j, Y\"\n\n# Default formatting for datetime objects. See all available format strings\n# here: https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nDATETIME_FORMAT = \"N j, Y, P\"\n\n# Default formatting for time objects. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date\nTIME_FORMAT = \"P\"\n\n# Default formatting for date objects when only the year and month are\n# relevant. See all available format strings here:\n# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date"}, {"file": "tests/model_forms/tests.py", "name": "FileAndImageFieldTests.test_render_empty_file_field", "type": "codeblock", "score": 6.735569477081299, "line": 2540, "text": "class FileAndImageFieldTests(TestCase):\n\n    def test_clear_and_file_contradiction(self):\n        \"\"\"\n        If the user submits a new file upload AND checks the clear checkbox,\n        they get a validation error, and the bound redisplay of the form still\n        includes the current file and the clear checkbox.\n        \"\"\"\n\n        class DocumentForm(forms.ModelForm):\n            class Meta:\n                model = Document\n                fields = \"__all__\"\n\n        form = DocumentForm(\n            files={\"myfile\": SimpleUploadedFile(\"something.txt\", b\"content\")}\n        )\n        self.assertTrue(form.is_valid())\n        doc = form.save(commit=False)\n        form = DocumentForm(\n            instance=doc,\n            files={\"myfile\": SimpleUploadedFile(\"something.txt\", b\"content\")},\n            data={\"myfile-clear\": \"true\"},\n        )\n        self.assertTrue(not form.is_valid())\n        self.assertEqual(\n            form.errors[\"myfile\"],\n            [\"Please either submit a file or check the clear checkbox, not both.\"],\n        )\n        rendered = str(form)\n        self.assertIn(\"something.txt\", rendered)\n        self.assertIn(\"myfile-clear\", rendered)\n\n    def test_render_empty_file_field(self):\n        class DocumentForm(forms.ModelForm):\n            class Meta:\n                model = Document\n                fields = \"__all__\"\n\n        doc = Document.objects.create()\n        form = DocumentForm(instance=doc)\n        self.assertHTMLEqual(\n            str(form[\"myfile\"]), '<input id=\"id_myfile\" name=\"myfile\" type=\"file\">'\n        )"}, {"file": "django/forms/widgets.py", "name": "ClearableFileInput.value_omitted_from_data", "type": "codeblock", "score": 6.215252876281738, "line": 579, "text": "class ClearableFileInput(FileInput):\n\n    def value_from_datadict(self, data, files, name):\n        upload = super().value_from_datadict(data, files, name)\n        self.checked = self.clear_checkbox_name(name) in data\n        if not self.is_required and CheckboxInput().value_from_datadict(\n            data, files, self.clear_checkbox_name(name)\n        ):\n            if upload:\n                # If the user contradicts themselves (uploads a new file AND\n                # checks the \"clear\" checkbox), we return a unique marker\n                # object that FileField will turn into a ValidationError.\n                return FILE_INPUT_CONTRADICTION\n            # False signals to clear any existing value, as opposed to just\n            # None\n            return False\n        return upload\n\n    def value_omitted_from_data(self, data, files, name):\n        return (\n            super().value_omitted_from_data(data, files, name)\n            and self.clear_checkbox_name(name) not in data\n        )"}, {"file": "django/core/files/uploadhandler.py", "name": "StopUpload.__init__", "type": "codeblock", "score": 6.136866569519043, "line": 32, "text": "class StopUpload(UploadFileException):\n    \"\"\"\n    This exception is raised when an upload must abort.\n    \"\"\"\n\n    def __init__(self, connection_reset=False):\n        \"\"\"\n        If ``connection_reset`` is ``True``, Django knows will halt the upload\n        without consuming the rest of the upload. This will cause the browser\n        to show a \"connection reset\" error.\n        \"\"\"\n        self.connection_reset = connection_reset\n\n    def __str__(self):\n        if self.connection_reset:\n            return \"StopUpload: Halt current upload.\"\n        else:\n            return \"StopUpload: Consume request data, then halt.\"\n\n\nclass SkipFile(UploadFileException):\n    \"\"\"\n    This exception is raised by an upload handler that wants to skip a given\n    file.\n    \"\"\"\n\n    pass\n\n\nclass StopFutureHandlers(UploadFileException):\n    \"\"\"\n    Upload handlers that have handled a file and do not want future handlers to\n    run should raise this exception instead of returning None.\n    \"\"\"\n\n    pass"}, {"file": "tests/file_uploads/tests.py", "name": "DirectoryCreationTests.test_readonly_root", "type": "codeblock", "score": 5.838391304016113, "line": 852, "text": "@override_settings(MEDIA_ROOT=MEDIA_ROOT)\nclass DirectoryCreationTests(SimpleTestCase):\n    \"\"\"\n    Tests for error handling during directory creation\n    via _save_FIELD_file (ticket #6450)\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        os.makedirs(MEDIA_ROOT, exist_ok=True)\n        cls.addClassCleanup(shutil.rmtree, MEDIA_ROOT)\n\n    def setUp(self):\n        self.obj = FileModel()\n\n    @unittest.skipIf(\n        sys.platform == \"win32\", \"Python on Windows doesn't have working os.chmod().\"\n    )\n    @override_settings(\n        STORAGES={\n            DEFAULT_STORAGE_ALIAS: {\n                \"BACKEND\": \"django.core.files.storage.FileSystemStorage\",\n            }\n        }\n    )\n    def test_readonly_root(self):\n        \"\"\"Permission errors are not swallowed\"\"\"\n        os.chmod(MEDIA_ROOT, 0o500)\n        self.addCleanup(os.chmod, MEDIA_ROOT, 0o700)\n        with self.assertRaises(PermissionError):\n            self.obj.testfile.save(\n                \"foo.txt\", SimpleUploadedFile(\"foo.txt\", b\"x\"), save=False\n            )"}, {"file": "django/core/files/uploadhandler.py", "name": "UploadFileException", "type": "codeblock", "score": 5.679318428039551, "line": 1, "text": "\"\"\"\nBase file upload handler classes, and the built-in concrete subclasses\n\"\"\"\n\nimport os\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile\nfrom django.utils.module_loading import import_string\n\n__all__ = [\n    \"UploadFileException\",\n    \"StopUpload\",\n    \"SkipFile\",\n    \"FileUploadHandler\",\n    \"TemporaryFileUploadHandler\",\n    \"MemoryFileUploadHandler\",\n    \"load_handler\",\n    \"StopFutureHandlers\",\n]\n\n\nclass UploadFileException(Exception):\n    \"\"\"\n    Any error having to do with uploading files.\n    \"\"\"\n\n    pass"}, {"file": "django/core/files/uploadhandler.py", "name": "FileUploadHandler.file_complete", "type": "codeblock", "score": 5.653627872467041, "line": 127, "text": "class FileUploadHandler:\n\n    def receive_data_chunk(self, raw_data, start):\n        \"\"\"\n        Receive data from the streamed upload parser. ``start`` is the position\n        in the file of the chunk.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of FileUploadHandler must provide a receive_data_chunk() method\"\n        )\n\n    def file_complete(self, file_size):\n        \"\"\"\n        Signal that a file has completed. File size corresponds to the actual\n        size accumulated by all the chunks.\n\n        Subclasses should return a valid ``UploadedFile`` object.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of FileUploadHandler must provide a file_complete() method\"\n        )\n\n    def upload_complete(self):\n        \"\"\"\n        Signal that the upload is complete. Subclasses should perform cleanup\n        that is necessary for this handler.\n        \"\"\"\n        pass\n\n    def upload_interrupted(self):\n        \"\"\"\n        Signal that the upload was interrupted. Subclasses should perform\n        cleanup that is necessary for this handler.\n        \"\"\"\n        pass"}, {"file": "django/core/files/uploadedfile.py", "name": "TemporaryUploadedFile.__init__", "type": "codeblock", "score": 5.593507766723633, "line": 71, "text": "class TemporaryUploadedFile(UploadedFile):\n    \"\"\"\n    A file uploaded to a temporary location (i.e. stream-to-disk).\n    \"\"\"\n\n    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n        _, ext = os.path.splitext(name)\n        file = tempfile.NamedTemporaryFile(\n            suffix=\".upload\" + ext, dir=settings.FILE_UPLOAD_TEMP_DIR\n        )\n        super().__init__(file, name, content_type, size, charset, content_type_extra)\n\n    def temporary_file_path(self):\n        \"\"\"Return the full path of this file.\"\"\"\n        return self.file.name\n\n    def close(self):\n        try:\n            return self.file.close()\n        except FileNotFoundError:\n            # The file was moved or deleted before the tempfile could unlink\n            # it. Still sets self.file.close_called and calls\n            # self.file.file.close() before the exception.\n            pass"}, {"file": "django/http/multipartparser.py", "name": "MultiPartParserError", "type": "codeblock", "score": 5.587308883666992, "line": 1, "text": "\"\"\"\nMulti-part parsing for file uploads.\n\nExposes one class, ``MultiPartParser``, which feeds chunks of uploaded data to\nfile upload handlers for processing.\n\"\"\"\n\nimport base64\nimport binascii\nimport collections\nimport html\n\nfrom django.conf import settings\nfrom django.core.exceptions import (\n    RequestDataTooBig,\n    SuspiciousMultipartForm,\n    TooManyFieldsSent,\n    TooManyFilesSent,\n)\nfrom django.core.files.uploadhandler import SkipFile, StopFutureHandlers, StopUpload\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\n\n__all__ = (\"MultiPartParser\", \"MultiPartParserError\", \"InputStreamExhausted\")\n\n\nclass MultiPartParserError(Exception):\n    pass\n\n\nclass InputStreamExhausted(Exception):\n    \"\"\"\n    No more reads are allowed from this device.\n    \"\"\"\n\n    pass\n\n\nRAW = \"raw\"\nFILE = \"file\"\nFIELD = \"field\"\nFIELD_TYPES = frozenset([FIELD, RAW])\nMAX_TOTAL_HEADER_SIZE = 1024"}, {"file": "tests/admin_widgets/tests.py", "name": "ImageFieldWidgetsSeleniumTests.test_clearablefileinput_widget_invalid_file", "type": "codeblock", "score": 5.5495524406433105, "line": 2027, "text": "@skipUnless(Image, \"Pillow not installed\")\nclass ImageFieldWidgetsSeleniumTests(AdminWidgetSeleniumTestCase):\n\n    def test_clearablefileinput_widget_invalid_file(self):\n        from selenium.webdriver.common.by import By\n\n        self._run_image_upload_path()\n        # Uploading non-image files is not supported by Safari with Selenium,\n        # so upload a broken one instead.\n        photo_input = self.selenium.find_element(By.ID, self.photo_input_id)\n        photo_input.send_keys(f\"{self.tests_files_folder}/brokenimg.png\")\n        self._submit_and_wait()\n        self.assertEqual(\n            self.selenium.find_element(By.CSS_SELECTOR, \".errorlist li\").text,\n            (\n                \"Upload a valid image. The file you uploaded was either not an image \"\n                \"or a corrupted image.\"\n            ),\n        )\n        # \"Currently\" with \"Clear\" checkbox and \"Change\" still shown.\n        photo_field_row = self.selenium.find_element(By.CSS_SELECTOR, \".field-photo\")\n        self.assertIn(\"Currently\", photo_field_row.text)\n        self.assertIn(\"Change\", photo_field_row.text)"}], "total_results": 10}
{"repo": "django", "query": "staticfiles storage permissions discussion", "top_10": [{"file": "django/contrib/staticfiles/checks.py", "name": "imports", "type": "codeblock", "score": 6.944634437561035, "line": 1, "text": "from django.conf import STATICFILES_STORAGE_ALIAS, settings\nfrom django.contrib.staticfiles.finders import get_finders\nfrom django.core.checks import Error\n\nE005 = Error(\n    f\"The STORAGES setting must define a '{STATICFILES_STORAGE_ALIAS}' storage.\",\n    id=\"staticfiles.E005\",\n)\n\n\ndef check_finders(app_configs, **kwargs):\n    \"\"\"Check all registered staticfiles finders.\"\"\"\n    errors = []\n    for finder in get_finders():\n        try:\n            finder_errors = finder.check()\n        except NotImplementedError:\n            pass\n        else:\n            errors.extend(finder_errors)\n    return errors\n\n\ndef check_storages(app_configs, **kwargs):\n    \"\"\"Ensure staticfiles is defined in STORAGES setting.\"\"\"\n    errors = []\n    if STATICFILES_STORAGE_ALIAS not in settings.STORAGES:\n        errors.append(E005)\n    return errors"}, {"file": "django/contrib/staticfiles/finders.py", "name": "DefaultStorageFinder.__init__", "type": "codeblock", "score": 6.596083641052246, "line": 259, "text": "class DefaultStorageFinder(BaseStorageFinder):\n    \"\"\"\n    A static files finder that uses the default storage backend.\n    \"\"\"\n\n    storage = default_storage\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        base_location = getattr(self.storage, \"base_location\", empty)\n        if not base_location:\n            raise ImproperlyConfigured(\n                \"The storage backend of the \"\n                \"staticfiles finder %r doesn't have \"\n                \"a valid location.\" % self.__class__\n            )"}, {"file": "tests/test_utils/tests.py", "name": "OverrideSettingsTests.test_override_staticfiles_storage", "type": "codeblock", "score": 6.562707901000977, "line": 1925, "text": "class OverrideSettingsTests(SimpleTestCase):\n    # #21518 -- If neither override_settings nor a setting_changed receiver\n    # clears the URL cache between tests, then one of test_first or\n\n    def test_override_staticfiles_storage(self):\n        \"\"\"\n        Overriding the STORAGES setting should be reflected in\n        the value of django.contrib.staticfiles.storage.staticfiles_storage.\n        \"\"\"\n        new_class = \"ManifestStaticFilesStorage\"\n        new_storage = \"django.contrib.staticfiles.storage.\" + new_class\n        with self.settings(\n            STORAGES={STATICFILES_STORAGE_ALIAS: {\"BACKEND\": new_storage}}\n        ):\n            self.assertEqual(staticfiles_storage.__class__.__name__, new_class)\n\n    def test_override_staticfiles_finders(self):\n        \"\"\"\n        Overriding the STATICFILES_FINDERS setting should be reflected in\n        the return value of django.contrib.staticfiles.finders.get_finders.\n        \"\"\"\n        current = get_finders()\n        self.assertGreater(len(list(current)), 1)\n        finders = [\"django.contrib.staticfiles.finders.FileSystemFinder\"]\n        with self.settings(STATICFILES_FINDERS=finders):\n            self.assertEqual(len(list(get_finders())), len(finders))"}, {"file": "django/contrib/staticfiles/finders.py", "name": "BaseStorageFinder.__init__", "type": "codeblock", "score": 6.255331039428711, "line": 211, "text": "class BaseStorageFinder(BaseFinder):\n    \"\"\"\n    A base static files finder to be used to extended\n    with an own storage class.\n    \"\"\"\n\n    storage = None\n\n    def __init__(self, storage=None, *args, **kwargs):\n        if storage is not None:\n            self.storage = storage\n        if self.storage is None:\n            raise ImproperlyConfigured(\n                \"The staticfiles storage finder %r \"\n                \"doesn't have a storage class \"\n                \"assigned.\" % self.__class__\n            )\n        # Make sure we have a storage instance here.\n        if not isinstance(self.storage, (Storage, LazyObject)):\n            self.storage = self.storage()\n        super().__init__(*args, **kwargs)\n\n    def find(self, path, find_all=False):\n        \"\"\"\n        Look for files in the default file storage, if it's local.\n        \"\"\"\n        try:\n            self.storage.path(\"\")\n        except NotImplementedError:\n            pass\n        else:\n            if self.storage.location not in searched_locations:\n                searched_locations.append(self.storage.location)\n            if self.storage.exists(path):\n                match = self.storage.path(path)\n                if find_all:\n                    match = [match]\n                return match\n        return []\n\n    def list(self, ignore_patterns):\n        \"\"\"\n        List all files of the storage.\n        \"\"\"\n        for path in utils.get_files(self.storage, ignore_patterns):\n            yield path, self.storage"}, {"file": "django/contrib/staticfiles/management/commands/collectstatic.py", "name": "imports", "type": "codeblock", "score": 6.187744140625, "line": 1, "text": "import os\n\nfrom django.apps import apps\nfrom django.contrib.staticfiles.finders import get_finders\nfrom django.contrib.staticfiles.storage import staticfiles_storage\nfrom django.core.checks import Tags\nfrom django.core.files.storage import FileSystemStorage\nfrom django.core.management.base import BaseCommand, CommandError\nfrom django.core.management.color import no_style\nfrom django.utils.functional import cached_property\n\n\nclass Command(BaseCommand):\n    \"\"\"\n    Copies or symlinks static files from different locations to the\n    settings.STATIC_ROOT.\n    \"\"\"\n\n    help = \"Collect static files in a single location.\"\n    requires_system_checks = [Tags.staticfiles]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.copied_files = []\n        self.symlinked_files = []\n        self.unmodified_files = []\n        self.post_processed_files = []\n        self.skipped_files = []\n        self.deleted_files = []\n        self.storage = staticfiles_storage\n        self.style = no_style()\n\n    @cached_property\n    def local(self):\n        try:\n            self.storage.path(\"\")\n        except NotImplementedError:\n            return False\n        return True"}, {"file": "django/contrib/staticfiles/storage.py", "name": "imports", "type": "codeblock", "score": 5.607397079467773, "line": 1, "text": "import json\nimport os\nimport posixpath\nimport re\nfrom hashlib import md5\nfrom urllib.parse import unquote, urldefrag, urlsplit, urlunsplit\n\nfrom django.conf import STATICFILES_STORAGE_ALIAS, settings\nfrom django.contrib.staticfiles.utils import check_settings, matches_patterns\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import FileSystemStorage, storages\nfrom django.utils.functional import LazyObject\n\n\nclass StaticFilesStorage(FileSystemStorage):\n    \"\"\"\n    Standard file system storage for static files.\n\n    The defaults for ``location`` and ``base_url`` are\n    ``STATIC_ROOT`` and ``STATIC_URL``.\n    \"\"\"\n\n    def __init__(self, location=None, base_url=None, *args, **kwargs):\n        if location is None:\n            location = settings.STATIC_ROOT\n        if base_url is None:\n            base_url = settings.STATIC_URL\n        check_settings(base_url)\n        super().__init__(location, base_url, *args, **kwargs)\n        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n        # is empty, so we restore the empty value.\n        if not location:\n            self.base_location = None\n            self.location = None\n\n    def path(self, name):\n        if not self.location:\n            raise ImproperlyConfigured(\n                \"You're using the staticfiles app \"\n                \"without having set the STATIC_ROOT \"\n                \"setting to a filesystem path.\"\n            )\n        return super().path(name)"}, {"file": "django/contrib/staticfiles/finders.py", "name": "imports", "type": "codeblock", "score": 5.5936784744262695, "line": 1, "text": "import functools\nimport os\n\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.contrib.staticfiles import utils\nfrom django.core.checks import Error, Warning\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.files.storage import FileSystemStorage, Storage, default_storage\nfrom django.utils._os import safe_join\nfrom django.utils.functional import LazyObject, empty\nfrom django.utils.module_loading import import_string\n\n# To keep track on which directories the finder has searched the static files.\nsearched_locations = []\n\n\nclass BaseFinder:\n    \"\"\"\n    A base file finder to be used for custom staticfiles finder classes.\n    \"\"\"\n\n    def check(self, **kwargs):\n        raise NotImplementedError(\n            \"subclasses may provide a check() method to verify the finder is \"\n            \"configured correctly.\"\n        )\n\n    def list(self, ignore_patterns):\n        \"\"\"\n        Given an optional list of paths to ignore, return a two item iterable\n        consisting of the relative path and storage instance.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of BaseFinder must provide a list() method\"\n        )"}, {"file": "tests/staticfiles_tests/storage.py", "name": "DummyStorage._save", "type": "codeblock", "score": 5.528886318206787, "line": 1, "text": "import os\nfrom datetime import UTC, datetime, timedelta\n\nfrom django.conf import settings\nfrom django.contrib.staticfiles.storage import ManifestStaticFilesStorage\nfrom django.core.files import storage\n\n\nclass DummyStorage(storage.Storage):\n    \"\"\"\n    A storage class that implements get_modified_time() but raises\n    NotImplementedError for path().\n    \"\"\"\n\n    def _save(self, name, content):\n        return \"dummy\"\n\n    def delete(self, name):\n        pass\n\n    def exists(self, name):\n        pass\n\n    def get_modified_time(self, name):\n        return datetime(1970, 1, 1, tzinfo=UTC)"}, {"file": "django/contrib/staticfiles/storage.py", "name": "ManifestStaticFilesStorage", "type": "codeblock", "score": 5.369248390197754, "line": 517, "text": "class ManifestFilesMixin(HashedFilesMixin):\n\n    def stored_name(self, name):\n        parsed_name = urlsplit(unquote(name))\n        clean_name = parsed_name.path.strip()\n        hash_key = self.hash_key(clean_name)\n        cache_name = self.hashed_files.get(hash_key)\n        if cache_name is None:\n            if self.manifest_strict:\n                raise ValueError(\n                    \"Missing staticfiles manifest entry for '%s'\" % clean_name\n                )\n            cache_name = self.clean_name(self.hashed_name(name))\n        unparsed_name = list(parsed_name)\n        unparsed_name[2] = cache_name\n        # Special casing for a @font-face hack, like url(myfont.eot?#iefix\")\n        # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax\n        if \"?#\" in name and not unparsed_name[3]:\n            unparsed_name[2] += \"?\"\n        return urlunsplit(unparsed_name)\n\n\nclass ManifestStaticFilesStorage(ManifestFilesMixin, StaticFilesStorage):\n    \"\"\"\n    A static file system storage backend which also saves\n    hashed copies of the files it saves.\n    \"\"\"\n\n    pass\n\n\nclass ConfiguredStorage(LazyObject):\n    def _setup(self):\n        self._wrapped = storages[STATICFILES_STORAGE_ALIAS]\n\n\nstaticfiles_storage = ConfiguredStorage()"}, {"file": "tests/file_storage/tests.py", "name": "StorageHandlerTests.test_nonexistent_alias", "type": "codeblock", "score": 5.2840447425842285, "line": 1224, "text": "class StorageHandlerTests(SimpleTestCase):\n    @override_settings(\n        STORAGES={\n            \"custom_storage\": {\n                \"BACKEND\": \"django.core.files.storage.FileSystemStorage\",\n            },\n        }\n    )\n    def test_same_instance(self):\n        cache1 = storages[\"custom_storage\"]\n        cache2 = storages[\"custom_storage\"]\n        self.assertIs(cache1, cache2)\n\n    def test_defaults(self):\n        storages = StorageHandler()\n        self.assertEqual(\n            storages.backends,\n            {\n                DEFAULT_STORAGE_ALIAS: {\n                    \"BACKEND\": \"django.core.files.storage.FileSystemStorage\",\n                },\n                STATICFILES_STORAGE_ALIAS: {\n                    \"BACKEND\": \"django.contrib.staticfiles.storage.StaticFilesStorage\",\n                },\n            },\n        )\n\n    def test_nonexistent_alias(self):\n        msg = \"Could not find config for 'nonexistent' in settings.STORAGES.\"\n        storages = StorageHandler()\n        with self.assertRaisesMessage(InvalidStorageError, msg):\n            storages[\"nonexistent\"]\n\n    def test_nonexistent_backend(self):\n        test_storages = StorageHandler(\n            {\n                \"invalid_backend\": {\n                    \"BACKEND\": \"django.nonexistent.NonexistentBackend\",\n                },\n            }\n        )\n        msg = (\n            \"Could not find backend 'django.nonexistent.NonexistentBackend': \"\n            \"No module named 'django.nonexistent'\"\n        )\n        with self.assertRaisesMessage(InvalidStorageError, msg):\n            test_storages[\"invalid_backend\"]\n\n\nclass StorageLazyObjectTests(SimpleTestCase):\n    def test_lazy_object_is_not_evaluated_before_manual_access(self):\n        obj = Storage()\n        self.assertIs(obj.lazy_storage.storage._wrapped, empty)\n        # assertEqual triggers resolution.\n        self.assertEqual(obj.lazy_storage.storage, temp_storage)"}], "total_results": 10}
{"repo": "django", "query": "file upload security permissions", "top_10": [{"file": "django/forms/widgets.py", "name": "ClearableFileInput.value_omitted_from_data", "type": "codeblock", "score": 6.215252876281738, "line": 579, "text": "class ClearableFileInput(FileInput):\n\n    def value_from_datadict(self, data, files, name):\n        upload = super().value_from_datadict(data, files, name)\n        self.checked = self.clear_checkbox_name(name) in data\n        if not self.is_required and CheckboxInput().value_from_datadict(\n            data, files, self.clear_checkbox_name(name)\n        ):\n            if upload:\n                # If the user contradicts themselves (uploads a new file AND\n                # checks the \"clear\" checkbox), we return a unique marker\n                # object that FileField will turn into a ValidationError.\n                return FILE_INPUT_CONTRADICTION\n            # False signals to clear any existing value, as opposed to just\n            # None\n            return False\n        return upload\n\n    def value_omitted_from_data(self, data, files, name):\n        return (\n            super().value_omitted_from_data(data, files, name)\n            and self.clear_checkbox_name(name) not in data\n        )"}, {"file": "django/core/files/uploadhandler.py", "name": "StopUpload.__init__", "type": "codeblock", "score": 6.136866569519043, "line": 32, "text": "class StopUpload(UploadFileException):\n    \"\"\"\n    This exception is raised when an upload must abort.\n    \"\"\"\n\n    def __init__(self, connection_reset=False):\n        \"\"\"\n        If ``connection_reset`` is ``True``, Django knows will halt the upload\n        without consuming the rest of the upload. This will cause the browser\n        to show a \"connection reset\" error.\n        \"\"\"\n        self.connection_reset = connection_reset\n\n    def __str__(self):\n        if self.connection_reset:\n            return \"StopUpload: Halt current upload.\"\n        else:\n            return \"StopUpload: Consume request data, then halt.\"\n\n\nclass SkipFile(UploadFileException):\n    \"\"\"\n    This exception is raised by an upload handler that wants to skip a given\n    file.\n    \"\"\"\n\n    pass\n\n\nclass StopFutureHandlers(UploadFileException):\n    \"\"\"\n    Upload handlers that have handled a file and do not want future handlers to\n    run should raise this exception instead of returning None.\n    \"\"\"\n\n    pass"}, {"file": "django/core/files/uploadhandler.py", "name": "UploadFileException", "type": "codeblock", "score": 5.679318428039551, "line": 1, "text": "\"\"\"\nBase file upload handler classes, and the built-in concrete subclasses\n\"\"\"\n\nimport os\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile\nfrom django.utils.module_loading import import_string\n\n__all__ = [\n    \"UploadFileException\",\n    \"StopUpload\",\n    \"SkipFile\",\n    \"FileUploadHandler\",\n    \"TemporaryFileUploadHandler\",\n    \"MemoryFileUploadHandler\",\n    \"load_handler\",\n    \"StopFutureHandlers\",\n]\n\n\nclass UploadFileException(Exception):\n    \"\"\"\n    Any error having to do with uploading files.\n    \"\"\"\n\n    pass"}, {"file": "django/core/files/uploadhandler.py", "name": "FileUploadHandler.file_complete", "type": "codeblock", "score": 5.653627872467041, "line": 127, "text": "class FileUploadHandler:\n\n    def receive_data_chunk(self, raw_data, start):\n        \"\"\"\n        Receive data from the streamed upload parser. ``start`` is the position\n        in the file of the chunk.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of FileUploadHandler must provide a receive_data_chunk() method\"\n        )\n\n    def file_complete(self, file_size):\n        \"\"\"\n        Signal that a file has completed. File size corresponds to the actual\n        size accumulated by all the chunks.\n\n        Subclasses should return a valid ``UploadedFile`` object.\n        \"\"\"\n        raise NotImplementedError(\n            \"subclasses of FileUploadHandler must provide a file_complete() method\"\n        )\n\n    def upload_complete(self):\n        \"\"\"\n        Signal that the upload is complete. Subclasses should perform cleanup\n        that is necessary for this handler.\n        \"\"\"\n        pass\n\n    def upload_interrupted(self):\n        \"\"\"\n        Signal that the upload was interrupted. Subclasses should perform\n        cleanup that is necessary for this handler.\n        \"\"\"\n        pass"}, {"file": "django/core/files/uploadedfile.py", "name": "TemporaryUploadedFile.__init__", "type": "codeblock", "score": 5.593507766723633, "line": 71, "text": "class TemporaryUploadedFile(UploadedFile):\n    \"\"\"\n    A file uploaded to a temporary location (i.e. stream-to-disk).\n    \"\"\"\n\n    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n        _, ext = os.path.splitext(name)\n        file = tempfile.NamedTemporaryFile(\n            suffix=\".upload\" + ext, dir=settings.FILE_UPLOAD_TEMP_DIR\n        )\n        super().__init__(file, name, content_type, size, charset, content_type_extra)\n\n    def temporary_file_path(self):\n        \"\"\"Return the full path of this file.\"\"\"\n        return self.file.name\n\n    def close(self):\n        try:\n            return self.file.close()\n        except FileNotFoundError:\n            # The file was moved or deleted before the tempfile could unlink\n            # it. Still sets self.file.close_called and calls\n            # self.file.file.close() before the exception.\n            pass"}, {"file": "django/http/multipartparser.py", "name": "MultiPartParserError", "type": "codeblock", "score": 5.587308883666992, "line": 1, "text": "\"\"\"\nMulti-part parsing for file uploads.\n\nExposes one class, ``MultiPartParser``, which feeds chunks of uploaded data to\nfile upload handlers for processing.\n\"\"\"\n\nimport base64\nimport binascii\nimport collections\nimport html\n\nfrom django.conf import settings\nfrom django.core.exceptions import (\n    RequestDataTooBig,\n    SuspiciousMultipartForm,\n    TooManyFieldsSent,\n    TooManyFilesSent,\n)\nfrom django.core.files.uploadhandler import SkipFile, StopFutureHandlers, StopUpload\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\n\n__all__ = (\"MultiPartParser\", \"MultiPartParserError\", \"InputStreamExhausted\")\n\n\nclass MultiPartParserError(Exception):\n    pass\n\n\nclass InputStreamExhausted(Exception):\n    \"\"\"\n    No more reads are allowed from this device.\n    \"\"\"\n\n    pass\n\n\nRAW = \"raw\"\nFILE = \"file\"\nFIELD = \"field\"\nFIELD_TYPES = frozenset([FIELD, RAW])\nMAX_TOTAL_HEADER_SIZE = 1024"}, {"file": "tests/admin_widgets/tests.py", "name": "ImageFieldWidgetsSeleniumTests.test_clearablefileinput_widget_invalid_file", "type": "codeblock", "score": 5.5495524406433105, "line": 2027, "text": "@skipUnless(Image, \"Pillow not installed\")\nclass ImageFieldWidgetsSeleniumTests(AdminWidgetSeleniumTestCase):\n\n    def test_clearablefileinput_widget_invalid_file(self):\n        from selenium.webdriver.common.by import By\n\n        self._run_image_upload_path()\n        # Uploading non-image files is not supported by Safari with Selenium,\n        # so upload a broken one instead.\n        photo_input = self.selenium.find_element(By.ID, self.photo_input_id)\n        photo_input.send_keys(f\"{self.tests_files_folder}/brokenimg.png\")\n        self._submit_and_wait()\n        self.assertEqual(\n            self.selenium.find_element(By.CSS_SELECTOR, \".errorlist li\").text,\n            (\n                \"Upload a valid image. The file you uploaded was either not an image \"\n                \"or a corrupted image.\"\n            ),\n        )\n        # \"Currently\" with \"Clear\" checkbox and \"Change\" still shown.\n        photo_field_row = self.selenium.find_element(By.CSS_SELECTOR, \".field-photo\")\n        self.assertIn(\"Currently\", photo_field_row.text)\n        self.assertIn(\"Change\", photo_field_row.text)"}, {"file": "tests/file_uploads/tests.py", "name": "FileUploadTests.test_filename_case_preservation", "type": "codeblock", "score": 5.544519424438477, "line": 779, "text": "@override_settings(\n    MEDIA_ROOT=MEDIA_ROOT, ROOT_URLCONF=\"file_uploads.urls\", MIDDLEWARE=[]\n)\nclass FileUploadTests(TestCase):\n\n    def test_filename_case_preservation(self):\n        \"\"\"\n        The storage backend shouldn't mess with the case of the filenames\n        uploaded.\n        \"\"\"\n        # Synthesize the contents of a file upload with a mixed case filename\n        # so we don't have to carry such a file in the Django tests source code\n        # tree.\n        vars = {\"boundary\": \"oUrBoUnDaRyStRiNg\"}\n        post_data = [\n            \"--%(boundary)s\",\n            'Content-Disposition: form-data; name=\"file_field\"; '\n            'filename=\"MiXeD_cAsE.txt\"',\n            \"Content-Type: application/octet-stream\",\n            \"\",\n            \"file contents\\n\",\n            \"--%(boundary)s--\\r\\n\",\n        ]\n        response = self.client.post(\n            \"/filename_case/\",\n            \"\\r\\n\".join(post_data) % vars,\n            \"multipart/form-data; boundary=%(boundary)s\" % vars,\n        )\n        self.assertEqual(response.status_code, 200)\n        id = int(response.content)\n        obj = FileModel.objects.get(pk=id)\n        # The name of the file uploaded and the file stored in the server-side\n        # shouldn't differ.\n        self.assertEqual(os.path.basename(obj.testfile.path), \"MiXeD_cAsE.txt\")"}, {"file": "tests/file_uploads/tests.py", "name": "FileUploadTests.test_stop_upload_temporary_file_handler", "type": "codeblock", "score": 5.4871134757995605, "line": 573, "text": "@override_settings(\n    MEDIA_ROOT=MEDIA_ROOT, ROOT_URLCONF=\"file_uploads.urls\", MIDDLEWARE=[]\n)\nclass FileUploadTests(TestCase):\n\n    def test_broken_custom_upload_handler(self):\n        with tempfile.NamedTemporaryFile() as file:\n            file.write(b\"a\" * (2**21))\n            file.seek(0)\n\n            msg = (\n                \"You cannot alter upload handlers after the upload has been processed.\"\n            )\n            with self.assertRaisesMessage(AttributeError, msg):\n                self.client.post(\"/quota/broken/\", {\"f\": file})\n\n    def test_stop_upload_temporary_file_handler(self):\n        with tempfile.NamedTemporaryFile() as temp_file:\n            temp_file.write(b\"a\")\n            temp_file.seek(0)\n            response = self.client.post(\"/temp_file/stop_upload/\", {\"file\": temp_file})\n            temp_path = response.json()[\"temp_path\"]\n            self.assertIs(os.path.exists(temp_path), False)"}, {"file": "tests/file_uploads/views.py", "name": "file_upload_echo", "type": "codeblock", "score": 5.393167018890381, "line": 80, "text": "def file_upload_echo(request):\n    \"\"\"\n    Simple view to echo back info about uploaded files for tests.\n    \"\"\"\n    r = {k: f.name for k, f in request.FILES.items()}\n    return JsonResponse(r)\n\n\ndef file_upload_echo_content(request):\n    \"\"\"\n    Simple view to echo back the content of uploaded files for tests.\n    \"\"\"\n\n    def read_and_close(f):\n        with f:\n            return f.read().decode()\n\n    r = {k: read_and_close(f) for k, f in request.FILES.items()}\n    return JsonResponse(r)\n\n\ndef file_upload_quota(request):\n    \"\"\"\n    Dynamically add in an upload handler.\n    \"\"\"\n    request.upload_handlers.insert(0, QuotaUploadHandler())\n    return file_upload_echo(request)\n\n\ndef file_upload_quota_broken(request):\n    \"\"\"\n    You can't change handlers after reading FILES; this view shouldn't work.\n    \"\"\"\n    response = file_upload_echo(request)\n    request.upload_handlers.insert(0, QuotaUploadHandler())\n    return response\n\n\ndef file_stop_upload_temporary_file(request):\n    request.upload_handlers.insert(0, StopUploadTemporaryFileHandler())\n    request.upload_handlers.pop(2)\n    request.FILES  # Trigger file parsing.\n    return JsonResponse(\n        {\"temp_path\": request.upload_handlers[0].file.temporary_file_path()},\n    )\n\n\ndef file_upload_interrupted_temporary_file(request):\n    request.upload_handlers.insert(0, TemporaryFileUploadHandler())\n    request.upload_handlers.pop(2)\n    request.FILES  # Trigger file parsing.\n    return JsonResponse(\n        {\"temp_path\": request.upload_handlers[0].file.temporary_file_path()},\n    )\n\n\ndef file_upload_getlist_count(request):\n    \"\"\"\n    Check the .getlist() function to ensure we receive the correct number of\n    files.\n    \"\"\"\n    file_counts = {}\n\n    for key in request.FILES:\n        file_counts[key] = len(request.FILES.getlist(key))\n    return JsonResponse(file_counts)\n\n\ndef file_upload_errors(request):\n    request.upload_handlers.insert(0, ErroringUploadHandler())\n    return file_upload_echo(request)\n\n\ndef file_upload_filename_case_view(request):\n    \"\"\"\n    Check adding the file to the database will preserve the filename case.\n    \"\"\"\n    file = request.FILES[\"file_field\"]\n    obj = FileModel()\n    obj.testfile.save(file.name, file)\n    return HttpResponse(\"%d\" % obj.pk)"}], "total_results": 10}
