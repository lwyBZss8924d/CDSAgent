{"repo": "pytest", "query": "rewrite handles first expression numeric literal", "top_10": [{"file": "src/_pytest/mark/expression.py", "name": "TokenType", "type": "codeblock", "score": 4.639353275299072, "line": 1, "text": "r\"\"\"Evaluate match expressions, as used by `-k` and `-m`.\n\nThe grammar is:\n\nexpression: expr? EOF\nexpr:       and_expr ('or' and_expr)*\nand_expr:   not_expr ('and' not_expr)*\nnot_expr:   'not' not_expr | '(' expr ')' | ident kwargs?\n\nident:      (\\w|:|\\+|-|\\.|\\[|\\]|\\\\|/)+\nkwargs:     ('(' name '=' value ( ', ' name '=' value )*  ')')\nname:       a valid ident, but not a reserved keyword\nvalue:      (unescaped) string literal | (-)?[0-9]+ | 'False' | 'True' | 'None'\n\nThe semantics are:\n\n- Empty expression evaluates to False.\n- ident evaluates to True or False according to a provided matcher function.\n- ident with parentheses and keyword arguments evaluates to True or False according to a provided matcher function.\n- or/and/not evaluate according to the usual boolean semantics.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nimport dataclasses\nimport enum\nimport keyword\nimport re\nimport types\nfrom typing import Final\nfrom typing import final\nfrom typing import Literal\nfrom typing import NoReturn\nfrom typing import overload\nfrom typing import Protocol\n\n\n__all__ = [\n    \"Expression\",\n    \"ExpressionMatcher\",\n]\n\n\nFILE_NAME: Final = \"<pytest match expression>\"\n\n\nclass TokenType(enum.Enum):\n    LPAREN = \"left parenthesis\"\n    RPAREN = \"right parenthesis\"\n    OR = \"or\"\n    AND = \"and\"\n    NOT = \"not\"\n    IDENT = \"identifier\"\n    EOF = \"end of input\"\n    EQUAL = \"=\"\n    STRING = \"string literal\"\n    COMMA = \",\"\n\n\n@dataclasses.dataclass(frozen=True)\nclass Token:\n    __slots__ = (\"pos\", \"type\", \"value\")\n    type: TokenType\n    value: str\n    pos: int"}, {"file": "src/_pytest/_io/terminalwriter.py", "name": "TerminalWriter._highlight", "type": "codeblock", "score": 4.247210502624512, "line": 235, "text": "@final\nclass TerminalWriter:\n\n    def _highlight(\n        self, source: str, lexer: Literal[\"diff\", \"python\"] = \"python\"\n    ) -> str:\n        \"\"\"Highlight the given source if we have markup support.\"\"\"\n        if not source or not self.hasmarkup or not self.code_highlight:\n            return source\n\n        pygments_lexer = self._get_pygments_lexer(lexer)\n        pygments_formatter = self._get_pygments_formatter()\n\n        highlighted: str = pygments.highlight(\n            source, pygments_lexer, pygments_formatter\n        )\n        # pygments terminal formatter may add a newline when there wasn't one.\n        # We don't want this, remove.\n        if highlighted[-1] == \"\\n\" and source[-1] != \"\\n\":\n            highlighted = highlighted[:-1]\n\n        # Some lexers will not set the initial color explicitly\n        # which may lead to the previous color being propagated to the\n        # start of the expression, so reset first.\n        highlighted = \"\\x1b[0m\" + highlighted\n\n        return highlighted"}, {"file": "src/_pytest/mark/expression.py", "name": "ExpressionMatcher.__call__", "type": "codeblock", "score": 4.089024543762207, "line": 248, "text": "def all_kwargs(s: Scanner) -> list[ast.keyword]:\n    ret = [single_kwarg(s)]\n    while s.accept(TokenType.COMMA):\n        ret.append(single_kwarg(s))\n    return ret\n\n\nclass ExpressionMatcher(Protocol):\n    \"\"\"A callable which, given an identifier and optional kwargs, should return\n    whether it matches in an :class:`Expression` evaluation.\n\n    Should be prepared to handle arbitrary strings as input.\n\n    If no kwargs are provided, the expression of the form `foo`.\n    If kwargs are provided, the expression is of the form `foo(1, b=True, \"s\")`.\n\n    If the expression is not supported (e.g. don't want to accept the kwargs\n    syntax variant), should raise :class:`~pytest.UsageError`.\n\n    Example::\n\n        def matcher(name: str, /, **kwargs: str | int | bool | None) -> bool:\n            # Match `cat`.\n            if name == \"cat\" and not kwargs:\n                return True\n            # Match `dog(barks=True)`.\n            if name == \"dog\" and kwargs == {\"barks\": False}:\n                return True\n            return False\n    \"\"\"\n\n    def __call__(self, name: str, /, **kwargs: str | int | bool | None) -> bool: ..."}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter", "type": "codeblock", "score": 3.7921266555786133, "line": 615, "text": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false and calls pytest_assertion_pass hook\n    if expression is true.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :expl_stmts: The AST statements which will be executed to get\n       data from the assertion.  This is the code which will construct\n       the detailed assertion message that is used in the AssertionError\n       or for the pytest_assertion_pass hook.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    :scope: A tuple containing the current scope used for variables_overwrite.\n\n    :variables_overwrite: A dict filled with references to variables\n       that change value within an assert. This happens when a variable is\n       reassigned with the walrus operator\n\n    This state, except the variables_overwrite,  is reset on every new assert\n    statement visited and used by the other visitors.\n    \"\"\""}, {"file": "src/_pytest/assertion/__init__.py", "name": "pytest_addoption", "type": "codeblock", "score": 3.771029472351074, "line": 26, "text": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook. \"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n    parser.addini(\n        \"truncation_limit_lines\",\n        default=None,\n        help=\"Set threshold of LINES after which truncation will take effect\",\n    )\n    parser.addini(\n        \"truncation_limit_chars\",\n        default=None,\n        help=(\"Set threshold of CHARS after which truncation will take effect\"),\n    )\n\n    Config._add_verbosity_ini(\n        parser,\n        Config.VERBOSITY_ASSERTIONS,\n        help=(\n            \"Specify a verbosity level for assertions, overriding the main level. \"\n            \"Higher levels will provide more detailed explanation when an assertion fails.\"\n        ),\n    )"}, {"file": "src/_pytest/raises.py", "name": "RaisesGroup", "type": "codeblock", "score": 3.709984302520752, "line": 844, "text": "@final\nclass RaisesGroup(AbstractRaises[BaseExceptionGroup[BaseExcT_co]]):\n\n    # allow_unwrapped=True requires: singular exception, exception not being\n    # RaisesGroup instance, match is None, check is None\n    @overload\n    def __init__(\n        self,\n        expected_exception: type[BaseExcT_co] | RaisesExc[BaseExcT_co],\n        /,\n        *,\n        allow_unwrapped: Literal[True],\n        flatten_subgroups: bool = False,\n    ) -> None: ...\n\n    # flatten_subgroups = True also requires no nested RaisesGroup\n    @overload\n    def __init__(\n        self,\n        expected_exception: type[BaseExcT_co] | RaisesExc[BaseExcT_co],\n        /,\n        *other_exceptions: type[BaseExcT_co] | RaisesExc[BaseExcT_co],\n        flatten_subgroups: Literal[True],\n        match: str | Pattern[str] | None = None,\n        check: Callable[[BaseExceptionGroup[BaseExcT_co]], bool] | None = None,\n    ) -> None: ...\n\n    # simplify the typevars if possible (the following 3 are equivalent but go simpler->complicated)\n    # ... the first handles RaisesGroup[ValueError], the second RaisesGroup[ExceptionGroup[ValueError]],\n    #     the third RaisesGroup[ValueError | ExceptionGroup[ValueError]].\n    # ... otherwise, we will get results like RaisesGroup[ValueError | ExceptionGroup[Never]] (I think)\n    #     (technically correct but misleading)\n    @overload\n    def __init__(\n        self: RaisesGroup[ExcT_1],\n        expected_exception: type[ExcT_1] | RaisesExc[ExcT_1],\n        /,\n        *other_exceptions: type[ExcT_1] | RaisesExc[ExcT_1],\n        match: str | Pattern[str] | None = None,\n        check: Callable[[ExceptionGroup[ExcT_1]], bool] | None = None,\n    ) -> None: ..."}, {"file": "src/_pytest/_code/code.py", "name": "ExceptionInfo.group_contains", "type": "codeblock", "score": 3.6117730140686035, "line": 816, "text": "@final\n@dataclasses.dataclass\nclass ExceptionInfo(Generic[E]):\n\n    def group_contains(\n        self,\n        expected_exception: EXCEPTION_OR_MORE,\n        *,\n        match: str | re.Pattern[str] | None = None,\n        depth: int | None = None,\n    ) -> bool:\n        \"\"\"Check whether a captured exception group contains a matching exception.\n\n        :param Type[BaseException] | Tuple[Type[BaseException]] expected_exception:\n            The expected exception type, or a tuple if one of multiple possible\n            exception types are expected.\n\n        :param str | re.Pattern[str] | None match:\n            If specified, a string containing a regular expression,\n            or a regular expression object, that is tested against the string\n            representation of the exception and its `PEP-678 <https://peps.python.org/pep-0678/>` `__notes__`\n            using :func:`re.search`.\n\n            To match a literal string that may contain :ref:`special characters\n            <re-syntax>`, the pattern can first be escaped with :func:`re.escape`.\n\n        :param Optional[int] depth:\n            If `None`, will search for a matching exception at any nesting depth.\n            If >= 1, will only match an exception if it's at the specified depth (depth = 1 being\n            the exceptions contained within the topmost exception group).\n\n        .. versionadded:: 8.0\n\n        .. warning::\n           This helper makes it easy to check for the presence of specific exceptions,\n           but it is very bad for checking that the group does *not* contain\n           *any other exceptions*.\n           You should instead consider using :class:`pytest.RaisesGroup`\n\n        \"\"\"\n        msg = \"Captured exception is not an instance of `BaseExceptionGroup`\"\n        assert isinstance(self.value, BaseExceptionGroup), msg\n        msg = \"`depth` must be >= 1 if specified\"\n        assert (depth is None) or (depth >= 1), msg\n        return self._group_contains(self.value, expected_exception, match, depth)"}, {"file": "src/_pytest/mark/expression.py", "name": "Expression.compile", "type": "codeblock", "score": 3.4866445064544678, "line": 310, "text": "@final\nclass Expression:\n    \"\"\"A compiled match expression as used by -k and -m.\n\n    The expression can be evaluated against different matchers.\n    \"\"\"\n\n    __slots__ = (\"_code\", \"input\")\n\n    def __init__(self, input: str, code: types.CodeType) -> None:\n        #: The original input line, as a string.\n        self.input: Final = input\n        self._code: Final = code\n\n    @classmethod\n    def compile(cls, input: str) -> Expression:\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n\n        :raises SyntaxError: If the expression is malformed.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr,\n            filename=\"<pytest match expression>\",\n            mode=\"eval\",\n        )\n        return Expression(input, code)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.pop_format_context", "type": "codeblock", "score": 3.4686057567596436, "line": 828, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an str ast.expr instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .expl_stmts and\n        return the ast.Name instance of the formatted string.\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys: list[ast.expr | None] = [ast.Constant(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        if self.enable_assertion_pass_hook:\n            self.format_variables.append(name)\n        self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node: ast.AST) -> tuple[ast.Name, str]:\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))"}, {"file": "src/_pytest/mark/expression.py", "name": "Scanner.accept_2", "type": "codeblock", "score": 3.4438490867614746, "line": 132, "text": "class Scanner:\n\n    @overload\n    def accept(self, type: TokenType, *, reject: Literal[True]) -> Token: ...\n\n    @overload\n    def accept(\n        self, type: TokenType, *, reject: Literal[False] = False\n    ) -> Token | None: ...\n\n    def accept(self, type: TokenType, *, reject: bool = False) -> Token | None:\n        if self.current.type is type:\n            token = self.current\n            if token.type is not TokenType.EOF:\n                self.current = next(self.tokens)\n            return token\n        if reject:\n            self.reject((type,))\n        return None\n\n    def reject(self, expected: Sequence[TokenType]) -> NoReturn:\n        raise SyntaxError(\n            \"expected {}; got {}\".format(\n                \" OR \".join(type.value for type in expected),\n                self.current.type.value,\n            ),\n            (FILE_NAME, 1, self.current.pos + 1, self.input),\n        )"}], "total_results": 10}
{"repo": "pytest", "query": "_pytest.rewrite detect docstring constant", "top_10": [{"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.run", "type": "codeblock", "score": 4.862457275390625, "line": 692, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        for item in mod.body:\n            match item:\n                case ast.Expr(value=ast.Constant(value=str() as doc)) if (\n                    expect_docstring\n                ):\n                    if self.is_rewrite_disabled(doc):\n                        return\n                    expect_docstring = False\n                case ast.ImportFrom(level=0, module=\"__future__\"):\n                    pass\n                case _:\n                    break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n            ast.alias(\n                \"_pytest.assertion.rewrite\",\n                \"@pytest_ar\",\n                lineno=lineno,\n                col_offset=0,\n            ),\n        ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        self.scope = (mod,)\n        nodes: list[ast.AST | Sentinel] = [mod]\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 4.783694267272949, "line": 893, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n        # ... other code\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Constant(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Constant(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Constant(assert_.lineno),\n                    ast.Constant(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                [*self.expl_stmts, hook_call_pass],\n                [],\n            )\n            statements_pass: list[ast.stmt] = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables: list[ast.expr] = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.Constant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Constant(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Name", "type": "codeblock", "score": 4.649048328399658, "line": 987, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Name(self, name: ast.Name) -> tuple[ast.Name, str]:\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_NamedExpr", "type": "codeblock", "score": 4.543417930603027, "line": 975, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_NamedExpr(self, name: ast.NamedExpr) -> tuple[ast.NamedExpr, str]:\n        # This method handles the 'walrus operator' repr of the target\n        # name if it's a local variable or _should_repr_global_name()\n        # thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        target_id = name.target.id\n        inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 3.5352582931518555, "line": 961, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.Constant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                if getattr(node, \"lineno\", None) is None:\n                    # apply the assertion location to all generated ast nodes without source location\n                    # and preserve the location of existing nodes or generated nodes with an correct location.\n                    ast.copy_location(node, assert_)\n        return self.statements"}, {"file": "src/_pytest/assertion/__init__.py", "name": "docstring", "type": "codeblock", "score": 3.4910101890563965, "line": 1, "text": "# mypy: allow-untyped-defs\n\"\"\"Support for presenting detailed information in failing assertions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\nimport sys\nfrom typing import Any\nfrom typing import Protocol\nfrom typing import TYPE_CHECKING\n\nfrom _pytest.assertion import rewrite\nfrom _pytest.assertion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\n\nif TYPE_CHECKING:\n    from _pytest.main import Session"}, {"file": "src/_pytest/assertion/util.py", "name": "_HighlightFunc.__call__", "type": "codeblock", "score": 3.337850570678711, "line": 1, "text": "# mypy: allow-untyped-defs\n\"\"\"Utilities for assertion debugging.\"\"\"\n\nfrom __future__ import annotations\n\nimport collections.abc\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set as AbstractSet\nimport pprint\nfrom typing import Any\nfrom typing import Literal\nfrom typing import Protocol\nfrom unicodedata import normalize\n\nfrom _pytest import outcomes\nimport _pytest._code\nfrom _pytest._io.pprint import PrettyPrinter\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest._io.saferepr import saferepr_unlimited\nfrom _pytest.compat import running_on_ci\nfrom _pytest.config import Config\n\n\n# The _reprcompare attribute on the util module is used by the new assertion\n# interpretation code and assertion rewriter to detect this plugin was\n# loaded and in turn call the hooks defined here as part of the\n# DebugInterpreter.\n_reprcompare: Callable[[str, object, object], str | None] | None = None\n\n# Works similarly as _reprcompare attribute. Is populated with the hook call\n# when pytest_runtest_setup is called.\n_assertion_pass: Callable[[int, str, str], None] | None = None\n\n# Config object which is assigned during pytest_runtest_protocol.\n_config: Config | None = None\n\n\nclass _HighlightFunc(Protocol):\n    def __call__(self, source: str, lexer: Literal[\"diff\", \"python\"] = \"python\") -> str:\n        \"\"\"Apply highlighting to the given source.\"\"\"\n\n\ndef dummy_highlighter(source: str, lexer: Literal[\"diff\", \"python\"] = \"python\") -> str:\n    \"\"\"Dummy highlighter that returns the text unprocessed.\n\n    Needed for _notin_text, as the diff gets post-processed to only show the \"+\" part.\n    \"\"\"\n    return source"}, {"file": "src/_pytest/_code/code.py", "name": "FormattedExcinfo._truncate_recursive_traceback", "type": "codeblock", "score": 3.025247573852539, "line": 1138, "text": "@dataclasses.dataclass\nclass FormattedExcinfo:\n\n    def _truncate_recursive_traceback(\n        self, traceback: Traceback\n    ) -> tuple[Traceback, str | None]:\n        \"\"\"Truncate the given recursive traceback trying to find the starting\n        point of the recursion.\n\n        The detection is done by going through each traceback entry and\n        finding the point in which the locals of the frame are equal to the\n        locals of a previous frame (see ``recursionindex()``).\n\n        Handle the situation where the recursion process might raise an\n        exception (for example comparing numpy arrays using equality raises a\n        TypeError), in which case we do our best to warn the user of the\n        error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline: str | None = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                f\"    {type(e).__name__}: {e!s}\\n\"\n                f\"  Displaying first and last {max_frames} stack frames out of {len(traceback)}.\"\n            )\n            # Type ignored because adding two instances of a List subtype\n            # currently incorrectly has type List instead of the subtype.\n            traceback = traceback[:max_frames] + traceback[-max_frames:]  # type: ignore\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline"}, {"file": "src/_pytest/pytester.py", "name": "LsofFdLeakChecker.matching_platform", "type": "codeblock", "score": 2.991264820098877, "line": 159, "text": "class LsofFdLeakChecker:\n\n    def matching_platform(self) -> bool:\n        try:\n            subprocess.run((\"lsof\", \"-v\"), check=True)\n        except (OSError, subprocess.CalledProcessError):\n            return False\n        else:\n            return True\n\n    @hookimpl(wrapper=True, tryfirst=True)\n    def pytest_runtest_protocol(self, item: Item) -> Generator[None, object, object]:\n        lines1 = self.get_open_files()\n        try:\n            return (yield)\n        finally:\n            if hasattr(sys, \"pypy_version_info\"):\n                gc.collect()\n            lines2 = self.get_open_files()\n\n            new_fds = {t[0] for t in lines2} - {t[0] for t in lines1}\n            leaked_files = [t for t in lines2 if t[0] in new_fds]\n            if leaked_files:\n                error = [\n                    f\"***** {len(leaked_files)} FD leakage detected\",\n                    *(str(f) for f in leaked_files),\n                    \"*** Before:\",\n                    *(str(f) for f in lines1),\n                    \"*** After:\",\n                    *(str(f) for f in lines2),\n                    f\"***** {len(leaked_files)} FD leakage detected\",\n                    \"*** function {}:{}: {} \".format(*item.location),\n                    \"See issue #2366\",\n                ]\n                item.warn(PytestFDWarning(\"\\n\".join(error)))"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Compare", "type": "codeblock", "score": 2.911128282546997, "line": 1110, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Compare(self, comp: ast.Compare) -> tuple[ast.expr, str]:\n        self.push_format_context()\n        # We first check if we have overwritten a variable in the previous assert\n        match comp.left:\n            case ast.Name(id=name_id) if name_id in self.variables_overwrite.get(\n                self.scope, {}\n            ):\n                comp.left = self.variables_overwrite[self.scope][name_id]  # type: ignore[assignment]\n            case ast.NamedExpr(target=ast.Name(id=target_id)):\n                self.variables_overwrite[self.scope][target_id] = comp.left  # type: ignore[assignment]\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, ast.Compare | ast.BoolOp):\n            left_expl = f\"({left_expl})\"\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names: list[ast.expr] = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators, strict=True)\n        expls: list[ast.expr] = []\n        syms: list[ast.expr] = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            match (next_operand, left_res):\n                case (\n                    ast.NamedExpr(target=ast.Name(id=target_id)),\n                    ast.Name(id=name_id),\n                ) if target_id == name_id:\n                    next_operand.target.id = self.variable()\n                    self.variables_overwrite[self.scope][name_id] = next_operand  # type: ignore[assignment]\n\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, ast.Compare | ast.BoolOp):\n                next_expl = f\"({next_expl})\"\n            results.append(next_res)\n            sym = BINOP_MAP[op.__class__]\n            syms.append(ast.Constant(sym))\n            expl = f\"{left_expl} {sym} {next_expl}\"\n            expls.append(ast.Constant(expl))\n            res_expr = ast.copy_location(ast.Compare(left_res, [op], [next_res]), comp)\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        # ... other code"}], "total_results": 10}
{"repo": "pytest", "query": "ModuleRewriter load_module docstring stripping", "top_10": [{"file": "testing/python/approx.py", "name": "mocked_doctest_runner", "type": "codeblock", "score": 3.2633376121520996, "line": 1, "text": "# mypy: allow-untyped-defs\nfrom __future__ import annotations\n\nfrom contextlib import contextmanager\nimport decimal\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import inf\nfrom math import nan\nfrom math import sqrt\nimport operator\nfrom operator import eq\nfrom operator import ne\nimport re\n\nfrom _pytest.pytester import Pytester\nfrom _pytest.python_api import _recursive_sequence_map\nimport pytest\nfrom pytest import approx\n\n\n@pytest.fixture\ndef mocked_doctest_runner(monkeypatch):\n    import doctest\n\n    class MockedPdb:\n        def __init__(self, out):\n            pass\n\n        def set_trace(self):\n            raise NotImplementedError(\"not used\")\n\n        def reset(self):\n            pass\n\n        def set_continue(self):\n            pass\n\n    monkeypatch.setattr(\"doctest._OutputRedirectingPdb\", MockedPdb)\n\n    class MyDocTestRunner(doctest.DocTestRunner):\n        def report_failure(self, out, test, example, got):\n            raise AssertionError(\n                f\"'{example.source.strip()}' evaluates to '{got.strip()}', not '{example.want.strip()}'\"\n            )\n\n    return MyDocTestRunner()\n\n\n@contextmanager\ndef temporary_verbosity(config, verbosity=0):\n    original_verbosity = config.getoption(\"verbose\")\n    config.option.verbose = verbosity\n    try:\n        yield\n    finally:\n        config.option.verbose = original_verbosity"}, {"file": "src/_pytest/_code/source.py", "name": "docstring", "type": "codeblock", "score": 2.586292028427124, "line": 1, "text": "# mypy: allow-untyped-defs\nfrom __future__ import annotations\n\nimport ast\nfrom bisect import bisect_right\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nimport inspect\nimport textwrap\nimport tokenize\nimport types\nfrom typing import overload\nimport warnings\n\n\nclass Source:\n    \"\"\"An immutable object holding a source code fragment.\n\n    When using Source(...), the source lines are deindented.\n    \"\"\"\n\n    def __init__(self, obj: object = None) -> None:\n        if not obj:\n            self.lines: list[str] = []\n            self.raw_lines: list[str] = []\n        elif isinstance(obj, Source):\n            self.lines = obj.lines\n            self.raw_lines = obj.raw_lines\n        elif isinstance(obj, tuple | list):\n            self.lines = deindent(x.rstrip(\"\\n\") for x in obj)\n            self.raw_lines = list(x.rstrip(\"\\n\") for x in obj)\n        elif isinstance(obj, str):\n            self.lines = deindent(obj.split(\"\\n\"))\n            self.raw_lines = obj.split(\"\\n\")\n        else:\n            try:\n                rawcode = getrawcode(obj)\n                src = inspect.getsource(rawcode)\n            except TypeError:\n                src = inspect.getsource(obj)  # type: ignore[arg-type]\n            self.lines = deindent(src.split(\"\\n\"))\n            self.raw_lines = src.split(\"\\n\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Source):\n            return NotImplemented\n        return self.lines == other.lines\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str: ...\n\n    @overload\n    def __getitem__(self, key: slice) -> Source: ...\n\n    def __getitem__(self, key: int | slice) -> str | Source:\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            newsource.raw_lines = self.raw_lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> Source:\n        \"\"\"Return new Source object with trailing and leading blank lines removed.\"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.raw_lines = self.raw_lines\n        source.lines[:] = self.lines[start:end]\n        return source"}, {"file": "scripts/release.py", "name": "announce", "type": "codeblock", "score": 2.5096802711486816, "line": 1, "text": "# mypy: disallow-untyped-defs\n\"\"\"Invoke development tasks.\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nfrom pathlib import Path\nimport re\nfrom subprocess import call\nfrom subprocess import check_call\nfrom subprocess import check_output\n\nfrom colorama import Fore\nfrom colorama import init\n\n\ndef announce(version: str, template_name: str, doc_version: str) -> None:\n    \"\"\"Generates a new release announcement entry in the docs.\"\"\"\n    stdout = check_output([\"git\", \"describe\", \"--abbrev=0\", \"--tags\"], encoding=\"UTF-8\")\n    last_version = stdout.strip()\n    rev_range = f\"{last_version}..HEAD\"\n\n    authors = check_output(\n        [\"git\", \"log\", rev_range, \"--format=%aN\"], encoding=\"UTF-8\"\n    ).splitlines()\n\n    co_authors_output = check_output(\n        [\"git\", \"log\", rev_range, \"--format=%(trailers:key=Co-authored-by) \"],\n        encoding=\"UTF-8\",\n    )\n    co_authors: list[str] = []\n    for co_author_line in co_authors_output.splitlines():\n        if m := re.search(r\"Co-authored-by: (.+?)<\", co_author_line):\n            co_authors.append(m.group(1).strip())\n\n    contributors = {\n        name\n        for name in authors + co_authors\n        if not name.endswith(\"[bot]\") and name != \"pytest bot\"\n    }\n\n    template_text = (\n        Path(__file__).parent.joinpath(template_name).read_text(encoding=\"UTF-8\")\n    )\n\n    contributors_text = \"\\n\".join(f\"* {name}\" for name in sorted(contributors)) + \"\\n\"\n    text = template_text.format(\n        version=version, contributors=contributors_text, doc_version=doc_version\n    )\n\n    target = Path(__file__).parent.joinpath(f\"../doc/en/announce/release-{version}.rst\")\n    target.write_text(text, encoding=\"UTF-8\")\n    print(f\"{Fore.CYAN}[generate.announce] {Fore.RESET}Generated {target.name}\")\n\n    # Update index with the new release entry\n    index_path = Path(__file__).parent.joinpath(\"../doc/en/announce/index.rst\")\n    lines = index_path.read_text(encoding=\"UTF-8\").splitlines()\n    indent = \"   \"\n    # ... other code"}, {"file": "src/_pytest/mark/structures.py", "name": "ParameterSet._parse_parametrize_args", "type": "codeblock", "score": 2.4804961681365967, "line": 164, "text": "class ParameterSet(NamedTuple):\n\n    @staticmethod\n    def _parse_parametrize_args(\n        argnames: str | Sequence[str],\n        argvalues: Iterable[ParameterSet | Sequence[object] | object],\n        *args,\n        **kwargs,\n    ) -> tuple[Sequence[str], bool]:\n        if isinstance(argnames, str):\n            argnames = [x.strip() for x in argnames.split(\",\") if x.strip()]\n            force_tuple = len(argnames) == 1\n        else:\n            force_tuple = False\n        return argnames, force_tuple\n\n    @staticmethod\n    def _parse_parametrize_parameters(\n        argvalues: Iterable[ParameterSet | Sequence[object] | object],\n        force_tuple: bool,\n    ) -> list[ParameterSet]:\n        return [\n            ParameterSet.extract_from(x, force_tuple=force_tuple) for x in argvalues\n        ]"}, {"file": "src/_pytest/doctest.py", "name": "DoctestItem.reportinfo", "type": "codeblock", "score": 2.4400525093078613, "line": 317, "text": "class DoctestItem(Item):\n    def repr_failure(  # type: ignore[override]\n        self,\n        excinfo: ExceptionInfo[BaseException],\n    ) -> str | TerminalRepr:\n        import doctest\n\n        failures: (\n            Sequence[doctest.DocTestFailure | doctest.UnexpectedException] | None\n        ) = None\n        if isinstance(\n            excinfo.value, doctest.DocTestFailure | doctest.UnexpectedException\n        ):\n            failures = [excinfo.value]\n        elif isinstance(excinfo.value, MultipleDoctestFailures):\n            failures = excinfo.value.failures\n\n        if failures is None:\n            return super().repr_failure(excinfo)\n\n        reprlocation_lines = []\n        for failure in failures:\n            example = failure.example\n            test = failure.test\n            filename = test.filename\n            if test.lineno is None:\n                lineno = None\n            else:\n                lineno = test.lineno + example.lineno + 1\n            message = type(failure).__name__\n            # TODO: ReprFileLocation doesn't expect a None lineno.\n            reprlocation = ReprFileLocation(filename, lineno, message)  # type: ignore[arg-type]\n            checker = _get_checker()\n            report_choice = _get_report_choice(self.config.getoption(\"doctestreport\"))\n            if lineno is not None:\n                assert failure.test.docstring is not None\n                lines = failure.test.docstring.splitlines(False)\n                # add line numbers to the left of the error message\n                assert test.lineno is not None\n                lines = [\n                    f\"{i + test.lineno + 1:03d} {x}\" for (i, x) in enumerate(lines)\n                ]\n                # trim docstring error lines to 10\n                lines = lines[max(example.lineno - 9, 0) : example.lineno + 1]\n            else:\n                lines = [\n                    \"EXAMPLE LOCATION UNKNOWN, not showing all tests of that example\"\n                ]\n                indent = \">>>\"\n                for line in example.source.splitlines():\n                    lines.append(f\"??? {indent} {line}\")\n                    indent = \"...\"\n            if isinstance(failure, doctest.DocTestFailure):\n                lines += checker.output_difference(\n                    example, failure.got, report_choice\n                ).split(\"\\n\")\n            else:\n                inner_excinfo = ExceptionInfo.from_exc_info(failure.exc_info)\n                lines += [f\"UNEXPECTED EXCEPTION: {inner_excinfo.value!r}\"]\n                lines += [\n                    x.strip(\"\\n\") for x in traceback.format_exception(*failure.exc_info)\n                ]\n            reprlocation_lines.append((reprlocation, lines))\n        return ReprFailDoctest(reprlocation_lines)\n\n    def reportinfo(self) -> tuple[os.PathLike[str] | str, int | None, str]:\n        return self.path, self.dtest.lineno, f\"[doctest] {self.name}\""}, {"file": "src/_pytest/fixtures.py", "name": "FixtureLookupErrorRepr", "type": "codeblock", "score": 2.2398617267608643, "line": 867, "text": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(\n        self,\n        filename: str | os.PathLike[str],\n        firstlineno: int,\n        tblines: Sequence[str],\n        errorstring: str,\n        argname: str | None,\n    ) -> None:\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                f\"{FormattedExcinfo.fail_marker}       {lines[0].strip()}\",\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    f\"{FormattedExcinfo.flow_marker}       {line.strip()}\",\n                    red=True,\n                )\n        tw.line()\n        tw.line(f\"{os.fspath(self.filename)}:{self.firstlineno + 1}\")"}, {"file": "src/_pytest/_py/path.py", "name": "LocalPath.join", "type": "codeblock", "score": 2.136242389678955, "line": 719, "text": "class LocalPath:\n\n    def join(self, *args: os.PathLike[str], abs: bool = False) -> LocalPath:\n        \"\"\"Return a new path by appending all 'args' as path\n        components.  if abs=1 is used restart from root if any\n        of the args is an absolute path.\n        \"\"\"\n        sep = self.sep\n        strargs = [os.fspath(arg) for arg in args]\n        strpath = self.strpath\n        if abs:\n            newargs: list[str] = []\n            for arg in reversed(strargs):\n                if isabs(arg):\n                    strpath = arg\n                    strargs = newargs\n                    break\n                newargs.insert(0, arg)\n        # special case for when we have e.g. strpath == \"/\"\n        actual_sep = \"\" if strpath.endswith(sep) else sep\n        for arg in strargs:\n            arg = arg.strip(sep)\n            if iswin32:\n                # allow unix style paths even on windows.\n                arg = arg.strip(\"/\")\n                arg = arg.replace(\"/\", sep)\n            strpath = strpath + actual_sep + arg\n            actual_sep = sep\n        obj = object.__new__(self.__class__)\n        obj.strpath = normpath(strpath)\n        return obj"}, {"file": "src/_pytest/config/__init__.py", "name": "PytestPluginManager._check_non_top_pytest_plugins", "type": "codeblock", "score": 1.8815340995788574, "line": 769, "text": "@final\nclass PytestPluginManager(PluginManager):\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(\n        self, args: Sequence[str], *, exclude_only: bool = False\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                parg = parg.strip()\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue\n                self.consider_pluginarg(parg)"}, {"file": "src/_pytest/_code/code.py", "name": "TerminalRepr", "type": "codeblock", "score": 1.8719995021820068, "line": 1225, "text": "@dataclasses.dataclass(eq=False)\nclass TerminalRepr:\n    def __str__(self) -> str:\n        # FYI this is called from pytest-xdist's serialization of exception\n        # information.\n        io = StringIO()\n        tw = TerminalWriter(file=io)\n        self.toterminal(tw)\n        return io.getvalue().strip()\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__} instance at {id(self):0x}>\"\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        raise NotImplementedError()"}, {"file": "src/_pytest/logging.py", "name": "LoggingPlugin._runtest_for", "type": "codeblock", "score": 1.853217601776123, "line": 812, "text": "class LoggingPlugin:\n\n    @contextmanager\n    def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None]:\n        \"\"\"Implement the internals of the pytest_runtest_xxx() hooks.\"\"\"\n        with (\n            catching_logs(\n                self.caplog_handler,\n                level=self.log_level,\n            ) as caplog_handler,\n            catching_logs(\n                self.report_handler,\n                level=self.log_level,\n            ) as report_handler,\n        ):\n            caplog_handler.reset()\n            report_handler.reset()\n            item.stash[caplog_records_key][when] = caplog_handler.records\n            item.stash[caplog_handler_key] = caplog_handler\n\n            try:\n                yield\n            finally:\n                log = report_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)"}], "total_results": 10}
{"repo": "pytest", "query": "assertion rewrite when module starts with number", "top_10": [{"file": "src/_pytest/assertion/__init__.py", "name": "install_importhook", "type": "codeblock", "score": 4.926191806793213, "line": 116, "text": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config.stash[assertstate_key] = AssertionState(config, \"rewrite\")\n    config.stash[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config.stash[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config.stash[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: Session) -> None:\n    # This hook is only called when test modules are collected\n    # so for example not in the managing process of pytest-xdist\n    # (which does not collect test modules).\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)"}, {"file": "src/_pytest/assertion/__init__.py", "name": "pytest_addoption", "type": "codeblock", "score": 4.721620082855225, "line": 26, "text": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook. \"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n    parser.addini(\n        \"truncation_limit_lines\",\n        default=None,\n        help=\"Set threshold of LINES after which truncation will take effect\",\n    )\n    parser.addini(\n        \"truncation_limit_chars\",\n        default=None,\n        help=(\"Set threshold of CHARS after which truncation will take effect\"),\n    )\n\n    Config._add_verbosity_ini(\n        parser,\n        Config.VERBOSITY_ASSERTIONS,\n        help=(\n            \"Specify a verbosity level for assertions, overriding the main level. \"\n            \"Higher levels will provide more detailed explanation when an assertion fails.\"\n        ),\n    )"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewritingHook.exec_module", "type": "codeblock", "score": 4.448801517486572, "line": 157, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)"}, {"file": "src/_pytest/reports.py", "name": "TestReport.__init__", "type": "codeblock", "score": 4.308040142059326, "line": 305, "text": "class TestReport(BaseReport):\n    \"\"\"Basic test report object (also used for setup and teardown calls if\n    they fail).\n\n    Reports can contain arbitrary extra attributes.\n    \"\"\"\n\n    __test__ = False\n\n    # Defined by skipping plugin.\n    # xfail reason if xfailed, otherwise not defined. Use hasattr to distinguish.\n    wasxfail: str\n\n    def __init__(\n        self,\n        nodeid: str,\n        location: tuple[str, int | None, str],\n        keywords: Mapping[str, Any],\n        outcome: Literal[\"passed\", \"failed\", \"skipped\"],\n        longrepr: None\n        | ExceptionInfo[BaseException]\n        | tuple[str, int, str]\n        | str\n        | TerminalRepr,\n        when: Literal[\"setup\", \"call\", \"teardown\"],\n        sections: Iterable[tuple[str, str]] = (),\n        duration: float = 0,\n        start: float = 0,\n        stop: float = 0,\n        user_properties: Iterable[tuple[str, object]] | None = None,\n        **extra,\n    ) -> None:\n        #: Normalized collection nodeid.\n        self.nodeid = nodeid\n\n        #: A (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        #: The filesystempath may be relative to ``config.rootdir``.\n        #: The line number is 0-based.\n        self.location: tuple[str, int | None, str] = location\n\n        #: A name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords: Mapping[str, Any] = keywords\n\n        #: Test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: One of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when: Literal[\"setup\", \"call\", \"teardown\"] = when\n\n        #: User properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test.\n        self.user_properties = list(user_properties or [])\n\n        #: Tuples of str ``(heading, content)`` with extra information\n        #: for the test report. Used by pytest to add text captured\n        #: from ``stdout``, ``stderr``, and intercepted logging events. May\n        #: be used by other plugins to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: Time it took to run just the test.\n        self.duration: float = duration\n\n        #: The system time when the call started, in seconds since the epoch.\n        self.start: float = start\n        #: The system time when the call ended, in seconds since the epoch.\n        self.stop: float = stop\n\n        self.__dict__.update(extra)"}, {"file": "src/_pytest/runner.py", "name": "CallInfo.__init__", "type": "codeblock", "score": 4.106125831604004, "line": 283, "text": "@final\n@dataclasses.dataclass\nclass CallInfo(Generic[TResult]):\n    \"\"\"Result/Exception info of a function invocation.\"\"\"\n\n    _result: TResult | None\n    #: The captured exception of the call, if it raised.\n    excinfo: ExceptionInfo[BaseException] | None\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.\n    duration: float\n    #: The context of invocation: \"collect\", \"setup\", \"call\" or \"teardown\".\n    when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"]\n\n    def __init__(\n        self,\n        result: TResult | None,\n        excinfo: ExceptionInfo[BaseException] | None,\n        start: float,\n        stop: float,\n        duration: float,\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._result = result\n        self.excinfo = excinfo\n        self.start = start\n        self.stop = stop\n        self.duration = duration\n        self.when = when"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter", "type": "codeblock", "score": 4.071279048919678, "line": 615, "text": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false and calls pytest_assertion_pass hook\n    if expression is true.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :expl_stmts: The AST statements which will be executed to get\n       data from the assertion.  This is the code which will construct\n       the detailed assertion message that is used in the AssertionError\n       or for the pytest_assertion_pass hook.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    :scope: A tuple containing the current scope used for variables_overwrite.\n\n    :variables_overwrite: A dict filled with references to variables\n       that change value within an assert. This happens when a variable is\n       reassigned with the walrus operator\n\n    This state, except the variables_overwrite,  is reset on every new assert\n    statement visited and used by the other visitors.\n    \"\"\""}, {"file": "src/_pytest/doctest.py", "name": "_get_allow_bytes_flag", "type": "codeblock", "score": 3.9561119079589844, "line": 663, "text": "def _get_checker() -> doctest.OutputChecker:\n    \"\"\"Return a doctest.OutputChecker subclass that supports some\n    additional options:\n\n    * ALLOW_UNICODE and ALLOW_BYTES options to ignore u'' and b''\n      prefixes (respectively) in string literals. Useful when the same\n      doctest should run in Python 2 and Python 3.\n\n    * NUMBER to ignore floating-point differences smaller than the\n      precision of the literal number in the doctest.\n\n    An inner class is used to avoid importing \"doctest\" at the module\n    level.\n    \"\"\"\n    global CHECKER_CLASS\n    if CHECKER_CLASS is None:\n        CHECKER_CLASS = _init_checker_class()\n    return CHECKER_CLASS()\n\n\ndef _get_allow_unicode_flag() -> int:\n    \"\"\"Register and return the ALLOW_UNICODE flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_UNICODE\")\n\n\ndef _get_allow_bytes_flag() -> int:\n    \"\"\"Register and return the ALLOW_BYTES flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_BYTES\")\n\n\ndef _get_number_flag() -> int:\n    \"\"\"Register and return the NUMBER flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"NUMBER\")"}, {"file": "src/_pytest/assertion/__init__.py", "name": "AssertionState", "type": "codeblock", "score": 3.869474411010742, "line": 96, "text": "class RewriteHook(Protocol):\n    def mark_rewrite(self, *names: str) -> None: ...\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook: rewrite.AssertionRewritingHook | None = None"}, {"file": "src/_pytest/pathlib.py", "name": "_import_module_using_spec", "type": "codeblock", "score": 3.847597360610962, "line": 696, "text": "def _import_module_using_spec(\n    module_name: str, module_path: Path, module_location: Path, *, insert_modules: bool\n) -> ModuleType | None:\n    # ... other code\n    for meta_importer in sys.meta_path:\n        module_name_of_meta = getattr(meta_importer.__class__, \"__module__\", \"\")\n        if module_name_of_meta == \"_pytest.assertion.rewrite\" and module_path.is_file():\n            # Import modules in subdirectories by module_path\n            # to ensure assertion rewrites are not missed (#12659).\n            find_spec_path = [str(module_location), str(module_path)]\n        else:\n            find_spec_path = [str(module_location)]\n\n        spec = meta_importer.find_spec(module_name, find_spec_path)\n\n        if spec_matches_module_path(spec, module_path):\n            break\n    else:\n        loader = None\n        if module_path.is_dir():\n            # The `spec_from_file_location` matches a loader based on the file extension by default.\n            # For a namespace package, need to manually specify a loader.\n            loader = NamespaceLoader(name, module_path, PathFinder())  # type: ignore[arg-type]\n\n        spec = importlib.util.spec_from_file_location(\n            module_name, str(module_path), loader=loader\n        )\n\n    if spec_matches_module_path(spec, module_path):\n        assert spec is not None\n        # Find spec and import this module.\n        mod = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = mod\n        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n\n        # Set this module as an attribute of the parent module (#12194).\n        if parent_module is not None:\n            setattr(parent_module, name, mod)\n\n        if insert_modules:\n            insert_missing_modules(sys.modules, module_name)\n        return mod\n\n    return None"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.run", "type": "codeblock", "score": 3.7591183185577393, "line": 692, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        for item in mod.body:\n            match item:\n                case ast.Expr(value=ast.Constant(value=str() as doc)) if (\n                    expect_docstring\n                ):\n                    if self.is_rewrite_disabled(doc):\n                        return\n                    expect_docstring = False\n                case ast.ImportFrom(level=0, module=\"__future__\"):\n                    pass\n                case _:\n                    break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n            ast.alias(\n                \"_pytest.assertion.rewrite\",\n                \"@pytest_ar\",\n                lineno=lineno,\n                col_offset=0,\n            ),\n        ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        self.scope = (mod,)\n        nodes: list[ast.AST | Sentinel] = [mod]\n        # ... other code"}], "total_results": 10}
{"repo": "pytest", "query": "docstring detection using ast.Constant", "top_10": [{"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 6.8643388748168945, "line": 893, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n        # ... other code\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Constant(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Constant(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Constant(assert_.lineno),\n                    ast.Constant(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                [*self.expl_stmts, hook_call_pass],\n                [],\n            )\n            statements_pass: list[ast.stmt] = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables: list[ast.expr] = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.Constant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Constant(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Name", "type": "codeblock", "score": 6.381410598754883, "line": 987, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Name(self, name: ast.Name) -> tuple[ast.Name, str]:\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_NamedExpr", "type": "codeblock", "score": 6.306492805480957, "line": 975, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_NamedExpr(self, name: ast.NamedExpr) -> tuple[ast.NamedExpr, str]:\n        # This method handles the 'walrus operator' repr of the target\n        # name if it's a local variable or _should_repr_global_name()\n        # thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        target_id = name.target.id\n        inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.run", "type": "codeblock", "score": 5.9348955154418945, "line": 692, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        for item in mod.body:\n            match item:\n                case ast.Expr(value=ast.Constant(value=str() as doc)) if (\n                    expect_docstring\n                ):\n                    if self.is_rewrite_disabled(doc):\n                        return\n                    expect_docstring = False\n                case ast.ImportFrom(level=0, module=\"__future__\"):\n                    pass\n                case _:\n                    break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n            ast.alias(\n                \"_pytest.assertion.rewrite\",\n                \"@pytest_ar\",\n                lineno=lineno,\n                col_offset=0,\n            ),\n        ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        self.scope = (mod,)\n        nodes: list[ast.AST | Sentinel] = [mod]\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Compare", "type": "codeblock", "score": 5.7151031494140625, "line": 1110, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Compare(self, comp: ast.Compare) -> tuple[ast.expr, str]:\n        self.push_format_context()\n        # We first check if we have overwritten a variable in the previous assert\n        match comp.left:\n            case ast.Name(id=name_id) if name_id in self.variables_overwrite.get(\n                self.scope, {}\n            ):\n                comp.left = self.variables_overwrite[self.scope][name_id]  # type: ignore[assignment]\n            case ast.NamedExpr(target=ast.Name(id=target_id)):\n                self.variables_overwrite[self.scope][target_id] = comp.left  # type: ignore[assignment]\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, ast.Compare | ast.BoolOp):\n            left_expl = f\"({left_expl})\"\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names: list[ast.expr] = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators, strict=True)\n        expls: list[ast.expr] = []\n        syms: list[ast.expr] = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            match (next_operand, left_res):\n                case (\n                    ast.NamedExpr(target=ast.Name(id=target_id)),\n                    ast.Name(id=name_id),\n                ) if target_id == name_id:\n                    next_operand.target.id = self.variable()\n                    self.variables_overwrite[self.scope][name_id] = next_operand  # type: ignore[assignment]\n\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, ast.Compare | ast.BoolOp):\n                next_expl = f\"({next_expl})\"\n            results.append(next_res)\n            sym = BINOP_MAP[op.__class__]\n            syms.append(ast.Constant(sym))\n            expl = f\"{left_expl} {sym} {next_expl}\"\n            expls.append(ast.Constant(expl))\n            res_expr = ast.copy_location(ast.Compare(left_res, [op], [next_res]), comp)\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_BoolOp", "type": "codeblock", "score": 5.388396739959717, "line": 997, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_BoolOp(self, boolop: ast.BoolOp) -> tuple[ast.Name, str]:\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.expl_stmts\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuiting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner: list[ast.stmt] = []\n                # cond is set in a prior loop iteration below\n                self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa: F821\n                self.expl_stmts = fail_inner\n                match v:\n                    # Check if the left operand is an ast.NamedExpr and the value has already been visited\n                    case ast.Compare(\n                        left=ast.NamedExpr(target=ast.Name(id=target_id))\n                    ) if target_id in [\n                        e.id for e in boolop.values[:i] if hasattr(e, \"id\")\n                    ]:\n                        pytest_temp = self.variable()\n                        self.variables_overwrite[self.scope][target_id] = v.left  # type:ignore[assignment]\n                        # mypy's false positive, we're checking that the 'target' attribute exists.\n                        v.left.target.id = pytest_temp  # type:ignore[attr-defined]\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Constant(expl))\n            call = ast.Call(app, [expl_format], [])\n            self.expl_stmts.append(ast.Expr(call))\n            if i < levels:\n                cond: ast.expr = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner: list[ast.stmt] = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.expl_stmts = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Constant(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)"}, {"file": "src/_pytest/mark/expression.py", "name": "and_expr", "type": "codeblock", "score": 5.310103893280029, "line": 160, "text": "# True, False and None are legal match expression identifiers,\n# but illegal as Python identifiers. To fix this, this prefix\n# is added to identifiers in the conversion to Python AST.\nIDENT_PREFIX = \"$\"\n\n\ndef expression(s: Scanner) -> ast.Expression:\n    if s.accept(TokenType.EOF):\n        ret: ast.expr = ast.Constant(False)\n    else:\n        ret = expr(s)\n        s.accept(TokenType.EOF, reject=True)\n    return ast.fix_missing_locations(ast.Expression(ret))\n\n\ndef expr(s: Scanner) -> ast.expr:\n    ret = and_expr(s)\n    while s.accept(TokenType.OR):\n        rhs = and_expr(s)\n        ret = ast.BoolOp(ast.Or(), [ret, rhs])\n    return ret\n\n\ndef and_expr(s: Scanner) -> ast.expr:\n    ret = not_expr(s)\n    while s.accept(TokenType.AND):\n        rhs = not_expr(s)\n        ret = ast.BoolOp(ast.And(), [ret, rhs])\n    return ret"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 5.275771141052246, "line": 961, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.Constant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                if getattr(node, \"lineno\", None) is None:\n                    # apply the assertion location to all generated ast nodes without source location\n                    # and preserve the location of existing nodes or generated nodes with an correct location.\n                    ast.copy_location(node, assert_)\n        return self.statements"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.is_rewrite_disabled", "type": "codeblock", "score": 5.233119964599609, "line": 771, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    @staticmethod\n    def is_rewrite_disabled(docstring: str) -> bool:\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self) -> str:\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr: ast.expr) -> ast.Name:\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.copy_location(ast.Name(name, ast.Load()), expr)\n\n    def display(self, expr: ast.expr) -> ast.expr:\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name: str, *args: ast.expr) -> ast.expr:\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast.Call(attr, list(args), [])\n\n    def builtin(self, name: str) -> ast.Attribute:\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.pop_format_context", "type": "codeblock", "score": 5.015839576721191, "line": 828, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an str ast.expr instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .expl_stmts and\n        return the ast.Name instance of the formatted string.\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys: list[ast.expr | None] = [ast.Constant(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        if self.enable_assertion_pass_hook:\n            self.format_variables.append(name)\n        self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node: ast.AST) -> tuple[ast.Name, str]:\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))"}], "total_results": 10}
{"repo": "pytest", "query": "tests for rewrite docstring misdetection", "top_10": [{"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.run", "type": "codeblock", "score": 3.2225115299224854, "line": 692, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        for item in mod.body:\n            match item:\n                case ast.Expr(value=ast.Constant(value=str() as doc)) if (\n                    expect_docstring\n                ):\n                    if self.is_rewrite_disabled(doc):\n                        return\n                    expect_docstring = False\n                case ast.ImportFrom(level=0, module=\"__future__\"):\n                    pass\n                case _:\n                    break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n            ast.alias(\n                \"_pytest.assertion.rewrite\",\n                \"@pytest_ar\",\n                lineno=lineno,\n                col_offset=0,\n            ),\n        ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        self.scope = (mod,)\n        nodes: list[ast.AST | Sentinel] = [mod]\n        # ... other code"}, {"file": "src/_pytest/assertion/__init__.py", "name": "docstring", "type": "codeblock", "score": 3.1603333950042725, "line": 1, "text": "# mypy: allow-untyped-defs\n\"\"\"Support for presenting detailed information in failing assertions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\nimport sys\nfrom typing import Any\nfrom typing import Protocol\nfrom typing import TYPE_CHECKING\n\nfrom _pytest.assertion import rewrite\nfrom _pytest.assertion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\n\nif TYPE_CHECKING:\n    from _pytest.main import Session"}, {"file": "src/_pytest/assertion/__init__.py", "name": "install_importhook", "type": "codeblock", "score": 2.9820361137390137, "line": 116, "text": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config.stash[assertstate_key] = AssertionState(config, \"rewrite\")\n    config.stash[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config.stash[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config.stash[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: Session) -> None:\n    # This hook is only called when test modules are collected\n    # so for example not in the managing process of pytest-xdist\n    # (which does not collect test modules).\n    assertstate = session.config.stash.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewritingHook._should_rewrite", "type": "codeblock", "score": 2.78197979927063, "line": 238, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def _should_rewrite(self, name: str, fn: str, state: AssertionState) -> bool:\n        # always rewrite conftest files\n        if os.path.basename(fn) == \"conftest.py\":\n            state.trace(f\"rewriting conftest file: {fn!r}\")\n            return True\n\n        if self.session is not None:\n            if self.session.isinitpath(absolutepath(fn)):\n                state.trace(f\"matched test file (was specified on cmdline): {fn!r}\")\n                return True\n\n        # modules not passed explicitly on the command line are only\n        # rewritten if they match the naming convention for test files\n        fn_path = PurePath(fn)\n        for pat in self.fnpats:\n            if fnmatch_ex(pat, fn_path):\n                state.trace(f\"matched test file {fn!r}\")\n                return True\n\n        return self._is_marked_for_rewrite(name, state)"}, {"file": "src/_pytest/assertion/__init__.py", "name": "pytest_addoption", "type": "codeblock", "score": 2.6316025257110596, "line": 26, "text": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook. \"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n    parser.addini(\n        \"truncation_limit_lines\",\n        default=None,\n        help=\"Set threshold of LINES after which truncation will take effect\",\n    )\n    parser.addini(\n        \"truncation_limit_chars\",\n        default=None,\n        help=(\"Set threshold of CHARS after which truncation will take effect\"),\n    )\n\n    Config._add_verbosity_ini(\n        parser,\n        Config.VERBOSITY_ASSERTIONS,\n        help=(\n            \"Specify a verbosity level for assertions, overriding the main level. \"\n            \"Higher levels will provide more detailed explanation when an assertion fails.\"\n        ),\n    )"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 2.5904202461242676, "line": 854, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            import warnings\n\n            from _pytest.warning_types import PytestAssertRewriteWarning\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: list[ast.stmt] = []\n        self.variables: list[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: list[str] = []\n\n        self.stack: list[dict[str, ast.expr]] = []\n        self.expl_stmts: list[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewritingHook.exec_module", "type": "codeblock", "score": 2.4782607555389404, "line": 157, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)"}, {"file": "src/_pytest/pytester_assertions.py", "name": "assertoutcome", "type": "codeblock", "score": 2.4263341426849365, "line": 1, "text": "\"\"\"Helper plugin for pytester; should not be loaded on its own.\"\"\"\n\n# This plugin contains assertions used by pytester. pytester cannot\n# contain them itself, since it is imported by the `pytest` module,\n# hence cannot be subject to assertion rewriting, which requires a\n# module to not be already imported.\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\n\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\n\n\ndef assertoutcome(\n    outcomes: tuple[\n        Sequence[TestReport],\n        Sequence[CollectReport | TestReport],\n        Sequence[CollectReport | TestReport],\n    ],\n    passed: int = 0,\n    skipped: int = 0,\n    failed: int = 0,\n) -> None:\n    __tracebackhide__ = True\n\n    realpassed, realskipped, realfailed = outcomes\n    obtained = {\n        \"passed\": len(realpassed),\n        \"skipped\": len(realskipped),\n        \"failed\": len(realfailed),\n    }\n    expected = {\"passed\": passed, \"skipped\": skipped, \"failed\": failed}\n    assert obtained == expected, outcomes"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.is_rewrite_disabled", "type": "codeblock", "score": 2.3825628757476807, "line": 771, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    @staticmethod\n    def is_rewrite_disabled(docstring: str) -> bool:\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self) -> str:\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr: ast.expr) -> ast.Name:\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.copy_location(ast.Name(name, ast.Load()), expr)\n\n    def display(self, expr: ast.expr) -> ast.expr:\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name: str, *args: ast.expr) -> ast.expr:\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast.Call(attr, list(args), [])\n\n    def builtin(self, name: str) -> ast.Attribute:\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewritingHook", "type": "codeblock", "score": 2.375335454940796, "line": 76, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session: Session | None = None\n        self._rewritten_names: dict[str, Path] = {}\n        self._must_rewrite: set[str] = set()\n        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n        # which might result in infinite recursion (#3506)\n        self._writing_pyc = False\n        self._basenames_to_check_rewrite = {\"conftest\"}\n        self._marked_for_rewrite_cache: dict[str, bool] = {}\n        self._session_paths_checked = False\n\n    def set_session(self, session: Session | None) -> None:\n        self.session = session\n        self._session_paths_checked = False\n\n    # Indirection so we can mock calls to find_spec originated from the hook during testing\n    _find_spec = importlib.machinery.PathFinder.find_spec"}], "total_results": 10}
{"repo": "pytest", "query": "StatementInfo docstring flag", "top_10": [{"file": "src/_pytest/doctest.py", "name": "_get_allow_bytes_flag", "type": "codeblock", "score": 3.021470069885254, "line": 663, "text": "def _get_checker() -> doctest.OutputChecker:\n    \"\"\"Return a doctest.OutputChecker subclass that supports some\n    additional options:\n\n    * ALLOW_UNICODE and ALLOW_BYTES options to ignore u'' and b''\n      prefixes (respectively) in string literals. Useful when the same\n      doctest should run in Python 2 and Python 3.\n\n    * NUMBER to ignore floating-point differences smaller than the\n      precision of the literal number in the doctest.\n\n    An inner class is used to avoid importing \"doctest\" at the module\n    level.\n    \"\"\"\n    global CHECKER_CLASS\n    if CHECKER_CLASS is None:\n        CHECKER_CLASS = _init_checker_class()\n    return CHECKER_CLASS()\n\n\ndef _get_allow_unicode_flag() -> int:\n    \"\"\"Register and return the ALLOW_UNICODE flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_UNICODE\")\n\n\ndef _get_allow_bytes_flag() -> int:\n    \"\"\"Register and return the ALLOW_BYTES flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_BYTES\")\n\n\ndef _get_number_flag() -> int:\n    \"\"\"Register and return the NUMBER flag.\"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"NUMBER\")"}, {"file": "src/_pytest/doctest.py", "name": "_get_continue_on_failure", "type": "codeblock", "score": 3.0080575942993164, "line": 401, "text": "def get_optionflags(config: Config) -> int:\n    optionflags_str = config.getini(\"doctest_optionflags\")\n    flag_lookup_table = _get_flag_lookup()\n    flag_acc = 0\n    for flag in optionflags_str:\n        flag_acc |= flag_lookup_table[flag]\n    return flag_acc\n\n\ndef _get_continue_on_failure(config: Config) -> bool:\n    continue_on_failure: bool = config.getvalue(\"doctest_continue_on_failure\")\n    if continue_on_failure:\n        # We need to turn off this if we use pdb since we should stop at\n        # the first failure.\n        if config.getvalue(\"usepdb\"):\n            continue_on_failure = False\n    return continue_on_failure"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "_write_pyc_fp", "type": "codeblock", "score": 2.6399426460266113, "line": 309, "text": "def _write_pyc_fp(\n    fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType\n) -> None:\n    # Technically, we don't have to have the same pyc format as\n    # (C)Python, since these \"pycs\" should never be seen by builtin\n    # import. However, there's little reason to deviate.\n    fp.write(importlib.util.MAGIC_NUMBER)\n    # https://www.python.org/dev/peps/pep-0552/\n    flags = b\"\\x00\\x00\\x00\\x00\"\n    fp.write(flags)\n    # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n    mtime = int(source_stat.st_mtime) & 0xFFFFFFFF\n    size = source_stat.st_size & 0xFFFFFFFF\n    # \"<LL\" stands for 2 unsigned longs, little-endian.\n    fp.write(struct.pack(\"<LL\", mtime, size))\n    fp.write(marshal.dumps(co))"}, {"file": "src/_pytest/config/argparsing.py", "name": "OverrideIniAction", "type": "codeblock", "score": 2.5539920330047607, "line": 520, "text": "class OverrideIniAction(argparse.Action):\n    \"\"\"Custom argparse action that makes a CLI flag equivalent to overriding an\n    option, in addition to behaving like `store_true`.\n\n    This can simplify things since code only needs to inspect the config option\n    and not consider the CLI flag.\n    \"\"\"\n\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        nargs: int | str | None = None,\n        *args,\n        ini_option: str,\n        ini_value: str,\n        **kwargs,\n    ) -> None:\n        super().__init__(option_strings, dest, 0, *args, **kwargs)\n        self.ini_option = ini_option\n        self.ini_value = ini_value\n\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        *args,\n        **kwargs,\n    ) -> None:\n        setattr(namespace, self.dest, True)\n        current_overrides = getattr(namespace, \"override_ini\", None)\n        if current_overrides is None:\n            current_overrides = []\n        current_overrides.append(f\"{self.ini_option}={self.ini_value}\")\n        setattr(namespace, \"override_ini\", current_overrides)"}, {"file": "src/_pytest/doctest.py", "name": "_get_report_choice", "type": "codeblock", "score": 2.31536865234375, "line": 704, "text": "def _get_report_choice(key: str) -> int:\n    \"\"\"Return the actual `doctest` module flag value.\n\n    We want to do it as late as possible to avoid importing `doctest` and all\n    its dependencies when parsing options, as it adds overhead and breaks tests.\n    \"\"\"\n    import doctest\n\n    return {\n        DOCTEST_REPORT_CHOICE_UDIFF: doctest.REPORT_UDIFF,\n        DOCTEST_REPORT_CHOICE_CDIFF: doctest.REPORT_CDIFF,\n        DOCTEST_REPORT_CHOICE_NDIFF: doctest.REPORT_NDIFF,\n        DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE: doctest.REPORT_ONLY_FIRST_FAILURE,\n        DOCTEST_REPORT_CHOICE_NONE: 0,\n    }[key]"}, {"file": "src/_pytest/raises.py", "name": "RaisesGroup.__repr__", "type": "codeblock", "score": 2.121795415878296, "line": 1062, "text": "@final\nclass RaisesGroup(AbstractRaises[BaseExceptionGroup[BaseExcT_co]]):\n\n    def __repr__(self) -> str:\n        reqs = [\n            e.__name__ if isinstance(e, type) else repr(e)\n            for e in self.expected_exceptions\n        ]\n        if self.allow_unwrapped:\n            reqs.append(f\"allow_unwrapped={self.allow_unwrapped}\")\n        if self.flatten_subgroups:\n            reqs.append(f\"flatten_subgroups={self.flatten_subgroups}\")\n        if self.match is not None:\n            # If no flags were specified, discard the redundant re.compile() here.\n            reqs.append(f\"match={_match_pattern(self.match)!r}\")\n        if self.check is not None:\n            reqs.append(f\"check={repr_callable(self.check)}\")\n        return f\"RaisesGroup({', '.join(reqs)})\""}, {"file": "src/_pytest/logging.py", "name": "LoggingPlugin.pytest_runtest_logreport", "type": "codeblock", "score": 1.9580918550491333, "line": 790, "text": "class LoggingPlugin:\n\n    @hookimpl(wrapper=True)\n    def pytest_runtestloop(self, session: Session) -> Generator[None, object, object]:\n        if session.config.option.collectonly:\n            return (yield)\n\n        if self._log_cli_enabled() and self._config.get_verbosity() < 1:\n            # The verbose flag is needed to avoid messy test progress output.\n            self._config.option.verbose = 1\n\n        with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n            with catching_logs(self.log_file_handler, level=self.log_file_level):\n                return (yield)  # Run all the tests.\n\n    @hookimpl\n    def pytest_runtest_logstart(self) -> None:\n        self.log_cli_handler.reset()\n        self.log_cli_handler.set_when(\"start\")\n\n    @hookimpl\n    def pytest_runtest_logreport(self) -> None:\n        self.log_cli_handler.set_when(\"logreport\")"}, {"file": "src/_pytest/raises.py", "name": "RaisesExc.__enter__", "type": "codeblock", "score": 1.8894892930984497, "line": 675, "text": "@final\nclass RaisesExc(AbstractRaises[BaseExcT_co_default]):\n\n    def __repr__(self) -> str:\n        parameters = []\n        if self.expected_exceptions:\n            parameters.append(_exception_type_name(self.expected_exceptions))\n        if self.match is not None:\n            # If no flags were specified, discard the redundant re.compile() here.\n            parameters.append(\n                f\"match={_match_pattern(self.match)!r}\",\n            )\n        if self.check is not None:\n            parameters.append(f\"check={repr_callable(self.check)}\")\n        return f\"RaisesExc({', '.join(parameters)})\"\n\n    def _check_type(self, exception: BaseException) -> TypeGuard[BaseExcT_co_default]:\n        self._fail_reason = _check_raw_type(self.expected_exceptions, exception)\n        return self._fail_reason is None\n\n    def __enter__(self) -> ExceptionInfo[BaseExcT_co_default]:\n        self.excinfo: ExceptionInfo[BaseExcT_co_default] = ExceptionInfo.for_later()\n        return self.excinfo\n\n    # TODO: move common code into superclass"}, {"file": "src/_pytest/raises.py", "name": "raises", "type": "codeblock", "score": 1.840404748916626, "line": 1, "text": "from __future__ import annotations\n\nfrom abc import ABC\nfrom abc import abstractmethod\nimport re\nfrom re import Pattern\nimport sys\nfrom textwrap import indent\nfrom typing import Any\nfrom typing import cast\nfrom typing import final\nfrom typing import Generic\nfrom typing import get_args\nfrom typing import get_origin\nfrom typing import Literal\nfrom typing import overload\nfrom typing import TYPE_CHECKING\nimport warnings\n\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code.code import stringify_exception\nfrom _pytest.outcomes import fail\nfrom _pytest.warning_types import PytestWarning\n\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n    from collections.abc import Sequence\n\n    # for some reason Sphinx does not play well with 'from types import TracebackType'\n    import types\n    from typing import TypeGuard\n\n    from typing_extensions import ParamSpec\n    from typing_extensions import TypeVar\n\n    P = ParamSpec(\"P\")\n\n    # this conditional definition is because we want to allow a TypeVar default\n    BaseExcT_co_default = TypeVar(\n        \"BaseExcT_co_default\",\n        bound=BaseException,\n        default=BaseException,\n        covariant=True,\n    )\n\n    # Use short name because it shows up in docs.\n    E = TypeVar(\"E\", bound=BaseException, default=BaseException)\nelse:\n    from typing import TypeVar\n\n    BaseExcT_co_default = TypeVar(\n        \"BaseExcT_co_default\", bound=BaseException, covariant=True\n    )\n\n# RaisesGroup doesn't work with a default.\nBaseExcT_co = TypeVar(\"BaseExcT_co\", bound=BaseException, covariant=True)\nBaseExcT_1 = TypeVar(\"BaseExcT_1\", bound=BaseException)\nBaseExcT_2 = TypeVar(\"BaseExcT_2\", bound=BaseException)\nExcT_1 = TypeVar(\"ExcT_1\", bound=Exception)\nExcT_2 = TypeVar(\"ExcT_2\", bound=Exception)\n\nif sys.version_info < (3, 11):\n    from exceptiongroup import BaseExceptionGroup\n    from exceptiongroup import ExceptionGroup\n\n\n# String patterns default to including the unicode flag.\n_REGEX_NO_FLAGS = re.compile(r\"\").flags\n\n\n# pytest.raises helper\n@overload\ndef raises(\n    expected_exception: type[E] | tuple[type[E], ...],\n    *,\n    match: str | re.Pattern[str] | None = ...,\n    check: Callable[[E], bool] = ...,\n) -> RaisesExc[E]: ..."}, {"file": "src/_pytest/_py/path.py", "name": "copychunked", "type": "codeblock", "score": 1.8332881927490234, "line": 1437, "text": "def copymode(src, dest):\n    \"\"\"Copy permission from src to dst.\"\"\"\n    import shutil\n\n    shutil.copymode(src, dest)\n\n\ndef copystat(src, dest):\n    \"\"\"Copy permission,  last modification time,\n    last access time, and flags from src to dst.\"\"\"\n    import shutil\n\n    shutil.copystat(str(src), str(dest))\n\n\ndef copychunked(src, dest):\n    chunksize = 524288  # half a meg of bytes\n    fsrc = src.open(\"rb\")\n    try:\n        fdest = dest.open(\"wb\")\n        try:\n            while 1:\n                buf = fsrc.read(chunksize)\n                if not buf:\n                    break\n                fdest.write(buf)\n        finally:\n            fdest.close()\n    finally:\n        fsrc.close()\n\n\ndef isimportable(name):\n    if name and (name[0].isalpha() or name[0] == \"_\"):\n        name = name.replace(\"_\", \"\")\n        return not name or name.isalnum()\n\n\nlocal = LocalPath"}], "total_results": 10}
{"repo": "pytest", "query": "bytecode cache update in rewrite", "top_10": [{"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewritingHook.exec_module", "type": "codeblock", "score": 4.284826278686523, "line": 157, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "_write_pyc_fp", "type": "codeblock", "score": 4.253179550170898, "line": 309, "text": "def _write_pyc_fp(\n    fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType\n) -> None:\n    # Technically, we don't have to have the same pyc format as\n    # (C)Python, since these \"pycs\" should never be seen by builtin\n    # import. However, there's little reason to deviate.\n    fp.write(importlib.util.MAGIC_NUMBER)\n    # https://www.python.org/dev/peps/pep-0552/\n    flags = b\"\\x00\\x00\\x00\\x00\"\n    fp.write(flags)\n    # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n    mtime = int(source_stat.st_mtime) & 0xFFFFFFFF\n    size = source_stat.st_size & 0xFFFFFFFF\n    # \"<LL\" stands for 2 unsigned longs, little-endian.\n    fp.write(struct.pack(\"<LL\", mtime, size))\n    fp.write(marshal.dumps(co))"}, {"file": "src/_pytest/cacheprovider.py", "name": "NFPlugin.__init__", "type": "codeblock", "score": 4.035458087921143, "line": 432, "text": "class NFPlugin:\n    \"\"\"Plugin which implements the --nf (run new-first) option.\"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.active = config.option.newfirst\n        assert config.cache is not None\n        self.cached_nodeids = set(config.cache.get(\"cache/nodeids\", []))\n\n    @hookimpl(wrapper=True, tryfirst=True)\n    def pytest_collection_modifyitems(self, items: list[nodes.Item]) -> Generator[None]:\n        res = yield\n\n        if self.active:\n            new_items: dict[str, nodes.Item] = {}\n            other_items: dict[str, nodes.Item] = {}\n            for item in items:\n                if item.nodeid not in self.cached_nodeids:\n                    new_items[item.nodeid] = item\n                else:\n                    other_items[item.nodeid] = item\n\n            items[:] = self._get_increasing_order(\n                new_items.values()\n            ) + self._get_increasing_order(other_items.values())\n            self.cached_nodeids.update(new_items)\n        else:\n            self.cached_nodeids.update(item.nodeid for item in items)\n\n        return res"}, {"file": "src/_pytest/stepwise.py", "name": "StepwisePlugin.pytest_report_collectionfinish", "type": "codeblock", "score": 3.850343704223633, "line": 198, "text": "class StepwisePlugin:\n\n    def pytest_report_collectionfinish(self) -> list[str] | None:\n        if self.config.get_verbosity() >= 0 and self.report_status:\n            return [f\"stepwise: {x}\" for x in self.report_status]\n        return None\n\n    def pytest_sessionfinish(self) -> None:\n        if hasattr(self.config, \"workerinput\"):\n            # Do not update cache if this process is a xdist worker to prevent\n            # race conditions (#10641).\n            return\n        self.cached_info.update_date_to_now()\n        self.cache.set(STEPWISE_CACHE_DIR, dataclasses.asdict(self.cached_info))"}, {"file": "src/_pytest/stepwise.py", "name": "pytest_sessionfinish", "type": "codeblock", "score": 3.7243459224700928, "line": 53, "text": "def pytest_configure(config: Config) -> None:\n    # --stepwise-skip/--stepwise-reset implies stepwise.\n    if config.option.stepwise_skip or config.option.stepwise_reset:\n        config.option.stepwise = True\n    if config.getoption(\"stepwise\"):\n        config.pluginmanager.register(StepwisePlugin(config), \"stepwiseplugin\")\n\n\ndef pytest_sessionfinish(session: Session) -> None:\n    if not session.config.getoption(\"stepwise\"):\n        assert session.config.cache is not None\n        if hasattr(session.config, \"workerinput\"):\n            # Do not update cache if this process is a xdist worker to prevent\n            # race conditions (#10641).\n            return"}, {"file": "src/_pytest/stepwise.py", "name": "StepwiseCacheInfo.last_cache_date", "type": "codeblock", "score": 3.6932530403137207, "line": 70, "text": "@dataclasses.dataclass\nclass StepwiseCacheInfo:\n    # The nodeid of the last failed test.\n    last_failed: str | None\n\n    # The number of tests in the last time --stepwise was run.\n    # We use this information as a simple way to invalidate the cache information, avoiding\n    # confusing behavior in case the cache is stale.\n    last_test_count: int | None\n\n    # The date when the cache was last updated, for information purposes only.\n    last_cache_date_str: str\n\n    @property\n    def last_cache_date(self) -> datetime:\n        return datetime.fromisoformat(self.last_cache_date_str)\n\n    @classmethod\n    def empty(cls) -> Self:\n        return cls(\n            last_failed=None,\n            last_test_count=None,\n            last_cache_date_str=datetime.now().isoformat(),\n        )\n\n    def update_date_to_now(self) -> None:\n        self.last_cache_date_str = datetime.now().isoformat()"}, {"file": "src/_pytest/assertion/__init__.py", "name": "pytest_addoption", "type": "codeblock", "score": 3.559431552886963, "line": 26, "text": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook. \"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n    parser.addini(\n        \"truncation_limit_lines\",\n        default=None,\n        help=\"Set threshold of LINES after which truncation will take effect\",\n    )\n    parser.addini(\n        \"truncation_limit_chars\",\n        default=None,\n        help=(\"Set threshold of CHARS after which truncation will take effect\"),\n    )\n\n    Config._add_verbosity_ini(\n        parser,\n        Config.VERBOSITY_ASSERTIONS,\n        help=(\n            \"Specify a verbosity level for assertions, overriding the main level. \"\n            \"Higher levels will provide more detailed explanation when an assertion fails.\"\n        ),\n    )"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "get_cache_dir", "type": "codeblock", "score": 3.2976183891296387, "line": 1191, "text": "def get_cache_dir(file_path: Path) -> Path:\n    \"\"\"Return the cache directory to write .pyc files for the given .py file path.\"\"\"\n    if sys.pycache_prefix:\n        # given:\n        #   prefix = '/tmp/pycs'\n        #   path = '/home/user/proj/test_app.py'\n        # we want:\n        #   '/tmp/pycs/home/user/proj'\n        return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])\n    else:\n        # classic pycache directory\n        return file_path.parent / \"__pycache__\""}, {"file": "src/_pytest/cacheprovider.py", "name": "LFPlugin.__init__", "type": "codeblock", "score": 3.227480411529541, "line": 319, "text": "class LFPlugin:\n    \"\"\"Plugin which implements the --lf (run last-failing) option.\"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        active_keys = \"lf\", \"failedfirst\"\n        self.active = any(config.getoption(key) for key in active_keys)\n        assert config.cache\n        self.lastfailed: dict[str, bool] = config.cache.get(\"cache/lastfailed\", {})\n        self._previously_failed_count: int | None = None\n        self._report_status: str | None = None\n        self._skipped_files = 0  # count skipped files during collection due to --lf\n\n        if config.getoption(\"lf\"):\n            self._last_failed_paths = self.get_last_failed_paths()\n            config.pluginmanager.register(\n                LFPluginCollWrapper(self), \"lfplugin-collwrapper\"\n            )\n\n    def get_last_failed_paths(self) -> set[Path]:\n        \"\"\"Return a set with all Paths of the previously failed nodeids and\n        their parents.\"\"\"\n        rootpath = self.config.rootpath\n        result = set()\n        for nodeid in self.lastfailed:\n            path = rootpath / nodeid.split(\"::\")[0]\n            result.add(path)\n            result.update(path.parents)\n        return {x for x in result if x.exists()}\n\n    def pytest_report_collectionfinish(self) -> str | None:\n        if self.active and self.config.get_verbosity() >= 0:\n            return f\"run-last-failure: {self._report_status}\"\n        return None\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        if (report.when == \"call\" and report.passed) or report.skipped:\n            self.lastfailed.pop(report.nodeid, None)\n        elif report.failed:\n            self.lastfailed[report.nodeid] = True\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        passed = report.outcome in (\"passed\", \"skipped\")\n        if passed:\n            if report.nodeid in self.lastfailed:\n                self.lastfailed.pop(report.nodeid)\n                self.lastfailed.update((item.nodeid, True) for item in report.result)\n        else:\n            self.lastfailed[report.nodeid] = True"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "_rewrite_test", "type": "codeblock", "score": 2.9478819370269775, "line": 327, "text": "def _write_pyc(\n    state: AssertionState,\n    co: types.CodeType,\n    source_stat: os.stat_result,\n    pyc: Path,\n) -> bool:\n    proc_pyc = f\"{pyc}.{os.getpid()}\"\n    try:\n        with open(proc_pyc, \"wb\") as fp:\n            _write_pyc_fp(fp, source_stat, co)\n    except OSError as e:\n        state.trace(f\"error writing pyc file at {proc_pyc}: errno={e.errno}\")\n        return False\n\n    try:\n        os.replace(proc_pyc, pyc)\n    except OSError as e:\n        state.trace(f\"error writing pyc file at {pyc}: {e}\")\n        # we ignore any failure to write the cache file\n        # there are many reasons, permission-denied, pycache dir being a\n        # file etc.\n        return False\n    return True\n\n\ndef _rewrite_test(fn: Path, config: Config) -> tuple[os.stat_result, types.CodeType]:\n    \"\"\"Read and rewrite *fn* and return the code object.\"\"\"\n    stat = os.stat(fn)\n    source = fn.read_bytes()\n    strfn = str(fn)\n    tree = ast.parse(source, filename=strfn)\n    rewrite_asserts(tree, source, strfn, config)\n    co = compile(tree, strfn, \"exec\", dont_inherit=True)\n    return stat, co"}], "total_results": 10}
{"repo": "pytest", "query": "ensure docstring nodes are strings", "top_10": [{"file": "src/_pytest/_py/path.py", "name": "LocalPath.ensure_dir", "type": "codeblock", "score": 2.9832940101623535, "line": 450, "text": "class LocalPath:\n\n    def ensure_dir(self, *args):\n        \"\"\"Ensure the path joined with args is a directory.\"\"\"\n        return self.ensure(*args, dir=True)\n\n    def bestrelpath(self, dest):\n        \"\"\"Return a string which is a relative path from self\n        (assumed to be a directory) to dest such that\n        self.join(bestrelpath) == dest and if not such\n        path can be determined return dest.\n        \"\"\"\n        try:\n            if self == dest:\n                return os.curdir\n            base = self.common(dest)\n            if not base:  # can be the case on windows\n                return str(dest)\n            self2base = self.relto(base)\n            reldest = dest.relto(base)\n            if self2base:\n                n = self2base.count(self.sep) + 1\n            else:\n                n = 0\n            lst = [os.pardir] * n\n            if reldest:\n                lst.append(reldest)\n            target = dest.sep.join(lst)\n            return target\n        except AttributeError:\n            return str(dest)"}, {"file": "testing/python/collect.py", "name": "TestModule.test_import_duplicate", "type": "codeblock", "score": 2.878136157989502, "line": 1, "text": "# mypy: allow-untyped-defs\nfrom __future__ import annotations\n\nimport os\nimport sys\nimport textwrap\nfrom typing import Any\n\nimport _pytest._code\nfrom _pytest.config import ExitCode\nfrom _pytest.main import Session\nfrom _pytest.monkeypatch import MonkeyPatch\nfrom _pytest.nodes import Collector\nfrom _pytest.pytester import Pytester\nfrom _pytest.python import Class\nfrom _pytest.python import Function\nimport pytest\n\n\nclass TestModule:\n    def test_failing_import(self, pytester: Pytester) -> None:\n        modcol = pytester.getmodulecol(\"import alksdjalskdjalkjals\")\n        pytest.raises(Collector.CollectError, modcol.collect)\n\n    def test_import_duplicate(self, pytester: Pytester) -> None:\n        a = pytester.mkdir(\"a\")\n        b = pytester.mkdir(\"b\")\n        p1 = a.joinpath(\"test_whatever.py\")\n        p1.touch()\n        p2 = b.joinpath(\"test_whatever.py\")\n        p2.touch()\n        # ensure we don't have it imported already\n        sys.modules.pop(p1.stem, None)\n\n        result = pytester.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*import*mismatch*\",\n                \"*imported*test_whatever*\",\n                f\"*{p1}*\",\n                \"*not the same*\",\n                f\"*{p2}*\",\n                \"*HINT*\",\n            ]\n        )"}, {"file": "src/_pytest/capture.py", "name": "EncodedFile", "type": "codeblock", "score": 2.811217784881592, "line": 183, "text": "# IO Helpers.\n\n\nclass EncodedFile(io.TextIOWrapper):\n    __slots__ = ()\n\n    @property\n    def name(self) -> str:\n        # Ensure that file.name is a string. Workaround for a Python bug\n        # fixed in >=3.7.4: https://bugs.python.org/issue36015\n        return repr(self.buffer)\n\n    @property\n    def mode(self) -> str:\n        # TextIOWrapper doesn't expose a mode, but at least some of our\n        # tests check it.\n        assert hasattr(self.buffer, \"mode\")\n        return cast(str, self.buffer.mode.replace(\"b\", \"\"))"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.pop_format_context", "type": "codeblock", "score": 2.7658519744873047, "line": 828, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an str ast.expr instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .expl_stmts and\n        return the ast.Name instance of the formatted string.\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys: list[ast.expr | None] = [ast.Constant(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        if self.enable_assertion_pass_hook:\n            self.format_variables.append(name)\n        self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node: ast.AST) -> tuple[ast.Name, str]:\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))"}, {"file": "src/_pytest/_py/path.py", "name": "LocalPath.dump", "type": "codeblock", "score": 2.7513675689697266, "line": 871, "text": "class LocalPath:\n\n    def rename(self, target):\n        \"\"\"Rename this path to target.\"\"\"\n        target = os.fspath(target)\n        return error.checked_call(os.rename, self.strpath, target)\n\n    def dump(self, obj, bin=1):\n        \"\"\"Pickle object into path location\"\"\"\n        f = self.open(\"wb\")\n        import pickle\n\n        try:\n            error.checked_call(pickle.dump, obj, f, bin)\n        finally:\n            f.close()\n\n    def mkdir(self, *args):\n        \"\"\"Create & return the directory joined with args.\"\"\"\n        p = self.join(*args)\n        error.checked_call(os.mkdir, os.fspath(p))\n        return p\n\n    def write_binary(self, data, ensure=False):\n        \"\"\"Write binary data into path.   If ensure is True create\n        missing parent directories.\n        \"\"\"\n        if ensure:\n            self.dirpath().ensure(dir=1)\n        with self.open(\"wb\") as f:\n            f.write(data)\n\n    def write_text(self, data, encoding, ensure=False):\n        \"\"\"Write text data into path using the specified encoding.\n        If ensure is True create missing parent directories.\n        \"\"\"\n        if ensure:\n            self.dirpath().ensure(dir=1)\n        with self.open(\"w\", encoding=encoding) as f:\n            f.write(data)"}, {"file": "src/_pytest/nodes.py", "name": "Node.teardown", "type": "codeblock", "score": 2.7503483295440674, "line": 278, "text": "class Node(abc.ABC, metaclass=NodeMeta):\n\n    # Methods for ordering nodes.\n\n    @property\n    def nodeid(self) -> str:\n        \"\"\"A ::-separated string denoting its collection tree address.\"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def iter_parents(self) -> Iterator[Node]:\n        \"\"\"Iterate over all parent collectors starting from and including self\n        up to the root of the collection tree.\n\n        .. versionadded:: 8.1\n        \"\"\"\n        parent: Node | None = self\n        while parent is not None:\n            yield parent\n            parent = parent.parent\n\n    def listchain(self) -> list[Node]:\n        \"\"\"Return a list of all parent collectors starting from the root of the\n        collection tree down to and including self.\"\"\"\n        chain = []\n        item: Node | None = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain"}, {"file": "src/_pytest/fixtures.py", "name": "get_scope_package", "type": "codeblock", "score": 2.714078426361084, "line": 85, "text": "FixtureValue = TypeVar(\"FixtureValue\", covariant=True)\n# The type of the fixture function (type variable).\nFixtureFunction = TypeVar(\"FixtureFunction\", bound=Callable[..., object])\n# The type of a fixture function (type alias generic in fixture value).\n_FixtureFunc = Callable[..., FixtureValue] | Callable[..., Generator[FixtureValue]]\n# The type of FixtureDef.cached_result (type alias generic in fixture value).\n_FixtureCachedResult = (\n    tuple[\n        # The result.\n        FixtureValue,\n        # Cache key.\n        object,\n        None,\n    ]\n    | tuple[\n        None,\n        # Cache key.\n        object,\n        # The exception and the original traceback.\n        tuple[BaseException, types.TracebackType | None],\n    ]\n)\n\n\ndef pytest_sessionstart(session: Session) -> None:\n    session._fixturemanager = FixtureManager(session)\n\n\ndef get_scope_package(\n    node: nodes.Item,\n    fixturedef: FixtureDef[object],\n) -> nodes.Node | None:\n    from _pytest.python import Package\n\n    for parent in node.iter_parents():\n        if isinstance(parent, Package) and parent.nodeid == fixturedef.baseid:\n            return parent\n    return node.session"}, {"file": "src/_pytest/nodes.py", "name": "Node.add_marker", "type": "codeblock", "score": 2.7032437324523926, "line": 316, "text": "class Node(abc.ABC, metaclass=NodeMeta):\n\n    def add_marker(self, marker: str | MarkDecorator, append: bool = True) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)"}, {"file": "src/_pytest/_py/path.py", "name": "LocalPath.write", "type": "codeblock", "score": 2.658447027206421, "line": 910, "text": "class LocalPath:\n\n    def write(self, data, mode=\"w\", ensure=False):\n        \"\"\"Write data into path.   If ensure is True create\n        missing parent directories.\n        \"\"\"\n        if ensure:\n            self.dirpath().ensure(dir=1)\n        if \"b\" in mode:\n            if not isinstance(data, bytes):\n                raise ValueError(\"can only process bytes\")\n        else:\n            if not isinstance(data, str):\n                if not isinstance(data, bytes):\n                    data = str(data)\n                else:\n                    data = data.decode(sys.getdefaultencoding())\n        f = self.open(mode)\n        try:\n            f.write(data)\n        finally:\n            f.close()"}, {"file": "src/_pytest/_py/path.py", "name": "LocalPath.open", "type": "codeblock", "score": 2.5736992359161377, "line": 749, "text": "class LocalPath:\n\n    def open(self, mode=\"r\", ensure=False, encoding=None):\n        \"\"\"Return an opened file with the given mode.\n\n        If ensure is True, create parent directories if needed.\n        \"\"\"\n        if ensure:\n            self.dirpath().ensure(dir=1)\n        if encoding:\n            return error.checked_call(\n                io.open,\n                self.strpath,\n                mode,\n                encoding=encoding,\n            )\n        return error.checked_call(open, self.strpath, mode)\n\n    def _fastjoin(self, name):\n        child = object.__new__(self.__class__)\n        child.strpath = self.strpath + self.sep + name\n        return child\n\n    def islink(self):\n        return islink(self.strpath)"}], "total_results": 10}
{"repo": "pytest", "query": "ast walk in _pytest/rewrite", "top_10": [{"file": "src/_pytest/_code/source.py", "name": "get_statement_startend2", "type": "codeblock", "score": 5.996919631958008, "line": 153, "text": "def get_statement_startend2(lineno: int, node: ast.AST) -> tuple[int, int | None]:\n    # Flatten all statements and except handlers into one lineno-list.\n    # AST's line numbers start indexing at 1.\n    values: list[int] = []\n    for x in ast.walk(node):\n        if isinstance(x, ast.stmt | ast.ExceptHandler):\n            # The lineno points to the class/def, so need to include the decorators.\n            if isinstance(x, ast.ClassDef | ast.FunctionDef | ast.AsyncFunctionDef):\n                for d in x.decorator_list:\n                    values.append(d.lineno - 1)\n            values.append(x.lineno - 1)\n            for name in (\"finalbody\", \"orelse\"):\n                val: list[ast.stmt] | None = getattr(x, name, None)\n                if val:\n                    # Treat the finally/orelse part as its own statement.\n                    values.append(val[0].lineno - 1 - 1)\n    values.sort()\n    insert_index = bisect_right(values, lineno)\n    start = values[insert_index - 1]\n    if insert_index >= len(values):\n        end = None\n    else:\n        end = values[insert_index]\n    return start, end"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 5.528176307678223, "line": 854, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            import warnings\n\n            from _pytest.warning_types import PytestAssertRewriteWarning\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: list[ast.stmt] = []\n        self.variables: list[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: list[str] = []\n\n        self.stack: list[dict[str, ast.expr]] = []\n        self.expl_stmts: list[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.run", "type": "codeblock", "score": 5.288414478302002, "line": 692, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        for item in mod.body:\n            match item:\n                case ast.Expr(value=ast.Constant(value=str() as doc)) if (\n                    expect_docstring\n                ):\n                    if self.is_rewrite_disabled(doc):\n                        return\n                    expect_docstring = False\n                case ast.ImportFrom(level=0, module=\"__future__\"):\n                    pass\n                case _:\n                    break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n            ast.alias(\n                \"_pytest.assertion.rewrite\",\n                \"@pytest_ar\",\n                lineno=lineno,\n                col_offset=0,\n            ),\n        ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        self.scope = (mod,)\n        nodes: list[ast.AST | Sentinel] = [mod]\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Compare", "type": "codeblock", "score": 5.275226593017578, "line": 1151, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Compare(self, comp: ast.Compare) -> tuple[ast.expr, str]:\n        # ... other code\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res: ast.expr = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n\n        return res, self.explanation_param(self.pop_format_context(expl_call))"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Name", "type": "codeblock", "score": 5.159682273864746, "line": 987, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Name(self, name: ast.Name) -> tuple[ast.Name, str]:\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_NamedExpr", "type": "codeblock", "score": 5.0935516357421875, "line": 975, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_NamedExpr(self, name: ast.NamedExpr) -> tuple[ast.NamedExpr, str]:\n        # This method handles the 'walrus operator' repr of the target\n        # name if it's a local variable or _should_repr_global_name()\n        # thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        target_id = name.target.id\n        inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))\n        return name, self.explanation_param(expr)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.__init__", "type": "codeblock", "score": 4.946415901184082, "line": 674, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def __init__(\n        self, module_path: str | None, config: Config | None, source: bytes\n    ) -> None:\n        super().__init__()\n        self.module_path = module_path\n        self.config = config\n        if config is not None:\n            self.enable_assertion_pass_hook = config.getini(\n                \"enable_assertion_pass_hook\"\n            )\n        else:\n            self.enable_assertion_pass_hook = False\n        self.source = source\n        self.scope: tuple[ast.AST, ...] = ()\n        self.variables_overwrite: defaultdict[tuple[ast.AST, ...], dict[str, str]] = (\n            defaultdict(dict)\n        )"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "traverse_node", "type": "codeblock", "score": 4.9354658126831055, "line": 513, "text": "def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:\n    if util._assertion_pass is not None:\n        util._assertion_pass(lineno, orig, expl)\n\n\ndef _check_if_assertion_pass_impl() -> bool:\n    \"\"\"Check if any plugins implement the pytest_assertion_pass hook\n    in order not to generate explanation unnecessarily (might be expensive).\"\"\"\n    return True if util._assertion_pass else False\n\n\nUNARY_MAP = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\n\nBINOP_MAP = {\n    ast.BitOr: \"|\",\n    ast.BitXor: \"^\",\n    ast.BitAnd: \"&\",\n    ast.LShift: \"<<\",\n    ast.RShift: \">>\",\n    ast.Add: \"+\",\n    ast.Sub: \"-\",\n    ast.Mult: \"*\",\n    ast.Div: \"/\",\n    ast.FloorDiv: \"//\",\n    ast.Mod: \"%%\",  # escaped for string formatting\n    ast.Eq: \"==\",\n    ast.NotEq: \"!=\",\n    ast.Lt: \"<\",\n    ast.LtE: \"<=\",\n    ast.Gt: \">\",\n    ast.GtE: \">=\",\n    ast.Pow: \"**\",\n    ast.Is: \"is\",\n    ast.IsNot: \"is not\",\n    ast.In: \"in\",\n    ast.NotIn: \"not in\",\n    ast.MatMult: \"@\",\n}\n\n\ndef traverse_node(node: ast.AST) -> Iterator[ast.AST]:\n    \"\"\"Recursively yield node and all its children in depth-first order.\"\"\"\n    yield node\n    for child in ast.iter_child_nodes(node):\n        yield from traverse_node(child)"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter.visit_Assert", "type": "codeblock", "score": 4.916080474853516, "line": 893, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_: ast.Assert) -> list[ast.stmt]:\n        # ... other code\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Constant(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Constant(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Constant(assert_.lineno),\n                    ast.Constant(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                [*self.expl_stmts, hook_call_pass],\n                [],\n            )\n            statements_pass: list[ast.stmt] = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables: list[ast.expr] = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.Constant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Constant(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n        # ... other code"}, {"file": "src/_pytest/assertion/rewrite.py", "name": "AssertionRewriter", "type": "codeblock", "score": 4.913006782531738, "line": 615, "text": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false and calls pytest_assertion_pass hook\n    if expression is true.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :expl_stmts: The AST statements which will be executed to get\n       data from the assertion.  This is the code which will construct\n       the detailed assertion message that is used in the AssertionError\n       or for the pytest_assertion_pass hook.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    :scope: A tuple containing the current scope used for variables_overwrite.\n\n    :variables_overwrite: A dict filled with references to variables\n       that change value within an assert. This happens when a variable is\n       reassigned with the walrus operator\n\n    This state, except the variables_overwrite,  is reset on every new assert\n    statement visited and used by the other visitors.\n    \"\"\""}], "total_results": 10}
