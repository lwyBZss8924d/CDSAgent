{"repo": "matplotlib", "query": "matplotlib __version__ defined in __init__", "top_10": [{"file": "lib/matplotlib/__init__.py", "name": "_check_versions", "type": "codeblock", "score": 5.050691604614258, "line": 239, "text": "@_api.caching_module_getattr\nclass __getattr__:\n    __version__ = property(lambda self: _get_version())\n    __version_info__ = property(\n        lambda self: _parse_to_version_info(self.__version__))\n\n\ndef _check_versions():\n\n    # Quickfix to ensure Microsoft Visual C++ redistributable\n    # DLLs are loaded before importing kiwisolver\n    from . import ft2font  # noqa: F401\n\n    for modname, minver in [\n            (\"cycler\", \"0.10\"),\n            (\"dateutil\", \"2.7\"),\n            (\"kiwisolver\", \"1.3.1\"),\n            (\"numpy\", \"1.25\"),\n            (\"pyparsing\", \"2.3.1\"),\n    ]:\n        module = importlib.import_module(modname)\n        if parse_version(module.__version__) < parse_version(minver):\n            raise ImportError(f\"Matplotlib requires {modname}>={minver}; \"\n                              f\"you have {module.__version__}\")"}, {"file": "lib/matplotlib/__init__.py", "name": "_rc_params_in_file", "type": "codeblock", "score": 4.249108791351318, "line": 912, "text": "def _rc_params_in_file(fname, transform=lambda x: x, fail_on_error=False):\n    # ... other code\n\n    for key, (val, line, line_no) in rc_temp.items():\n        if key in rcsetup._validators:\n            if fail_on_error:\n                config[key] = val  # try to convert to proper type or raise\n            else:\n                try:\n                    config[key] = val  # try to convert to proper type or skip\n                except Exception as msg:\n                    _log.warning('Bad value in file %r, line %d (%r): %s',\n                                 fname, line_no, line.rstrip('\\n'), msg)\n        else:\n            # __version__ must be looked up as an attribute to trigger the\n            # module-level __getattr__.\n            version = ('main' if '.post' in mpl.__version__\n                       else f'v{mpl.__version__}')\n            _log.warning(\"\"\"\nBad key %(key)s in file %(fname)s, line %(line_no)s (%(line)r)\nYou probably need to get an updated matplotlibrc file from\nhttps://github.com/matplotlib/matplotlib/blob/%(version)s/lib/matplotlib/mpl-data/matplotlibrc\nor from the matplotlib source distribution\"\"\",\n                         dict(key=key, fname=fname, line_no=line_no,\n                              line=line.rstrip('\\n'), version=version))\n    return config"}, {"file": "lib/matplotlib/backends/qt_compat.py", "name": "_setup_pyqt5plus", "type": "codeblock", "score": 3.9164371490478516, "line": 66, "text": "def _setup_pyqt5plus():\n    global QtCore, QtGui, QtWidgets, QtSvg, __version__\n    global _isdeleted, _to_int\n\n    if QT_API == QT_API_PYQT6:\n        from PyQt6 import QtCore, QtGui, QtWidgets, sip, QtSvg\n        __version__ = QtCore.PYQT_VERSION_STR\n        QtCore.Signal = QtCore.pyqtSignal\n        QtCore.Slot = QtCore.pyqtSlot\n        QtCore.Property = QtCore.pyqtProperty\n        _isdeleted = sip.isdeleted\n        _to_int = operator.attrgetter('value')\n    elif QT_API == QT_API_PYSIDE6:\n        from PySide6 import QtCore, QtGui, QtWidgets, QtSvg, __version__\n        import shiboken6\n        def _isdeleted(obj): return not shiboken6.isValid(obj)\n        if parse_version(__version__) >= parse_version('6.4'):\n            _to_int = operator.attrgetter('value')\n        else:\n            _to_int = int\n    elif QT_API == QT_API_PYQT5:\n        from PyQt5 import QtCore, QtGui, QtWidgets, QtSvg\n        import sip\n        __version__ = QtCore.PYQT_VERSION_STR\n        QtCore.Signal = QtCore.pyqtSignal\n        QtCore.Slot = QtCore.pyqtSlot\n        QtCore.Property = QtCore.pyqtProperty\n        _isdeleted = sip.isdeleted\n        _to_int = int\n    elif QT_API == QT_API_PYSIDE2:\n        from PySide2 import QtCore, QtGui, QtWidgets, QtSvg, __version__\n        try:\n            from PySide2 import shiboken2\n        except ImportError:\n            import shiboken2\n        def _isdeleted(obj):\n            return not shiboken2.isValid(obj)\n        _to_int = int\n    else:\n        raise AssertionError(f\"Unexpected QT_API: {QT_API}\")"}, {"file": "lib/matplotlib/backends/backend_pdf.py", "name": "_create_pdf_info_dict", "type": "codeblock", "score": 3.8078794479370117, "line": 117, "text": "def _create_pdf_info_dict(backend, metadata):\n    \"\"\"\n    Create a PDF infoDict based on user-supplied metadata.\n\n    A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though\n    the user metadata may override it. The date may be the current time, or a\n    time set by the ``SOURCE_DATE_EPOCH`` environment variable.\n\n    Metadata is verified to have the correct keys and their expected types. Any\n    unknown keys/types will raise a warning.\n\n    Parameters\n    ----------\n    backend : str\n        The name of the backend to use in the Producer value.\n\n    metadata : dict[str, Union[str, datetime, Name]]\n        A dictionary of metadata supplied by the user with information\n        following the PDF specification, also defined in\n        `~.backend_pdf.PdfPages` below.\n\n        If any value is *None*, then the key will be removed. This can be used\n        to remove any pre-defined values.\n\n    Returns\n    -------\n    dict[str, Union[str, datetime, Name]]\n        A validated dictionary of metadata.\n    \"\"\"\n\n    # get source date from SOURCE_DATE_EPOCH, if set\n    # See https://reproducible-builds.org/specs/source-date-epoch/\n    source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n    if source_date_epoch:\n        source_date = datetime.fromtimestamp(int(source_date_epoch), timezone.utc)\n        source_date = source_date.replace(tzinfo=UTC)\n    else:\n        source_date = datetime.today()\n\n    info = {\n        'Creator': f'Matplotlib v{mpl.__version__}, https://matplotlib.org',\n        'Producer': f'Matplotlib {backend} backend v{mpl.__version__}',\n        'CreationDate': source_date,\n        **metadata\n    }\n    info = {k: v for (k, v) in info.items() if v is not None}\n\n    def is_string_like(x):\n        return isinstance(x, str)\n    is_string_like.text_for_warning = \"an instance of str\"\n\n    def is_date(x):\n        return isinstance(x, datetime)\n    is_date.text_for_warning = \"an instance of datetime.datetime\"\n\n    def check_trapped(x):\n        if isinstance(x, Name):\n            return x.name in (b'True', b'False', b'Unknown')\n        else:\n            return x in ('True', 'False', 'Unknown')\n    check_trapped.text_for_warning = 'one of {\"True\", \"False\", \"Unknown\"}'\n    # ... other code"}, {"file": "ci/check_version_number.py", "name": "docstring", "type": "codeblock", "score": 3.6112661361694336, "line": 1, "text": "#!/usr/bin/env python3\n\n\"\"\"\nCheck that the version number of the install Matplotlib does not start with 0\n\nTo run:\n    $ python3 -m build .\n    $ pip install dist/matplotlib*.tar.gz for sdist\n    $ pip install dist/matplotlib*.whl for wheel\n    $ ./ci/check_version_number.py\n\"\"\"\nimport sys\n\nimport matplotlib\n\n\nprint(f\"Version {matplotlib.__version__} installed\")\nif matplotlib.__version__[0] == \"0\":\n    sys.exit(\"Version incorrectly starts with 0\")"}, {"file": "lib/matplotlib/font_manager.py", "name": "impl:31", "type": "codeblock", "score": 3.4228506088256836, "line": 1647, "text": "def _load_fontmanager(*, try_read_cache=True):\n    fm_path = Path(\n        mpl.get_cachedir(), f\"fontlist-v{FontManager.__version__}.json\")\n    if try_read_cache:\n        try:\n            fm = json_load(fm_path)\n        except Exception:\n            pass\n        else:\n            if getattr(fm, \"_version\", object()) == FontManager.__version__:\n                _log.debug(\"Using fontManager instance from %s\", fm_path)\n                return fm\n    fm = FontManager()\n    json_dump(fm, fm_path)\n    _log.info(\"generated new fontManager\")\n    return fm\n\n\nfontManager = _load_fontmanager()\nfindfont = fontManager.findfont\nget_font_names = fontManager.get_font_names"}, {"file": "lib/matplotlib/__init__.py", "name": "_get_version", "type": "codeblock", "score": 3.3328189849853516, "line": 213, "text": "def _get_version():\n    \"\"\"Return the version string used for __version__.\"\"\"\n    # Only shell out to a git subprocess if really needed, i.e. when we are in\n    # a matplotlib git repo but not in a shallow clone, such as those used by\n    # CI, as the latter would trigger a warning from setuptools_scm.\n    root = Path(__file__).resolve().parents[2]\n    if ((root / \".matplotlib-repo\").exists()\n            and (root / \".git\").exists()\n            and not (root / \".git/shallow\").exists()):\n        try:\n            import setuptools_scm\n        except ImportError:\n            pass\n        else:\n            return setuptools_scm.get_version(\n                root=root,\n                dist_name=\"matplotlib\",\n                version_scheme=\"release-branch-semver\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n    # Get the version from the _version.py file if not in repo or setuptools_scm is\n    # unavailable.\n    return _version.version"}, {"file": "lib/matplotlib/font_manager.py", "name": "FontManager.__init__", "type": "codeblock", "score": 3.3207077980041504, "line": 1074, "text": "class FontManager:\n\n    def __init__(self, size=None, weight='normal'):\n        self._version = self.__version__\n\n        self.__default_weight = weight\n        self.default_size = size\n\n        # Create list of font paths.\n        paths = [cbook._get_data_path('fonts', subdir)\n                 for subdir in ['ttf', 'afm', 'pdfcorefonts']]\n        _log.debug('font search path %s', paths)\n\n        self.defaultFamily = {\n            'ttf': 'DejaVu Sans',\n            'afm': 'Helvetica'}\n\n        self.afmlist = []\n        self.ttflist = []\n\n        # Delay the warning by 5s.\n        timer = threading.Timer(5, lambda: _log.warning(\n            'Matplotlib is building the font cache; this may take a moment.'))\n        timer.start()\n        try:\n            for fontext in [\"afm\", \"ttf\"]:\n                for path in [*findSystemFonts(paths, fontext=fontext),\n                             *findSystemFonts(fontext=fontext)]:\n                    try:\n                        self.addfont(path)\n                    except OSError as exc:\n                        _log.info(\"Failed to open font file %s: %s\", path, exc)\n                    except Exception as exc:\n                        _log.info(\"Failed to extract font properties from %s: \"\n                                  \"%s\", path, exc)\n        finally:\n            timer.cancel()"}, {"file": "lib/matplotlib/__init__.py", "name": "matplotlib_fname", "type": "codeblock", "score": 3.232304573059082, "line": 616, "text": "def matplotlib_fname():\n    \"\"\"\n    Get the location of the config file.\n\n    The file location is determined in the following order\n\n    - ``$PWD/matplotlibrc``\n    - ``$MATPLOTLIBRC`` if it is not a directory\n    - ``$MATPLOTLIBRC/matplotlibrc``\n    - ``$MPLCONFIGDIR/matplotlibrc``\n    - On Linux,\n        - ``$XDG_CONFIG_HOME/matplotlib/matplotlibrc`` (if ``$XDG_CONFIG_HOME``\n          is defined)\n        - or ``$HOME/.config/matplotlib/matplotlibrc`` (if ``$XDG_CONFIG_HOME``\n          is not defined)\n    - On other platforms,\n      - ``$HOME/.matplotlib/matplotlibrc`` if ``$HOME`` is defined\n    - Lastly, it looks in ``$MATPLOTLIBDATA/matplotlibrc``, which should always\n      exist.\n    \"\"\"\n    # ... other code"}, {"file": "lib/matplotlib/backend_bases.py", "name": "Event", "type": "codeblock", "score": 3.110288619995117, "line": 1170, "text": "class Event:\n    \"\"\"\n    A Matplotlib event.\n\n    The following attributes are defined and shown with their default values.\n    Subclasses may define additional attributes.\n\n    Attributes\n    ----------\n    name : str\n        The event name.\n    canvas : `FigureCanvasBase`\n        The backend-specific canvas instance generating the event.\n    guiEvent\n        The GUI event that triggered the Matplotlib event.\n    \"\"\"\n\n    def __init__(self, name, canvas, guiEvent=None):\n        self.name = name\n        self.canvas = canvas\n        self.guiEvent = guiEvent\n\n    def _process(self):\n        \"\"\"Process this event on ``self.canvas``, then unset ``guiEvent``.\"\"\"\n        self.canvas.callbacks.process(self.name, self)\n        self.guiEvent = None"}], "total_results": 10}
{"repo": "matplotlib", "query": "top-level version banner text", "top_10": [{"file": "doc/conf.py", "name": "add_html_cache_busting", "type": "codeblock", "score": 5.986423492431641, "line": 512, "text": "# The style sheet to use for HTML and HTML Help pages. A file of that name\n# must exist either in Sphinx' static/ path, or in one of the custom paths\n# given in html_static_path.\nhtml_css_files = [\n    \"mpl.css\",\n]\n\nhtml_theme = \"mpl_sphinx_theme\"\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# The name of an image file (within the static path) to place at the top of\n# the sidebar.\nhtml_theme_options = {\n    \"navbar_links\": \"internal\",\n    # collapse_navigation in pydata-sphinx-theme is slow, so skipped for local\n    # and CI builds https://github.com/pydata/pydata-sphinx-theme/pull/386\n    \"collapse_navigation\": not is_release_build,\n    \"show_prev_next\": False,\n    \"switcher\": {\n        # Add a unique query to the switcher.json url.  This will be ignored by\n        # the server, but will be used as part of the key for caching by browsers\n        # so when we do a new meso release the switcher will update \"promptly\" on\n        # the stable and devdocs.\n        \"json_url\": (\n            \"https://output.circle-artifacts.com/output/job/\"\n            f\"{os.environ['CIRCLE_WORKFLOW_JOB_ID']}/artifacts/\"\n            f\"{os.environ['CIRCLE_NODE_INDEX']}\"\n            \"/doc/build/html/_static/switcher.json\" if CIRCLECI and not DEVDOCS else\n            f\"https://matplotlib.org/devdocs/_static/switcher.json?{SHA}\"\n        ),\n        \"version_match\": (\n            matplotlib.__version__\n            if matplotlib.__version_info__.releaselevel == 'final'\n            else 'dev')\n    },\n    \"navbar_end\": [\"theme-switcher\", \"version-switcher\", \"mpl_icon_links\"],\n    \"navbar_persistent\": [\"search-button\"],\n    \"footer_start\": [\"copyright\", \"sphinx-version\", \"doc_version\"],\n    # We override the announcement template from pydata-sphinx-theme, where\n    # this special value indicates the use of the unreleased banner. If we need\n    # an actual announcement, then just place the text here as usual.\n    \"announcement\": \"unreleased\" if not is_release_build else \"\",\n    \"show_version_warning_banner\": True,\n}"}, {"file": "galleries/examples/lines_bars_and_markers/timeline.py", "name": "impl:39", "type": "codeblock", "score": 4.704856872558594, "line": 51, "text": "dates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]  # Convert strs to dates.\nreleases = [tuple(release.split('.')) for release in releases]  # Split by component.\ndates, releases = zip(*sorted(zip(dates, releases)))  # Sort by increasing date.\n\n# %%\n# Next, we'll create a stem plot with some variation in levels as to\n# distinguish even close-by events. We add markers on the baseline for visual\n# emphasis on the one-dimensional nature of the timeline.\n#\n# For each event, we add a text label via `~.Axes.annotate`, which is offset\n# in units of points from the tip of the event line.\n#\n# Note that Matplotlib will automatically plot datetime inputs.\n\n# Choose some nice levels: alternate meso releases between top and bottom, and\n# progressively shorten the stems for micro releases.\nlevels = []\nmacro_meso_releases = sorted({release[:2] for release in releases})\nfor release in releases:\n    macro_meso = release[:2]\n    micro = int(release[2])\n    h = 1 + 0.8 * (5 - micro)\n    level = h if macro_meso_releases.index(macro_meso) % 2 == 0 else -h\n    levels.append(level)\n\n\ndef is_feature(release):\n    \"\"\"Return whether a version (split into components) is a feature release.\"\"\"\n    return release[-1] == '0'\n\n\n# The figure and the axes.\nfig, ax = plt.subplots(figsize=(8.8, 4), layout=\"constrained\")\nax.set(title=\"Matplotlib release dates\")\n\n# The vertical stems.\nax.vlines(dates, 0, levels,\n          color=[(\"tab:red\", 1 if is_feature(release) else .5) for release in releases])\n# The baseline.\nax.axhline(0, c=\"black\")\n# The markers on the baseline.\nmeso_dates = [date for date, release in zip(dates, releases) if is_feature(release)]\nmicro_dates = [date for date, release in zip(dates, releases)\n               if not is_feature(release)]\nax.plot(micro_dates, np.zeros_like(micro_dates), \"ko\", mfc=\"white\")\nax.plot(meso_dates, np.zeros_like(meso_dates), \"ko\", mfc=\"tab:red\")\n\n# Annotate the lines."}, {"file": "lib/matplotlib/axes/_base.py", "name": "_AxesBase.set_ylabel", "type": "codeblock", "score": 4.684225559234619, "line": 3876, "text": "@_api.define_aliases({\"facecolor\": [\"fc\"]})\nclass _AxesBase(martist.Artist):\n\n    def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,\n                   loc=None, **kwargs):\n        \"\"\"\n        Set the label for the y-axis.\n\n        Parameters\n        ----------\n        ylabel : str\n            The label text.\n\n        labelpad : float, default: :rc:`axes.labelpad`\n            Spacing in points from the Axes bounding box including ticks\n            and tick labels.  If None, the previous value is left as is.\n\n        loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`\n            The label position. This is a high-level alternative for passing\n            parameters *y* and *horizontalalignment*.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~matplotlib.text.Text` properties\n            `.Text` properties control the appearance of the label.\n\n        See Also\n        --------\n        text : Documents the properties supported by `.Text`.\n        \"\"\"\n        if labelpad is not None:\n            self.yaxis.labelpad = labelpad\n        protected_kw = ['y', 'horizontalalignment', 'ha']\n        if {*kwargs} & {*protected_kw}:\n            if loc is not None:\n                raise TypeError(f\"Specifying 'loc' is disallowed when any of \"\n                                f\"its corresponding low level keyword \"\n                                f\"arguments ({protected_kw}) are also \"\n                                f\"supplied\")\n\n        else:\n            loc = mpl._val_or_rc(loc, 'yaxis.labellocation')\n            _api.check_in_list(('bottom', 'center', 'top'), loc=loc)\n\n            y, ha = {\n                'bottom': (0, 'left'),\n                'center': (0.5, 'center'),\n                'top': (1, 'right')\n            }[loc]\n            kwargs.update(y=y, horizontalalignment=ha)\n\n        return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)"}, {"file": "lib/matplotlib/pyplot.py", "name": "clabel", "type": "codeblock", "score": 4.218583106994629, "line": 3240, "text": "# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Axes.broken_barh)\ndef broken_barh(\n    xranges: Sequence[tuple[float, float]],\n    yrange: tuple[float, float],\n    align: Literal[\"bottom\", \"center\", \"top\"] = \"bottom\",\n    *,\n    data=None,\n    **kwargs,\n) -> PolyCollection:\n    return gca().broken_barh(\n        xranges,\n        yrange,\n        align=align,\n        **({\"data\": data} if data is not None else {}),\n        **kwargs,\n    )\n\n\n# Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n@_copy_docstring_and_deprecators(Axes.clabel)\ndef clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:\n    return gca().clabel(CS, levels=levels, **kwargs)"}, {"file": "lib/mpl_toolkits/mplot3d/axes3d.py", "name": "Axes3D._3d_extend_contour", "type": "codeblock", "score": 4.2152910232543945, "line": 2562, "text": "@_docstring.interpd\n@_api.define_aliases({\n    \"xlim\": [\"xlim3d\"], \"ylim\": [\"ylim3d\"], \"zlim\": [\"zlim3d\"]})\nclass Axes3D(Axes):\n\n    def _3d_extend_contour(self, cset, stride=5):\n        \"\"\"\n        Extend a contour in 3D by creating\n        \"\"\"\n\n        dz = (cset.levels[1] - cset.levels[0]) / 2\n        polyverts = []\n        colors = []\n        for idx, level in enumerate(cset.levels):\n            path = cset.get_paths()[idx]\n            subpaths = [*path._iter_connected_components()]\n            color = cset.get_edgecolor()[idx]\n            top = art3d._paths_to_3d_segments(subpaths, level - dz)\n            bot = art3d._paths_to_3d_segments(subpaths, level + dz)\n            if not len(top[0]):\n                continue\n            nsteps = max(round(len(top[0]) / stride), 2)\n            stepsize = (len(top[0]) - 1) / (nsteps - 1)\n            polyverts.extend([\n                (top[0][round(i * stepsize)], top[0][round((i + 1) * stepsize)],\n                 bot[0][round((i + 1) * stepsize)], bot[0][round(i * stepsize)])\n                for i in range(round(nsteps) - 1)])\n            colors.extend([color] * (round(nsteps) - 1))\n        self.add_collection3d(art3d.Poly3DCollection(\n            np.array(polyverts),  # All polygons have 4 vertices, so vectorize.\n            facecolors=colors, edgecolors=colors, shade=True))\n        cset.remove()"}, {"file": "lib/matplotlib/figure.py", "name": "FigureBase.get_children", "type": "codeblock", "score": 3.9963769912719727, "line": 220, "text": "class FigureBase(Artist):\n\n    def get_children(self):\n        \"\"\"Get a list of artists contained in the figure.\"\"\"\n        return [self.patch,\n                *self.artists,\n                *self._localaxes,\n                *self.lines,\n                *self.patches,\n                *self.texts,\n                *self.images,\n                *self.legends,\n                *self.subfigs]\n\n    def get_figure(self, root=None):\n        \"\"\"\n        Return the `.Figure` or `.SubFigure` instance the (Sub)Figure belongs to.\n\n        Parameters\n        ----------\n        root : bool, default=True\n            If False, return the (Sub)Figure this artist is on.  If True,\n            return the root Figure for a nested tree of SubFigures.\n\n            .. deprecated:: 3.10\n\n                From version 3.12 *root* will default to False.\n        \"\"\"\n        if self._root_figure is self:\n            # Top level Figure\n            return self\n\n        if self._parent is self._root_figure:\n            # Return early to prevent the deprecation warning when *root* does not\n            # matter\n            return self._parent\n\n        if root is None:\n            # When deprecation expires, consider removing the docstring and just\n            # inheriting the one from Artist.\n            message = ('From Matplotlib 3.12 SubFigure.get_figure will by default '\n                       'return the direct parent figure, which may be a SubFigure. '\n                       'To suppress this warning, pass the root parameter.  Pass '\n                       '`True` to maintain the old behavior and `False` to opt-in to '\n                       'the future behavior.')\n            _api.warn_deprecated('3.10', message=message)\n            root = True\n\n        if root:\n            return self._root_figure\n\n        return self._parent"}, {"file": "galleries/examples/text_labels_and_annotations/tex_demo.py", "name": "impl:35", "type": "codeblock", "score": 3.9368202686309814, "line": 52, "text": "ax.text(0, 0.1, r\"$\\delta$\",\n        color=\"black\", fontsize=24,\n        horizontalalignment=\"center\", verticalalignment=\"center\",\n        bbox=dict(boxstyle=\"round\", fc=\"white\", ec=\"black\", pad=0.2))\n\n# Use tex in labels\nax.set_xticks([-1, 0, 1])\nax.set_xticklabels([\"$-1$\", r\"$\\pm 0$\", \"$+1$\"], color=\"k\", size=20)\n\n# Left Y-axis labels, combine math mode and text mode\nax.set_ylabel(r\"\\bf{phase field} $\\phi$\", color=\"C0\", fontsize=20)\nax.set_yticks([0, 0.5, 1])\nax.set_yticklabels([r\"\\bf{0}\", r\"\\bf{.5}\", r\"\\bf{1}\"], color=\"k\", size=20)\n\n# Right Y-axis labels\nax.text(1.02, 0.5, r\"\\bf{level set} $\\phi$\",\n        color=\"C2\", fontsize=20, rotation=90,\n        horizontalalignment=\"left\", verticalalignment=\"center\",\n        clip_on=False, transform=ax.transAxes)\n\n# Use multiline environment inside a `text`.\n# level set equations\neq1 = (r\"\\begin{eqnarray*}\"\n       r\"|\\nabla\\phi| &=& 1,\\\\\"\n       r\"\\frac{\\partial \\phi}{\\partial t} + U|\\nabla \\phi| &=& 0 \"\n       r\"\\end{eqnarray*}\")\nax.text(1, 0.9, eq1, color=\"C2\", fontsize=18,\n        horizontalalignment=\"right\", verticalalignment=\"top\")\n\n# phase field equations\neq2 = (r\"\\begin{eqnarray*}\"\n       r\"\\mathcal{F} &=& \\int f\\left( \\phi, c \\right) dV, \\\\ \"\n       r\"\\frac{ \\partial \\phi } { \\partial t } &=& -M_{ \\phi } \"\n       r\"\\frac{ \\delta \\mathcal{F} } { \\delta \\phi }\"\n       r\"\\end{eqnarray*}\")\nax.text(0.18, 0.18, eq2, color=\"C0\", fontsize=16)\n\nax.text(-1, .30, r\"gamma: $\\gamma$\", color=\"r\", fontsize=20)\nax.text(-1, .18, r\"Omega: $\\Omega$\", color=\"b\", fontsize=20)\n\nplt.show()"}, {"file": "lib/matplotlib/__init__.py", "name": "set_loglevel", "type": "codeblock", "score": 3.871610641479492, "line": 284, "text": "def set_loglevel(level):\n    \"\"\"\n    Configure Matplotlib's logging levels.\n\n    Matplotlib uses the standard library `logging` framework under the root\n    logger 'matplotlib'.  This is a helper function to:\n\n    - set Matplotlib's root logger level\n    - set the root logger handler's level, creating the handler\n      if it does not exist yet\n\n    Typically, one should call ``set_loglevel(\"INFO\")`` or\n    ``set_loglevel(\"DEBUG\")`` to get additional debugging information.\n\n    Users or applications that are installing their own logging handlers\n    may want to directly manipulate ``logging.getLogger('matplotlib')`` rather\n    than use this function.\n\n    Parameters\n    ----------\n    level : {\"NOTSET\", \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        The log level as defined in `Python logging levels\n        <https://docs.python.org/3/library/logging.html#logging-levels>`__.\n\n        For backwards compatibility, the levels are case-insensitive, but\n        the capitalized version is preferred in analogy to `logging.Logger.setLevel`.\n\n    Notes\n    -----\n    The first time this function is called, an additional handler is attached\n    to Matplotlib's root handler; this handler is reused every time and this\n    function simply manipulates the logger and handler's level.\n\n    \"\"\"\n    _log.setLevel(level.upper())\n    _ensure_handler().setLevel(level.upper())"}, {"file": "galleries/examples/text_labels_and_annotations/text_alignment.py", "name": "docstring:2", "type": "codeblock", "score": 3.850249767303467, "line": 51, "text": "fig, ax = plt.subplots()\n\n# Build a rectangle in axes coords\nleft, width = .25, .5\nbottom, height = .25, .5\nright = left + width\ntop = bottom + height\np = plt.Rectangle((left, bottom), width, height, fill=False)\np.set_transform(ax.transAxes)\np.set_clip_on(False)\nax.add_patch(p)\n\nax.text(left, bottom, 'left top',\n        horizontalalignment='left',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, bottom, 'left bottom',\n        horizontalalignment='left',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right bottom',\n        horizontalalignment='right',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right top',\n        horizontalalignment='right',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(right, bottom, 'center top',\n        horizontalalignment='center',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'right center',\n        horizontalalignment='right',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'left center',\n        horizontalalignment='left',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(0.5 * (left + right), 0.5 * (bottom + top), 'middle',\n        horizontalalignment='center',\n        verticalalignment='center',\n        transform=ax.transAxes)\n\nax.text(right, 0.5 * (bottom + top), 'centered',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, top, 'rotated\\nwith newlines',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation=45,\n        transform=ax.transAxes)\n\nax.set_axis_off()\n\nplt.show()"}, {"file": "galleries/users_explain/artists/patheffects_guide.py", "name": "docstring:18", "type": "codeblock", "score": 3.8230276107788086, "line": 75, "text": "text = fig.text(0.5, 0.5, 'This text stands out because of\\n'\n                          'its black border.', color='white',\n                          ha='center', va='center', size=30)\ntext.set_path_effects([path_effects.Stroke(linewidth=3, foreground='black'),\n                       path_effects.Normal()])\nplt.show()\n\n# %%\n# It is important to note that this effect only works because we have drawn\n# the text path twice; once with a thick black line, and then once with the\n# original text path on top.\n#\n# You may have noticed that the keywords to `Stroke` and `SimplePatchShadow`\n# and `SimpleLineShadow` are not the usual Artist keywords (*facecolor*\n# *edgecolor*, etc.). This is because with these path effects we are operating\n# at lower level of Matplotlib. In fact, the keywords which are accepted are\n# those for a `matplotlib.backend_bases.GraphicsContextBase` instance, which\n# have been designed for making it easy to create new backends - and not for\n# its user interface.\n#\n#\n# Greater control of the path effect Artist\n# -----------------------------------------\n#\n# As already mentioned, some of the path effects operate at a lower level\n# than most users will be used to, meaning that setting keywords such as\n# *facecolor* and *edgecolor* raise an AttributeError. Luckily there is a\n# generic `PathPatchEffect` path effect which creates a `.patches.PathPatch`\n# class with the original path.  The keywords to this effect are identical to\n# those of `.patches.PathPatch`:\n\nfig = plt.figure(figsize=(8.5, 1))\nt = fig.text(0.02, 0.5, 'Hatch shadow', fontsize=75, weight=1000, va='center')\nt.set_path_effects([\n    path_effects.PathPatchEffect(\n        offset=(4, -4), hatch='xxxx', facecolor='gray'),\n    path_effects.PathPatchEffect(\n        edgecolor='white', linewidth=1.1, facecolor='black')])\nplt.show()\n\n# %%\n# ..\n#     Headings for future consideration:\n#\n#     Implementing a custom path effect\n#     ---------------------------------\n#\n#     What is going on under the hood\n#     --------------------------------"}], "total_results": 10}
{"repo": "matplotlib", "query": "cbook get_versions helper", "top_10": [{"file": "lib/matplotlib/__init__.py", "name": "_get_version", "type": "codeblock", "score": 3.7930548191070557, "line": 213, "text": "def _get_version():\n    \"\"\"Return the version string used for __version__.\"\"\"\n    # Only shell out to a git subprocess if really needed, i.e. when we are in\n    # a matplotlib git repo but not in a shallow clone, such as those used by\n    # CI, as the latter would trigger a warning from setuptools_scm.\n    root = Path(__file__).resolve().parents[2]\n    if ((root / \".matplotlib-repo\").exists()\n            and (root / \".git\").exists()\n            and not (root / \".git/shallow\").exists()):\n        try:\n            import setuptools_scm\n        except ImportError:\n            pass\n        else:\n            return setuptools_scm.get_version(\n                root=root,\n                dist_name=\"matplotlib\",\n                version_scheme=\"release-branch-semver\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n    # Get the version from the _version.py file if not in repo or setuptools_scm is\n    # unavailable.\n    return _version.version"}, {"file": "lib/matplotlib/cbook.py", "name": "_str_lower_equal", "type": "codeblock", "score": 3.592073678970337, "line": 1927, "text": "def _str_equal(obj, s):\n    \"\"\"\n    Return whether *obj* is a string equal to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj == s\n\n\ndef _str_lower_equal(obj, s):\n    \"\"\"\n    Return whether *obj* is a string equal, when lowercased, to string *s*.\n\n    This helper solely exists to handle the case where *obj* is a numpy array,\n    because in such cases, a naive ``obj == s`` would yield an array, which\n    cannot be used in a boolean context.\n    \"\"\"\n    return isinstance(obj, str) and obj.lower() == s"}, {"file": "lib/matplotlib/cbook.py", "name": "_is_torch_array", "type": "codeblock", "score": 3.004617214202881, "line": 2375, "text": "def _picklable_class_constructor(mixin_class, fmt, attr_name, base_class):\n    \"\"\"Internal helper for _make_class_factory.\"\"\"\n    factory = _make_class_factory(mixin_class, fmt, attr_name)\n    cls = factory(base_class)\n    return cls.__new__(cls)\n\n\ndef _is_torch_array(x):\n    \"\"\"Return whether *x* is a PyTorch Tensor.\"\"\"\n    try:\n        # We're intentionally not attempting to import torch. If somebody\n        # has created a torch array, torch should already be in sys.modules.\n        tp = sys.modules.get(\"torch\").Tensor\n    except AttributeError:\n        return False  # Module not imported or a nonstandard module with no Tensor attr.\n    return (isinstance(tp, type)  # Just in case it's a very nonstandard module.\n            and isinstance(x, tp))"}, {"file": "lib/matplotlib/collections.py", "name": "Collection._set_mappable_flags", "type": "codeblock", "score": 2.922874927520752, "line": 959, "text": "@_api.define_aliases({\n    \"antialiased\": [\"antialiaseds\", \"aa\"],\n    \"edgecolor\": [\"edgecolors\", \"ec\"],\n    \"facecolor\": [\"facecolors\", \"fc\"],\n    \"linestyle\": [\"linestyles\", \"dashes\", \"ls\"],\n    \"linewidth\": [\"linewidths\", \"lw\"],\n    \"offset_transform\": [\"transOffset\"],\n})\nclass Collection(mcolorizer.ColorizingArtist):\n\n    def _set_mappable_flags(self):\n        \"\"\"\n        Determine whether edges and/or faces are color-mapped.\n\n        This is a helper for update_scalarmappable.\n        It sets Boolean flags '_edge_is_mapped' and '_face_is_mapped'.\n\n        Returns\n        -------\n        mapping_change : bool\n            True if either flag is True, or if a flag has changed.\n        \"\"\"\n        # The flags are initialized to None to ensure this returns True\n        # the first time it is called.\n        edge0 = self._edge_is_mapped\n        face0 = self._face_is_mapped\n        # After returning, the flags must be Booleans, not None.\n        self._edge_is_mapped = False\n        self._face_is_mapped = False\n        if self._A is not None:\n            if not cbook._str_equal(self._original_facecolor, 'none'):\n                self._face_is_mapped = True\n                if cbook._str_equal(self._original_edgecolor, 'face'):\n                    self._edge_is_mapped = True\n            else:\n                if self._original_edgecolor is None:\n                    self._edge_is_mapped = True\n\n        mapped = self._face_is_mapped or self._edge_is_mapped\n        changed = (edge0 is None or face0 is None\n                   or self._edge_is_mapped != edge0\n                   or self._face_is_mapped != face0)\n        return mapped or changed"}, {"file": "lib/matplotlib/artist.py", "name": "Artist._update_props", "type": "codeblock", "score": 2.886308193206787, "line": 1202, "text": "class Artist:\n\n    def _update_props(self, props, errfmt):\n        \"\"\"\n        Helper for `.Artist.set` and `.Artist.update`.\n\n        *errfmt* is used to generate error messages for invalid property\n        names; it gets formatted with ``type(self)`` for \"{cls}\" and the\n        property name for \"{prop_name}\".\n        \"\"\"\n        ret = []\n        with cbook._setattr_cm(self, eventson=False):\n            for k, v in props.items():\n                # Allow attributes we want to be able to update through\n                # art.update, art.set, setp.\n                if k == \"axes\":\n                    ret.append(setattr(self, k, v))\n                else:\n                    func = getattr(self, f\"set_{k}\", None)\n                    if not callable(func):\n                        raise AttributeError(\n                            errfmt.format(cls=type(self), prop_name=k),\n                            name=k)\n                    ret.append(func(v))\n        if ret:\n            self.pchanged()\n            self.stale = True\n        return ret"}, {"file": "lib/matplotlib/cbook.py", "name": "index_of", "type": "codeblock", "score": 2.776963233947754, "line": 1690, "text": "STEP_LOOKUP_MAP = {'default': lambda x, y: (x, y),\n                   'steps': pts_to_prestep,\n                   'steps-pre': pts_to_prestep,\n                   'steps-post': pts_to_poststep,\n                   'steps-mid': pts_to_midstep}\n\n\ndef index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : float or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.to_numpy(), y.to_numpy()\n    except AttributeError:\n        pass\n    try:\n        y = _check_1d(y)\n    except (VisibleDeprecationWarning, ValueError):\n        # NumPy 1.19 will warn on ragged input, and we can't actually use it.\n        pass\n    else:\n        return np.arange(y.shape[0], dtype=float), y\n    raise ValueError('Input could not be cast to an at-least-1D NumPy array')"}, {"file": "lib/matplotlib/cbook.py", "name": "_unpack_to_numpy", "type": "codeblock", "score": 2.6276445388793945, "line": 2435, "text": "def _unpack_to_numpy(x):\n    \"\"\"Internal helper to extract data from e.g. pandas and xarray objects.\"\"\"\n    if isinstance(x, np.ndarray):\n        # If numpy, return directly\n        return x\n    if hasattr(x, 'to_numpy'):\n        # Assume that any to_numpy() method actually returns a numpy array\n        return x.to_numpy()\n    if hasattr(x, 'values'):\n        xtmp = x.values\n        # For example a dict has a 'values' attribute, but it is not a property\n        # so in this case we do not want to return a function\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    if _is_torch_array(x) or _is_jax_array(x) or _is_tensorflow_array(x):\n        # using np.asarray() instead of explicitly __array__(), as the latter is\n        # only _one_ of many methods, and it's the last resort, see also\n        # https://numpy.org/devdocs/user/basics.interoperability.html#using-arbitrary-objects-in-numpy\n        # therefore, let arrays do better if they can\n        xtmp = np.asarray(x)\n\n        # In case np.asarray method does not return a numpy array in future\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    return x"}, {"file": "lib/matplotlib/_api/deprecation.py", "name": "deprecate_privatize_attribute.__init__", "type": "codeblock", "score": 2.626462936401367, "line": 221, "text": "class deprecate_privatize_attribute:\n    \"\"\"\n    Helper to deprecate public access to an attribute (or method).\n\n    This helper should only be used at class scope, as follows::\n\n        class Foo:\n            attr = _deprecate_privatize_attribute(*args, **kwargs)\n\n    where *all* parameters are forwarded to `deprecated`.  This form makes\n    ``attr`` a property which forwards read and write access to ``self._attr``\n    (same name but with a leading underscore), with a deprecation warning.\n    Note that the attribute name is derived from *the name this helper is\n    assigned to*.  This helper also works for deprecating methods.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.deprecator = deprecated(*args, **kwargs)\n\n    def __set_name__(self, owner, name):\n        setattr(owner, name, self.deprecator(\n            property(lambda self: getattr(self, f\"_{name}\"),\n                     lambda self, value: setattr(self, f\"_{name}\", value)),\n            name=name))\n\n\n# Used by _copy_docstring_and_deprecators to redecorate pyplot wrappers and\n# boilerplate.py to retrieve original signatures.  It may seem natural to store\n# this information as an attribute on the wrapper, but if the wrapper gets\n# itself functools.wraps()ed, then such attributes are silently propagated to\n# the outer wrapper, which is not desired.\nDECORATORS = {}"}, {"file": "lib/matplotlib/axes/_axes.py", "name": "Axes._convert_dx", "type": "codeblock", "score": 2.5470547676086426, "line": 2203, "text": "@_docstring.interpd\nclass Axes(_AxesBase):\n\n    @staticmethod\n    def _convert_dx(dx, x0, xconv, convert):\n        \"\"\"\n        Small helper to do logic of width conversion flexibly.\n\n        *dx* and *x0* have units, but *xconv* has already been converted\n        to unitless (and is an ndarray).  This allows the *dx* to have units\n        that are different from *x0*, but are still accepted by the\n        ``__add__`` operator of *x0*.\n        \"\"\"\n\n        # x should be an array...\n        assert type(xconv) is np.ndarray\n\n        if xconv.size == 0:\n            # xconv has already been converted, but maybe empty...\n            return convert(dx)\n\n        try:\n            # attempt to add the width to x0; this works for\n            # datetime+timedelta, for instance\n\n            # only use the first element of x and x0.  This saves\n            # having to be sure addition works across the whole\n            # vector.  This is particularly an issue if\n            # x0 and dx are lists so x0 + dx just concatenates the lists.\n            # We can't just cast x0 and dx to numpy arrays because that\n            # removes the units from unit packages like `pint` that\n            # wrap numpy arrays.\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError):\n                pass\n\n            try:\n                x = cbook._safe_first_finite(xconv)\n            except (TypeError, IndexError, KeyError):\n                x = xconv\n\n            delist = False\n            if not np.iterable(dx):\n                dx = [dx]\n                delist = True\n            dx = [convert(x0 + ddx) - x for ddx in dx]\n            if delist:\n                dx = dx[0]\n        except (ValueError, TypeError, AttributeError):\n            # if the above fails (for any reason) just fallback to what\n            # we do by default and convert dx by itself.\n            dx = convert(dx)\n        return dx"}, {"file": "lib/mpl_toolkits/axisartist/grid_helper_curvelinear.py", "name": "GridHelperCurveLinear.new_fixed_axis", "type": "codeblock", "score": 2.5357718467712402, "line": 318, "text": "class GridHelperCurveLinear(GridHelperBase):\n\n    def new_fixed_axis(\n        self, loc, *, axis_direction=None, offset=None, axes=None, nth_coord=None\n    ):\n        if axes is None:\n            axes = self.axes\n        if axis_direction is None:\n            axis_direction = loc\n        helper = FixedAxisArtistHelper(self, loc, nth_coord_ticks=nth_coord)\n        axisline = AxisArtist(axes, helper, axis_direction=axis_direction)\n        # Why is clip not set on axisline, unlike in new_floating_axis or in\n        # the floating_axig.GridHelperCurveLinear subclass?\n        return axisline"}], "total_results": 10}
{"repo": "matplotlib", "query": "version tuple formatting logic", "top_10": [{"file": "lib/matplotlib/backends/qt_compat.py", "name": "impl:45", "type": "codeblock", "score": 4.352148056030273, "line": 108, "text": "if QT_API in [QT_API_PYQT6, QT_API_PYQT5, QT_API_PYSIDE6, QT_API_PYSIDE2]:\n    _setup_pyqt5plus()\nelif QT_API is None:  # See above re: dict.__getitem__.\n    if _QT_FORCE_QT5_BINDING:\n        _candidates = [\n            (_setup_pyqt5plus, QT_API_PYQT5),\n            (_setup_pyqt5plus, QT_API_PYSIDE2),\n        ]\n    else:\n        _candidates = [\n            (_setup_pyqt5plus, QT_API_PYQT6),\n            (_setup_pyqt5plus, QT_API_PYSIDE6),\n            (_setup_pyqt5plus, QT_API_PYQT5),\n            (_setup_pyqt5plus, QT_API_PYSIDE2),\n        ]\n    for _setup, QT_API in _candidates:\n        try:\n            _setup()\n        except ImportError:\n            continue\n        break\n    else:\n        raise ImportError(\n            \"Failed to import any of the following Qt binding modules: {}\"\n            .format(\", \".join([QT_API for _, QT_API in _candidates]))\n        )\nelse:  # We should not get there.\n    raise AssertionError(f\"Unexpected QT_API: {QT_API}\")\n_version_info = tuple(QtCore.QLibraryInfo.version().segments())\n\n\nif _version_info < (5, 12):\n    raise ImportError(\n        f\"The Qt version imported is \"\n        f\"{QtCore.QLibraryInfo.version().toString()} but Matplotlib requires \"\n        f\"Qt>=5.12\")\n\n\n# Fixes issues with Big Sur\n# https://bugreports.qt.io/browse/QTBUG-87014, fixed in qt 5.15.2\nif (sys.platform == 'darwin' and\n        parse_version(platform.mac_ver()[0]) >= parse_version(\"10.16\") and\n        _version_info < (5, 15, 2)):\n    os.environ.setdefault(\"QT_MAC_WANTS_LAYER\", \"1\")\n\n\n# Backports.\n\n\ndef _exec(obj):\n    # exec on PyQt6, exec_ elsewhere.\n    obj.exec() if hasattr(obj, \"exec\") else obj.exec_()"}, {"file": "lib/matplotlib/animation.py", "name": "HTMLWriter.finish", "type": "codeblock", "score": 4.24382209777832, "line": 809, "text": "@writers.register('html')\nclass HTMLWriter(FileMovieWriter):\n\n    def finish(self):\n        # save the frames to an html file\n        if self.embed_frames:\n            fill_frames = _embedded_frames(self._saved_frames,\n                                           self.frame_format)\n            frame_count = len(self._saved_frames)\n        else:\n            # temp names is filled by FileMovieWriter\n            frame_count = len(self._temp_paths)\n            fill_frames = _included_frames(\n                frame_count, self.frame_format,\n                self._temp_paths[0].parent.relative_to(self.outfile.parent))\n        mode_dict = dict(once_checked='',\n                         loop_checked='',\n                         reflect_checked='')\n        mode_dict[self.default_mode + '_checked'] = 'checked'\n\n        interval = 1000 // self.fps\n\n        with open(self.outfile, 'w') as of:\n            of.write(JS_INCLUDE + STYLE_INCLUDE)\n            of.write(DISPLAY_TEMPLATE.format(id=uuid.uuid4().hex,\n                                             Nframes=frame_count,\n                                             fill_frames=fill_frames,\n                                             interval=interval,\n                                             **mode_dict))\n\n        # Duplicate the temporary file clean up logic from\n        # FileMovieWriter.finish.  We cannot call the inherited version of\n        # finish because it assumes that there is a subprocess that we either\n        # need to call to merge many frames together or that there is a\n        # subprocess call that we need to clean up.\n        if self._tmpdir:\n            _log.debug('MovieWriter: clearing temporary path=%s', self._tmpdir)\n            self._tmpdir.cleanup()"}, {"file": "lib/matplotlib/backends/backend_ps.py", "name": "_serialize_type42", "type": "codeblock", "score": 4.22348165512085, "line": 208, "text": "def _serialize_type42(font, subset, fontdata):\n    \"\"\"\n    Output a PostScript Type-42 format representation of font\n\n    Parameters\n    ----------\n    font : fontTools.ttLib.ttFont.TTFont\n        The original font object\n    subset : fontTools.ttLib.ttFont.TTFont\n        The subset font object\n    fontdata : bytes\n        The raw font data in TTF format\n\n    Returns\n    -------\n    str\n        The Type-42 formatted font\n    \"\"\"\n    version, breakpoints = _version_and_breakpoints(font.get('loca'), fontdata)\n    post = font['post']\n    name = font['name']\n    chars = _generate_charstrings(subset)\n    sfnts = _generate_sfnts(fontdata, subset, breakpoints)\n    return textwrap.dedent(f\"\"\"\n        %%!PS-TrueTypeFont-{version[0]}.{version[1]}-{font['head'].fontRevision:.7f}\n        10 dict begin\n        /FontType 42 def\n        /FontMatrix [1 0 0 1 0 0] def\n        /FontName /{name.getDebugName(6)} def\n        /FontInfo 7 dict dup begin\n        /FullName ({name.getDebugName(4)}) def\n        /FamilyName ({name.getDebugName(1)}) def\n        /Version ({name.getDebugName(5)}) def\n        /ItalicAngle {post.italicAngle} def\n        /isFixedPitch {'true' if post.isFixedPitch else 'false'} def\n        /UnderlinePosition {post.underlinePosition} def\n        /UnderlineThickness {post.underlineThickness} def\n        end readonly def\n        /Encoding StandardEncoding def\n        /FontBBox [{_nums_to_str(*_bounds(font))}] def\n        /PaintType 0 def\n        /CIDMap 0 def\n        {chars}\n        {sfnts}\n        FontName currentdict end definefont pop\n        \"\"\")"}, {"file": "lib/matplotlib/backends/backend_ps.py", "name": "_version_and_breakpoints", "type": "codeblock", "score": 4.172800064086914, "line": 256, "text": "def _version_and_breakpoints(loca, fontdata):\n    \"\"\"\n    Read the version number of the font and determine sfnts breakpoints.\n\n    When a TrueType font file is written as a Type 42 font, it has to be\n    broken into substrings of at most 65535 bytes. These substrings must\n    begin at font table boundaries or glyph boundaries in the glyf table.\n    This function determines all possible breakpoints and it is the caller's\n    responsibility to do the splitting.\n\n    Helper function for _font_to_ps_type42.\n\n    Parameters\n    ----------\n    loca : fontTools.ttLib._l_o_c_a.table__l_o_c_a or None\n        The loca table of the font if available\n    fontdata : bytes\n        The raw data of the font\n\n    Returns\n    -------\n    version : tuple[int, int]\n        A 2-tuple of the major version number and minor version number.\n    breakpoints : list[int]\n        The breakpoints is a sorted list of offsets into fontdata; if loca is not\n        available, just the table boundaries.\n    \"\"\"\n    v1, v2, numTables = struct.unpack('>3h', fontdata[:6])\n    version = (v1, v2)\n\n    tables = {}\n    for i in range(numTables):\n        tag, _, offset, _ = struct.unpack('>4sIII', fontdata[12 + i*16:12 + (i+1)*16])\n        tables[tag.decode('ascii')] = offset\n    if loca is not None:\n        glyf_breakpoints = {tables['glyf'] + offset for offset in loca.locations[:-1]}\n    else:\n        glyf_breakpoints = set()\n    breakpoints = sorted({*tables.values(), *glyf_breakpoints, len(fontdata)})\n\n    return version, breakpoints"}, {"file": "lib/matplotlib/__init__.py", "name": "_get_executable_info", "type": "codeblock", "score": 3.8990085124969482, "line": 364, "text": "@functools.cache\ndef _get_executable_info(name):\n    \"\"\"\n    Get the version of some executable that Matplotlib optionally depends on.\n\n    .. warning::\n       The list of executables that this function supports is set according to\n       Matplotlib's internal needs, and may change without notice.\n\n    Parameters\n    ----------\n    name : str\n        The executable to query.  The following values are currently supported:\n        \"dvipng\", \"gs\", \"inkscape\", \"magick\", \"pdftocairo\", \"pdftops\".  This\n        list is subject to change without notice.\n\n    Returns\n    -------\n    tuple\n        A namedtuple with fields ``executable`` (`str`) and ``version``\n        (`packaging.Version`, or ``None`` if the version cannot be determined).\n\n    Raises\n    ------\n    ExecutableNotFoundError\n        If the executable is not found or older than the oldest version\n        supported by Matplotlib.  For debugging purposes, it is also\n        possible to \"hide\" an executable from Matplotlib by adding it to the\n        :envvar:`_MPLHIDEEXECUTABLES` environment variable (a comma-separated\n        list), which must be set prior to any calls to this function.\n    ValueError\n        If the executable is not one that we know how to query.\n    \"\"\"\n    # ... other code"}, {"file": "lib/matplotlib/image.py", "name": "imsave", "type": "codeblock", "score": 3.727116346359253, "line": 1634, "text": "def imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None,\n           origin=None, dpi=100, *, metadata=None, pil_kwargs=None):\n    # ... other code\n    if format in [\"pdf\", \"ps\", \"eps\", \"svg\"]:\n        # Vector formats that are not handled by PIL.\n        if pil_kwargs is not None:\n            raise ValueError(\n                f\"Cannot use 'pil_kwargs' when saving to {format}\")\n        fig = Figure(dpi=dpi, frameon=False)\n        fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin,\n                     resize=True)\n        fig.savefig(fname, dpi=dpi, format=format, transparent=True,\n                    metadata=metadata)\n    else:\n        # Don't bother creating an image; this avoids rounding errors on the\n        # size when dividing and then multiplying by dpi.\n        origin = mpl._val_or_rc(origin, \"image.origin\")\n        _api.check_in_list(('upper', 'lower'), origin=origin)\n        if origin == \"lower\":\n            arr = arr[::-1]\n        if (isinstance(arr, memoryview) and arr.format == \"B\"\n                and arr.ndim == 3 and arr.shape[-1] == 4):\n            # Such an ``arr`` would also be handled fine by sm.to_rgba below\n            # (after casting with asarray), but it is useful to special-case it\n            # because that's what backend_agg passes, and can be in fact used\n            # as is, saving a few operations.\n            rgba = arr\n        else:\n            sm = mcolorizer.Colorizer(cmap=cmap)\n            sm.set_clim(vmin, vmax)\n            rgba = sm.to_rgba(arr, bytes=True)\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        else:\n            # we modify this below, so make a copy (don't modify caller's dict)\n            pil_kwargs = pil_kwargs.copy()\n        pil_shape = (rgba.shape[1], rgba.shape[0])\n        rgba = np.require(rgba, requirements='C')\n        image = PIL.Image.frombuffer(\n            \"RGBA\", pil_shape, rgba, \"raw\", \"RGBA\", 0, 1)\n        if format == \"png\":\n            # Only use the metadata kwarg if pnginfo is not set, because the\n            # semantics of duplicate keys in pnginfo is unclear.\n            if \"pnginfo\" in pil_kwargs:\n                if metadata:\n                    _api.warn_external(\"'metadata' is overridden by the \"\n                                       \"'pnginfo' entry in 'pil_kwargs'.\")\n            else:\n                metadata = {\n                    \"Software\": (f\"Matplotlib version{mpl.__version__}, \"\n                                 f\"https://matplotlib.org/\"),\n                    **(metadata if metadata is not None else {}),\n                }\n                pil_kwargs[\"pnginfo\"] = pnginfo = PIL.PngImagePlugin.PngInfo()\n                for k, v in metadata.items():\n                    if v is not None:\n                        pnginfo.add_text(k, v)\n        elif metadata is not None:\n            raise ValueError(f\"metadata not supported for format {format!r}\")\n        if format in [\"jpg\", \"jpeg\"]:\n            format = \"jpeg\"  # Pillow doesn't recognize \"jpg\".\n            facecolor = mpl.rcParams[\"savefig.facecolor\"]\n            if cbook._str_equal(facecolor, \"auto\"):\n                facecolor = mpl.rcParams[\"figure.facecolor\"]\n            color = tuple(int(x * 255) for x in mcolors.to_rgb(facecolor))\n            background = PIL.Image.new(\"RGB\", pil_shape, color)\n            background.paste(image, image)\n            image = background\n        pil_kwargs.setdefault(\"format\", format)\n        pil_kwargs.setdefault(\"dpi\", (dpi, dpi))\n        image.save(fname, **pil_kwargs)"}, {"file": "lib/matplotlib/_mathtext_data.py", "name": "impl:9", "type": "codeblock", "score": 3.7246994972229004, "line": 466, "text": "#  The script below is to sort and format the tex2uni dict\n\n## For decimal values: int(hex(v), 16)\n#  newtex = {k: hex(v) for k, v in tex2uni.items()}\n#  sd = dict(sorted(newtex.items(), key=lambda item: item[0]))\n#\n## For formatting the sorted dictionary with proper spacing\n## the value '24' comes from finding the longest string in\n## the newtex keys with len(max(newtex, key=len))\n#  for key in sd:\n#      print(\"{0:24} : {1: <s},\".format(\"'\" + key + \"'\", sd[key]))\n\ntex2uni =\n # ... other code\n\n# Each element is a 4-tuple of the form:\n#   src_start, src_end, dst_font, dst_start\n\n_EntryTypeIn = tuple[str, str, str, str | int]\n_EntryTypeOut = tuple[int, int, str, int]\n\n_stix_virtual_fonts: dict[str, dict[str, list[_EntryTypeIn]] | list[_EntryTypeIn]] =\n # ... other code"}, {"file": "lib/matplotlib/__init__.py", "name": "RcParams._update_raw", "type": "codeblock", "score": 3.6117355823516846, "line": 727, "text": "@_docstring.Substitution(\n    \"\\n\".join(map(\"- {}\".format, sorted(rcsetup._validators, key=str.lower)))\n)\nclass RcParams(MutableMapping, dict):\n\n    def _update_raw(self, other_params):\n        \"\"\"\n        Directly update the data from *other_params*, bypassing deprecation,\n        backend and validation logic on both sides.\n\n        This ``rcParams._update_raw(params)`` replaces the previous pattern\n        ``dict.update(rcParams, params)``.\n\n        Parameters\n        ----------\n        other_params : dict or `.RcParams`\n            The input mapping from which to update.\n        \"\"\"\n        if isinstance(other_params, RcParams):\n            other_params = dict.items(other_params)\n        dict.update(self, other_params)"}, {"file": "lib/matplotlib/backends/qt_compat.py", "name": "docstring", "type": "codeblock", "score": 3.572481870651245, "line": 1, "text": "\"\"\"\nQt binding and backend selector.\n\nThe selection logic is as follows:\n- if any of PyQt6, PySide6, PyQt5, or PySide2 have already been\n  imported (checked in that order), use it;\n- otherwise, if the QT_API environment variable (used by Enthought) is set, use\n  it to determine which binding to use;\n- otherwise, use whatever the rcParams indicate.\n\"\"\"\n\nimport operator\nimport os\nimport platform\nimport sys\n\nfrom packaging.version import parse as parse_version\n\nimport matplotlib as mpl\n\nfrom . import _QT_FORCE_QT5_BINDING\n\nQT_API_PYQT6 = \"PyQt6\"\nQT_API_PYSIDE6 = \"PySide6\"\nQT_API_PYQT5 = \"PyQt5\"\nQT_API_PYSIDE2 = \"PySide2\"\nQT_API_ENV = os.environ.get(\"QT_API\")\nif QT_API_ENV is not None:\n    QT_API_ENV = QT_API_ENV.lower()\n_ETS = {  # Mapping of QT_API_ENV to requested binding.\n    \"pyqt6\": QT_API_PYQT6, \"pyside6\": QT_API_PYSIDE6,\n    \"pyqt5\": QT_API_PYQT5, \"pyside2\": QT_API_PYSIDE2,\n}\n# First, check if anything is already imported."}, {"file": "lib/matplotlib/colors.py", "name": "_has_alpha_channel", "type": "codeblock", "score": 3.5428972244262695, "line": 240, "text": "def _has_alpha_channel(c):\n    \"\"\"\n    Return whether *c* is a color with an alpha channel.\n\n    If *c* is not a valid color specifier, then the result is undefined.\n    \"\"\"\n    # The following logic uses the assumption that c is a valid color spec.\n    # For speed and simplicity, we intentionally don't care about other inputs.\n    # Anything can happen with them.\n\n    # if c is a hex, it has an alpha channel when it has 4 (or 8) digits after '#'\n    if isinstance(c, str):\n        if c[0] == '#' and (len(c) == 5 or len(c) == 9):\n            # example: '#fff8' or '#0f0f0f80'\n            return True\n    else:\n        # if c isn't a string, it can be an RGB(A) or a color-alpha tuple\n        # if it has length 4, it has an alpha channel\n        if len(c) == 4:\n            # example: [0.5, 0.5, 0.5, 0.5]\n            return True\n\n        # if it has length 2, it's a color/alpha tuple\n        # if the second element isn't None or the first element has length = 4\n        if len(c) == 2 and (c[1] is not None or _has_alpha_channel(c[0])):\n            # example: ([0.5, 0.5, 0.5, 0.5], None) or ('r', 0.5)\n            return True\n\n    # otherwise it doesn't have an alpha channel\n    return False"}], "total_results": 10}
{"repo": "matplotlib", "query": "build metadata for Matplotlib version", "top_10": [{"file": "lib/matplotlib/__init__.py", "name": "_init_tests", "type": "codeblock", "score": 5.806234836578369, "line": 1343, "text": "def _init_tests():\n    # The version of FreeType to install locally for running the tests. This must match\n    # the value in `meson.build`.\n    LOCAL_FREETYPE_VERSION = '2.6.1'\n\n    from matplotlib import ft2font\n    if (ft2font.__freetype_version__ != LOCAL_FREETYPE_VERSION or\n            ft2font.__freetype_build_type__ != 'local'):\n        _log.warning(\n            \"Matplotlib is not built with the correct FreeType version to run tests.  \"\n            \"Rebuild without setting system-freetype=true in Meson setup options.  \"\n            \"Expect many image comparison failures below.  \"\n            \"Expected freetype version %s.  \"\n            \"Found freetype version %s.  \"\n            \"Freetype build type is %slocal.\",\n            LOCAL_FREETYPE_VERSION,\n            ft2font.__freetype_version__,\n            \"\" if ft2font.__freetype_build_type__ == 'local' else \"not \")"}, {"file": "lib/matplotlib/backends/backend_svg.py", "name": "RendererSVG._write_metadata", "type": "codeblock", "score": 5.566265106201172, "line": 350, "text": "class RendererSVG(RendererBase):\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [date.isoformat()]\n            elif np.iterable(date):\n                dates = []\n                for d in date:\n                    if isinstance(d, str):\n                        dates.append(d)\n                    elif isinstance(d, (datetime.datetime, datetime.date)):\n                        dates.append(d.isoformat())\n                    else:\n                        raise TypeError(\n                            f'Invalid type for Date metadata. '\n                            f'Expected iterable of str, date, or datetime, '\n                            f'not {type(d)}.')\n            else:\n                raise TypeError(f'Invalid type for Date metadata. '\n                                f'Expected str, date, datetime, or iterable '\n                                f'of the same, not {type(date)}.')\n            metadata['Date'] = '/'.join(dates)\n        elif 'Date' not in metadata:\n            # Do not add `Date` if the user explicitly set `Date` to `None`\n            # Get source date from SOURCE_DATE_EPOCH, if set.\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            date = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if date:\n                date = datetime.datetime.fromtimestamp(int(date), datetime.timezone.utc)\n                metadata['Date'] = date.replace(tzinfo=UTC).isoformat()\n            else:\n                metadata['Date'] = datetime.datetime.today().isoformat()\n\n        mid = None\n        # ... other code"}, {"file": "lib/matplotlib/sphinxext/figmpl_directive.py", "name": "depart_figmpl_latex", "type": "codeblock", "score": 5.331732749938965, "line": 255, "text": "def visit_figmpl_latex(self, node):\n\n    if node['srcset'] is not None:\n        imagedir, srcset = _copy_images_figmpl(self, node)\n        maxmult = -1\n        # choose the highest res version for latex:\n        maxmult = max(srcset, default=-1)\n        node['uri'] = PurePath(srcset[maxmult]).name\n\n    self.visit_figure(node)\n\n\ndef depart_figmpl_html(self, node):\n    pass\n\n\ndef depart_figmpl_latex(self, node):\n    self.depart_figure(node)\n\n\ndef figurempl_addnode(app):\n    app.add_node(figmplnode,\n                 html=(visit_figmpl_html, depart_figmpl_html),\n                 latex=(visit_figmpl_latex, depart_figmpl_latex))\n\n\ndef setup(app):\n    app.add_directive(\"figure-mpl\", FigureMpl)\n    figurempl_addnode(app)\n    metadata = {'parallel_read_safe': True, 'parallel_write_safe': True,\n                'version': matplotlib.__version__}\n    return metadata"}, {"file": "ci/check_version_number.py", "name": "docstring", "type": "codeblock", "score": 5.251496315002441, "line": 1, "text": "#!/usr/bin/env python3\n\n\"\"\"\nCheck that the version number of the install Matplotlib does not start with 0\n\nTo run:\n    $ python3 -m build .\n    $ pip install dist/matplotlib*.tar.gz for sdist\n    $ pip install dist/matplotlib*.whl for wheel\n    $ ./ci/check_version_number.py\n\"\"\"\nimport sys\n\nimport matplotlib\n\n\nprint(f\"Version {matplotlib.__version__} installed\")\nif matplotlib.__version__[0] == \"0\":\n    sys.exit(\"Version incorrectly starts with 0\")"}, {"file": "lib/matplotlib/backends/backend_pdf.py", "name": "_create_pdf_info_dict", "type": "codeblock", "score": 5.179018497467041, "line": 117, "text": "def _create_pdf_info_dict(backend, metadata):\n    \"\"\"\n    Create a PDF infoDict based on user-supplied metadata.\n\n    A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though\n    the user metadata may override it. The date may be the current time, or a\n    time set by the ``SOURCE_DATE_EPOCH`` environment variable.\n\n    Metadata is verified to have the correct keys and their expected types. Any\n    unknown keys/types will raise a warning.\n\n    Parameters\n    ----------\n    backend : str\n        The name of the backend to use in the Producer value.\n\n    metadata : dict[str, Union[str, datetime, Name]]\n        A dictionary of metadata supplied by the user with information\n        following the PDF specification, also defined in\n        `~.backend_pdf.PdfPages` below.\n\n        If any value is *None*, then the key will be removed. This can be used\n        to remove any pre-defined values.\n\n    Returns\n    -------\n    dict[str, Union[str, datetime, Name]]\n        A validated dictionary of metadata.\n    \"\"\"\n\n    # get source date from SOURCE_DATE_EPOCH, if set\n    # See https://reproducible-builds.org/specs/source-date-epoch/\n    source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n    if source_date_epoch:\n        source_date = datetime.fromtimestamp(int(source_date_epoch), timezone.utc)\n        source_date = source_date.replace(tzinfo=UTC)\n    else:\n        source_date = datetime.today()\n\n    info = {\n        'Creator': f'Matplotlib v{mpl.__version__}, https://matplotlib.org',\n        'Producer': f'Matplotlib {backend} backend v{mpl.__version__}',\n        'CreationDate': source_date,\n        **metadata\n    }\n    info = {k: v for (k, v) in info.items() if v is not None}\n\n    def is_string_like(x):\n        return isinstance(x, str)\n    is_string_like.text_for_warning = \"an instance of str\"\n\n    def is_date(x):\n        return isinstance(x, datetime)\n    is_date.text_for_warning = \"an instance of datetime.datetime\"\n\n    def check_trapped(x):\n        if isinstance(x, Name):\n            return x.name in (b'True', b'False', b'Unknown')\n        else:\n            return x in ('True', 'False', 'Unknown')\n    check_trapped.text_for_warning = 'one of {\"True\", \"False\", \"Unknown\"}'\n    # ... other code"}, {"file": "lib/matplotlib/backends/backend_agg.py", "name": "FigureCanvasAgg.print_webp", "type": "codeblock", "score": 5.1667304039001465, "line": 484, "text": "class FigureCanvasAgg(FigureCanvasBase):\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    def print_gif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"gif\", pil_kwargs, metadata)\n\n    def print_jpg(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs, metadata)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs, metadata)\n\n    print_tiff = print_tif\n\n    def print_webp(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs, metadata)\n\n    def print_avif(self, filename_or_obj, *, metadata=None, pil_kwargs=None):\n        if not features.check(\"avif\"):\n            raise RuntimeError(\n                \"The installed pillow version does not support avif. Full \"\n                \"avif support has been added in pillow 11.3.\"\n            )\n        self._print_pil(filename_or_obj, \"avif\", pil_kwargs, metadata)"}, {"file": "lib/matplotlib/backends/_backend_tk.py", "name": "imports", "type": "codeblock", "score": 4.9400634765625, "line": 1, "text": "import uuid\nimport weakref\nfrom contextlib import contextmanager\nimport logging\nimport math\nimport os.path\nimport pathlib\nimport sys\nimport tkinter as tk\nimport tkinter.filedialog\nimport tkinter.font\nimport tkinter.messagebox\nfrom tkinter.simpledialog import SimpleDialog\n\nimport numpy as np\nfrom PIL import Image, ImageTk\n\nimport matplotlib as mpl\nfrom matplotlib import _api, backend_tools, cbook, _c_internal_utils\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, NavigationToolbar2,\n    TimerBase, ToolContainerBase, cursors, _Mode, MouseButton,\n    CloseEvent, KeyEvent, LocationEvent, MouseEvent, ResizeEvent)\nfrom matplotlib._pylab_helpers import Gcf\n\ntry:\n    from . import _tkagg\n    from ._tkagg import TK_PHOTO_COMPOSITE_OVERLAY, TK_PHOTO_COMPOSITE_SET\nexcept ImportError as e:\n    # catch incompatibility of python-build-standalone with Tk\n    cause1 = getattr(e, '__cause__', None)\n    cause2 = getattr(cause1, '__cause__', None)\n    if (isinstance(cause1, ImportError) and\n            isinstance(cause2, AttributeError) and\n            \"'_tkinter' has no attribute '__file__'\" in str(cause2)):\n\n        is_uv_python = \"/uv/python\" in (os.path.realpath(sys.executable))\n        if is_uv_python:\n            raise ImportError(\n                \"Failed to import tkagg backend. You appear to be using an outdated \"\n                \"version of uv's managed Python distribution which is not compatible \"\n                \"with Tk. Please upgrade to the latest uv version, then update \"\n                \"Python with: `uv python upgrade --reinstall`\"\n                ) from e\n        else:\n            raise ImportError(\n                \"Failed to import tkagg backend. This is likely caused by using a \"\n                \"Python executable based on python-build-standalone, which is not \"\n                \"compatible with Tk. Recent versions of python-build-standalone \"\n                \"should be compatible with Tk. Please update your python version \"\n                \"or select another backend.\"\n                ) from e\n    else:\n        raise\n\n\n_log = logging.getLogger(__name__)"}, {"file": "doc/sphinxext/redirect_from.py", "name": "docstring", "type": "codeblock", "score": 4.81492805480957, "line": 1, "text": "\"\"\"\nRedirecting old docs to new location\n====================================\n\nIf an rst file is moved or its content subsumed in a different file, it\nis desirable to redirect the old file to the new or existing file. This\nextension enables this with a simple html refresh.\n\nFor example suppose ``doc/topic/old-page.rst`` is removed and its content\nincluded in ``doc/topic/new-page.rst``.  We use the ``redirect-from``\ndirective in ``doc/topic/new-page.rst``::\n\n    .. redirect-from:: /topic/old-page\n\nThis creates in the build directory a file ``build/html/topic/old-page.html``\nthat contains a relative refresh::\n\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"refresh\" content=\"0; url=new-page.html\">\n      </head>\n    </html>\n\nIf you need to redirect across subdirectory trees, that works as well.  For\ninstance if ``doc/topic/subdir1/old-page.rst`` is now found at\n``doc/topic/subdir2/new-page.rst`` then ``new-page.rst`` just lists the\nfull path::\n\n    .. redirect-from:: /topic/subdir1/old-page.rst\n\n\"\"\"\n\nfrom pathlib import Path\nfrom sphinx.util.docutils import SphinxDirective\nfrom sphinx.domains import Domain\nfrom sphinx.util import logging\n\nlogger = logging.getLogger(__name__)\n\n\nHTML_TEMPLATE = \"\"\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"refresh\" content=\"0; url={v}\">\n  </head>\n</html>\n\"\"\"\n\n\ndef setup(app):\n    app.add_directive(\"redirect-from\", RedirectFrom)\n    app.add_domain(RedirectFromDomain)\n    app.connect(\"builder-inited\", _clear_redirects)\n    app.connect(\"build-finished\", _generate_redirects)\n\n    metadata = {'parallel_read_safe': True}\n    return metadata"}, {"file": "doc/conf.py", "name": "docstring", "type": "codeblock", "score": 4.759178638458252, "line": 1, "text": "# Matplotlib documentation build configuration file, created by\n# sphinx-quickstart on Fri May  2 12:33:25 2008.\n#\n# This file is execfile()d with the current directory set to its containing\n# dir.\n#\n# The contents of this file are pickled, so don't put values in the namespace\n# that aren't picklable (module imports are okay, they're removed\n# automatically).\n#\n# All configuration values have a default value; values that are commented out\n# serve to show the default value.\n\nfrom datetime import datetime, timezone\nimport logging\nimport os\nfrom pathlib import Path\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport time\nfrom urllib.parse import urlsplit, urlunsplit\nimport warnings\n\nfrom packaging.version import parse as parse_version\nimport sphinx\nimport yaml\n\nimport matplotlib\n\n# debug that building expected version\nprint(f\"Building Documentation for Matplotlib: {matplotlib.__version__}\")\n\n# Release mode enables optimizations and other related options.\nis_release_build = tags.has('release')  # noqa\n\n# are we running circle CI?\nCIRCLECI = 'CIRCLECI' in os.environ\n# are we deploying this build to matplotlib.org/devdocs?\n# This is a copy of the logic in .circleci/deploy-docs.sh\nDEVDOCS = (\n    CIRCLECI and\n    (os.environ.get(\"CIRCLE_PROJECT_USERNAME\") == \"matplotlib\") and\n    (os.environ.get(\"CIRCLE_BRANCH\") == \"main\") and\n    (not os.environ.get(\"CIRCLE_PULL_REQUEST\", \"\").startswith(\n        \"https://github.com/matplotlib/matplotlib/pull\")))\nwarnings.filterwarnings('default', category=UserWarning,\n                        message=r'Matplotlib currently does not support .+ natively\\.')\nwarnings.filterwarnings('ignore', category=DeprecationWarning,\n                        module='importlib',  # used by sphinx.autodoc.importer\n                        message=r'(\\n|.)*module was deprecated.*')"}, {"file": "lib/matplotlib/image.py", "name": "imsave", "type": "codeblock", "score": 4.675717353820801, "line": 1634, "text": "def imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None,\n           origin=None, dpi=100, *, metadata=None, pil_kwargs=None):\n    # ... other code\n    if format in [\"pdf\", \"ps\", \"eps\", \"svg\"]:\n        # Vector formats that are not handled by PIL.\n        if pil_kwargs is not None:\n            raise ValueError(\n                f\"Cannot use 'pil_kwargs' when saving to {format}\")\n        fig = Figure(dpi=dpi, frameon=False)\n        fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin,\n                     resize=True)\n        fig.savefig(fname, dpi=dpi, format=format, transparent=True,\n                    metadata=metadata)\n    else:\n        # Don't bother creating an image; this avoids rounding errors on the\n        # size when dividing and then multiplying by dpi.\n        origin = mpl._val_or_rc(origin, \"image.origin\")\n        _api.check_in_list(('upper', 'lower'), origin=origin)\n        if origin == \"lower\":\n            arr = arr[::-1]\n        if (isinstance(arr, memoryview) and arr.format == \"B\"\n                and arr.ndim == 3 and arr.shape[-1] == 4):\n            # Such an ``arr`` would also be handled fine by sm.to_rgba below\n            # (after casting with asarray), but it is useful to special-case it\n            # because that's what backend_agg passes, and can be in fact used\n            # as is, saving a few operations.\n            rgba = arr\n        else:\n            sm = mcolorizer.Colorizer(cmap=cmap)\n            sm.set_clim(vmin, vmax)\n            rgba = sm.to_rgba(arr, bytes=True)\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        else:\n            # we modify this below, so make a copy (don't modify caller's dict)\n            pil_kwargs = pil_kwargs.copy()\n        pil_shape = (rgba.shape[1], rgba.shape[0])\n        rgba = np.require(rgba, requirements='C')\n        image = PIL.Image.frombuffer(\n            \"RGBA\", pil_shape, rgba, \"raw\", \"RGBA\", 0, 1)\n        if format == \"png\":\n            # Only use the metadata kwarg if pnginfo is not set, because the\n            # semantics of duplicate keys in pnginfo is unclear.\n            if \"pnginfo\" in pil_kwargs:\n                if metadata:\n                    _api.warn_external(\"'metadata' is overridden by the \"\n                                       \"'pnginfo' entry in 'pil_kwargs'.\")\n            else:\n                metadata = {\n                    \"Software\": (f\"Matplotlib version{mpl.__version__}, \"\n                                 f\"https://matplotlib.org/\"),\n                    **(metadata if metadata is not None else {}),\n                }\n                pil_kwargs[\"pnginfo\"] = pnginfo = PIL.PngImagePlugin.PngInfo()\n                for k, v in metadata.items():\n                    if v is not None:\n                        pnginfo.add_text(k, v)\n        elif metadata is not None:\n            raise ValueError(f\"metadata not supported for format {format!r}\")\n        if format in [\"jpg\", \"jpeg\"]:\n            format = \"jpeg\"  # Pillow doesn't recognize \"jpg\".\n            facecolor = mpl.rcParams[\"savefig.facecolor\"]\n            if cbook._str_equal(facecolor, \"auto\"):\n                facecolor = mpl.rcParams[\"figure.facecolor\"]\n            color = tuple(int(x * 255) for x in mcolors.to_rgb(facecolor))\n            background = PIL.Image.new(\"RGB\", pil_shape, color)\n            background.paste(image, image)\n            image = background\n        pil_kwargs.setdefault(\"format\", format)\n        pil_kwargs.setdefault(\"dpi\", (dpi, dpi))\n        image.save(fname, **pil_kwargs)"}], "total_results": 10}
{"repo": "matplotlib", "query": "setuptools_scm integration", "top_10": [{"file": "lib/matplotlib/__init__.py", "name": "_get_version", "type": "codeblock", "score": 5.662662506103516, "line": 213, "text": "def _get_version():\n    \"\"\"Return the version string used for __version__.\"\"\"\n    # Only shell out to a git subprocess if really needed, i.e. when we are in\n    # a matplotlib git repo but not in a shallow clone, such as those used by\n    # CI, as the latter would trigger a warning from setuptools_scm.\n    root = Path(__file__).resolve().parents[2]\n    if ((root / \".matplotlib-repo\").exists()\n            and (root / \".git\").exists()\n            and not (root / \".git/shallow\").exists()):\n        try:\n            import setuptools_scm\n        except ImportError:\n            pass\n        else:\n            return setuptools_scm.get_version(\n                root=root,\n                dist_name=\"matplotlib\",\n                version_scheme=\"release-branch-semver\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n    # Get the version from the _version.py file if not in repo or setuptools_scm is\n    # unavailable.\n    return _version.version"}, {"file": "lib/matplotlib/__init__.py", "name": "_parse_to_version_info", "type": "codeblock", "score": 3.3065035343170166, "line": 189, "text": "def _parse_to_version_info(version_str):\n    \"\"\"\n    Parse a version string to a namedtuple analogous to sys.version_info.\n\n    See:\n    https://packaging.pypa.io/en/latest/version.html#packaging.version.parse\n    https://docs.python.org/3/library/sys.html#sys.version_info\n    \"\"\"\n    v = parse_version(version_str)\n    if v.pre is None and v.post is None and v.dev is None:\n        return _VersionInfo(v.major, v.minor, v.micro, 'final', 0)\n    elif v.dev is not None:\n        return _VersionInfo(v.major, v.minor, v.micro, 'alpha', v.dev)\n    elif v.pre is not None:\n        releaselevel = {\n            'a': 'alpha',\n            'b': 'beta',\n            'rc': 'candidate'}.get(v.pre[0], 'alpha')\n        return _VersionInfo(v.major, v.minor, v.micro, releaselevel, v.pre[1])\n    else:\n        # fallback for v.post: guess-next-dev scheme from setuptools_scm\n        return _VersionInfo(v.major, v.minor, v.micro + 1, 'alpha', v.post)"}, {"file": "lib/matplotlib/streamplot.py", "name": "_get_integrator", "type": "codeblock", "score": 3.3049893379211426, "line": 517, "text": "def _get_integrator(u, v, dmap, minlength, maxlength, integration_direction):\n    # ... other code\n\n    def integrate(x0, y0, broken_streamlines=True, integration_max_step_scale=1.0,\n                  integration_max_error_scale=1.0):\n        \"\"\"\n        Return x, y grid-coordinates of trajectory based on starting point.\n\n        Integrate both forward and backward in time from starting point in\n        grid coordinates.\n\n        Integration is terminated when a trajectory reaches a domain boundary\n        or when it crosses into an already occupied cell in the StreamMask. The\n        resulting trajectory is None if it is shorter than `minlength`.\n        \"\"\"\n\n        stotal, xy_traj = 0., []\n\n        try:\n            dmap.start_trajectory(x0, y0, broken_streamlines)\n        except InvalidIndexError:\n            return None\n        if integration_direction in ['both', 'backward']:\n            s, xyt = _integrate_rk12(x0, y0, dmap, backward_time, maxlength,\n                                     broken_streamlines,\n                                     integration_max_step_scale,\n                                     integration_max_error_scale)\n            stotal += s\n            xy_traj += xyt[::-1]\n\n        if integration_direction in ['both', 'forward']:\n            dmap.reset_start_point(x0, y0)\n            s, xyt = _integrate_rk12(x0, y0, dmap, forward_time, maxlength,\n                                     broken_streamlines,\n                                     integration_max_step_scale,\n                                     integration_max_error_scale)\n            stotal += s\n            xy_traj += xyt[1:]\n\n        if stotal > minlength:\n            return np.broadcast_arrays(xy_traj, np.empty((1, 2)))[0]\n        else:  # reject short trajectories\n            dmap.undo_trajectory()\n            return None\n\n    return integrate\n\n\nclass OutOfBounds(IndexError):\n    pass"}, {"file": "lib/matplotlib/axes/_axes.py", "name": "Axes._errorevery_to_mask", "type": "codeblock", "score": 3.1555140018463135, "line": 3769, "text": "@_docstring.interpd\nclass Axes(_AxesBase):\n\n    @staticmethod\n    def _errorevery_to_mask(x, errorevery):\n        \"\"\"\n        Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.\n\n        This function is split out to be usable both by 2D and 3D errorbars.\n        \"\"\"\n        if isinstance(errorevery, Integral):\n            errorevery = (0, errorevery)\n        if isinstance(errorevery, tuple):\n            if (len(errorevery) == 2 and\n                    isinstance(errorevery[0], Integral) and\n                    isinstance(errorevery[1], Integral)):\n                errorevery = slice(errorevery[0], None, errorevery[1])\n            else:\n                raise ValueError(\n                    f'{errorevery=!r} is a not a tuple of two integers')\n        elif isinstance(errorevery, slice):\n            pass\n        elif not isinstance(errorevery, str) and np.iterable(errorevery):\n            try:\n                x[errorevery]  # fancy indexing\n            except (ValueError, IndexError) as err:\n                raise ValueError(\n                    f\"{errorevery=!r} is iterable but not a valid NumPy fancy \"\n                    \"index to match 'xerr'/'yerr'\") from err\n        else:\n            raise ValueError(f\"{errorevery=!r} is not a recognized value\")\n        everymask = np.zeros(len(x), bool)\n        everymask[errorevery] = True\n        return everymask"}, {"file": "galleries/examples/showcase/integral.py", "name": "docstring", "type": "codeblock", "score": 3.01395845413208, "line": 1, "text": "\"\"\"\n==================================\nIntegral as the area under a curve\n==================================\n\nAlthough this is a simple example, it demonstrates some important tweaks:\n\n* A simple line plot with custom color and line width.\n* A shaded region created using a Polygon patch.\n* A text label with mathtext rendering.\n* figtext calls to label the x- and y-axes.\n* Use of axis spines to hide the top and right spines.\n* Custom tick placement and labels.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef func(x):\n    return (x - 3) * (x - 5) * (x - 7) + 85\n\n\na, b = 2, 9  # integral limits\nx = np.linspace(0, 10)\ny = func(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y, 'r', linewidth=2)\nax.set_ylim(bottom=0)\n\n# Make the shaded region\nix = np.linspace(a, b)\niy = func(ix)\nverts = [(a, 0), *zip(ix, iy), (b, 0)]\npoly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\nax.add_patch(poly)\n\nax.text(0.5 * (a + b), 30, r\"$\\int_a^b f(x)\\mathrm{d}x$\",\n        horizontalalignment='center', fontsize=20)\n\nfig.text(0.9, 0.05, '$x$')\nfig.text(0.1, 0.9, '$y$')\n\nax.spines[['top', 'right']].set_visible(False)\nax.set_xticks([a, b], labels=['$a$', '$b$'])\nax.set_yticks([])\n\nplt.show()"}, {"file": "lib/matplotlib/gridspec.py", "name": "SubplotSpec._from_subplot_args", "type": "codeblock", "score": 2.953237771987915, "line": 561, "text": "class SubplotSpec:\n\n    @staticmethod\n    def _from_subplot_args(figure, args):\n        \"\"\"\n        Construct a `.SubplotSpec` from a parent `.Figure` and either\n\n        - a `.SubplotSpec` -- returned as is;\n        - one or three numbers -- a MATLAB-style subplot specifier.\n        \"\"\"\n        if len(args) == 1:\n            arg, = args\n            if isinstance(arg, SubplotSpec):\n                return arg\n            elif not isinstance(arg, Integral):\n                raise ValueError(\n                    f\"Single argument to subplot must be a three-digit \"\n                    f\"integer, not {arg!r}\")\n            try:\n                rows, cols, num = map(int, str(arg))\n            except ValueError:\n                raise ValueError(\n                    f\"Single argument to subplot must be a three-digit \"\n                    f\"integer, not {arg!r}\") from None\n        elif len(args) == 3:\n            rows, cols, num = args\n        else:\n            raise _api.nargs_error(\"subplot\", takes=\"1 or 3\", given=len(args))\n\n        gs = GridSpec._check_gridspec_exists(figure, rows, cols)\n        if gs is None:\n            gs = GridSpec(rows, cols, figure=figure)\n        if isinstance(num, tuple) and len(num) == 2:\n            if not all(isinstance(n, Integral) for n in num):\n                raise ValueError(\n                    f\"Subplot specifier tuple must contain integers, not {num}\"\n                )\n            i, j = num\n        else:\n            if not isinstance(num, Integral) or num < 1 or num > rows*cols:\n                raise ValueError(\n                    f\"num must be an integer with 1 <= num <= {rows*cols}, \"\n                    f\"not {num!r}\"\n                )\n            i = j = num\n        return gs[i-1:j]"}, {"file": "lib/matplotlib/streamplot.py", "name": "_get_integrator", "type": "codeblock", "score": 2.8705785274505615, "line": 489, "text": "# Integrator definitions\n# =======================\n\ndef _get_integrator(u, v, dmap, minlength, maxlength, integration_direction):\n\n    # rescale velocity onto grid-coordinates for integrations.\n    u, v = dmap.data2grid(u, v)\n\n    # speed (path length) will be in axes-coordinates\n    u_ax = u / (dmap.grid.nx - 1)\n    v_ax = v / (dmap.grid.ny - 1)\n    speed = np.ma.sqrt(u_ax ** 2 + v_ax ** 2)\n\n    def forward_time(xi, yi):\n        if not dmap.grid.within_grid(xi, yi):\n            raise OutOfBounds\n        ds_dt = interpgrid(speed, xi, yi)\n        if ds_dt == 0:\n            raise TerminateTrajectory()\n        dt_ds = 1. / ds_dt\n        ui = interpgrid(u, xi, yi)\n        vi = interpgrid(v, xi, yi)\n        return ui * dt_ds, vi * dt_ds\n\n    def backward_time(xi, yi):\n        dxi, dyi = forward_time(xi, yi)\n        return -dxi, -dyi\n    # ... other code"}, {"file": "lib/matplotlib/backend_bases.py", "name": "_Backend.show", "type": "codeblock", "score": 2.690934658050537, "line": 3631, "text": "class _Backend:\n    # A backend can be defined by using the following pattern:\n    #\n    # @_Backend.export\n    # class FooBackend(_Backend):\n    #     # override the attributes and methods documented below.\n\n    @classmethod\n    def show(cls, *, block=None):\n        \"\"\"\n        Show all figures.\n\n        `show` blocks by calling `mainloop` if *block* is ``True``, or if it is\n        ``None`` and we are not in `interactive` mode and if IPython's\n        ``%matplotlib`` integration has not been activated.\n        \"\"\"\n        managers = Gcf.get_all_fig_managers()\n        if not managers:\n            return\n        for manager in managers:\n            try:\n                manager.show()  # Emits a warning for non-interactive backend.\n            except NonGuiException as exc:\n                _api.warn_external(str(exc))\n        if cls.mainloop is None:\n            return\n        if block is None:\n            # Hack: Is IPython's %matplotlib integration activated?  If so,\n            # IPython's activate_matplotlib (>= 0.10) tacks a _needmain\n            # attribute onto pyplot.show (always set to False).\n            pyplot_show = getattr(sys.modules.get(\"matplotlib.pyplot\"), \"show\", None)\n            ipython_pylab = hasattr(pyplot_show, \"_needmain\")\n            block = not ipython_pylab and not is_interactive()\n        if block:\n            cls.mainloop()"}, {"file": "lib/matplotlib/streamplot.py", "name": "_integrate_rk12", "type": "codeblock", "score": 2.6740763187408447, "line": 566, "text": "def _integrate_rk12(x0, y0, dmap, f, maxlength, broken_streamlines=True,\n                    integration_max_step_scale=1.0,\n                    integration_max_error_scale=1.0):\n    \"\"\"\n    2nd-order Runge-Kutta algorithm with adaptive step size.\n\n    This method is also referred to as the improved Euler's method, or Heun's\n    method. This method is favored over higher-order methods because:\n\n    1. To get decent looking trajectories and to sample every mask cell\n       on the trajectory we need a small timestep, so a lower order\n       solver doesn't hurt us unless the data is *very* high resolution.\n       In fact, for cases where the user inputs\n       data smaller or of similar grid size to the mask grid, the higher\n       order corrections are negligible because of the very fast linear\n       interpolation used in `interpgrid`.\n\n    2. For high resolution input data (i.e. beyond the mask\n       resolution), we must reduce the timestep. Therefore, an adaptive\n       timestep is more suited to the problem as this would be very hard\n       to judge automatically otherwise.\n\n    This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using\n    similar Python implementations) in most setups.\n    \"\"\"\n    # This error is below that needed to match the RK4 integrator. It\n    # is set for visual reasons -- too low and corners start\n    # appearing ugly and jagged. Can be tuned.\n    maxerror = 0.003 * integration_max_error_scale\n\n    # This limit is important (for all integrators) to avoid the\n    # trajectory skipping some mask cells. We could relax this\n    # condition if we use the code which is commented out below to\n    # increment the location gradually. However, due to the efficient\n    # nature of the interpolation, this doesn't boost speed by much\n    # for quite a bit of complexity.\n    maxds = min(1. / dmap.mask.nx, 1. / dmap.mask.ny, 0.1)\n    maxds *= integration_max_step_scale\n\n    ds = maxds\n    stotal = 0\n    xi = x0\n    yi = y0\n    xyf_traj = []\n    # ... other code"}, {"file": "lib/matplotlib/gridspec.py", "name": "GridSpecBase.__init__", "type": "codeblock", "score": 2.664257526397705, "line": 27, "text": "class GridSpecBase:\n    \"\"\"\n    A base class of GridSpec that specifies the geometry of the grid\n    that a subplot will be placed.\n    \"\"\"\n\n    def __init__(self, nrows, ncols, height_ratios=None, width_ratios=None):\n        \"\"\"\n        Parameters\n        ----------\n        nrows, ncols : int\n            The number of rows and columns of the grid.\n        width_ratios : array-like of length *ncols*, optional\n            Defines the relative widths of the columns. Each column gets a\n            relative width of ``width_ratios[i] / sum(width_ratios)``.\n            If not given, all columns will have the same width.\n        height_ratios : array-like of length *nrows*, optional\n            Defines the relative heights of the rows. Each row gets a\n            relative height of ``height_ratios[i] / sum(height_ratios)``.\n            If not given, all rows will have the same height.\n        \"\"\"\n        if not isinstance(nrows, Integral) or nrows <= 0:\n            raise ValueError(\n                f\"Number of rows must be a positive integer, not {nrows!r}\")\n        if not isinstance(ncols, Integral) or ncols <= 0:\n            raise ValueError(\n                f\"Number of columns must be a positive integer, not {ncols!r}\")\n        self._nrows, self._ncols = nrows, ncols\n        self.set_height_ratios(height_ratios)\n        self.set_width_ratios(width_ratios)"}], "total_results": 10}
{"repo": "matplotlib", "query": "docstring showing Matplotlib version", "top_10": [{"file": "ci/check_version_number.py", "name": "docstring", "type": "codeblock", "score": 3.7604384422302246, "line": 1, "text": "#!/usr/bin/env python3\n\n\"\"\"\nCheck that the version number of the install Matplotlib does not start with 0\n\nTo run:\n    $ python3 -m build .\n    $ pip install dist/matplotlib*.tar.gz for sdist\n    $ pip install dist/matplotlib*.whl for wheel\n    $ ./ci/check_version_number.py\n\"\"\"\nimport sys\n\nimport matplotlib\n\n\nprint(f\"Version {matplotlib.__version__} installed\")\nif matplotlib.__version__[0] == \"0\":\n    sys.exit(\"Version incorrectly starts with 0\")"}, {"file": "lib/matplotlib/pyplot.py", "name": "switch_backend", "type": "codeblock", "score": 3.261052370071411, "line": 506, "text": "def switch_backend(newbackend: str) -> None:\n    # ... other code\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactive.\n    try:\n        install_repl_displayhook()\n    except NotImplementedError as err:\n        _log.warning(\"Fallback to a different backend\")\n        raise ImportError from err"}, {"file": "lib/matplotlib/backends/_backend_tk.py", "name": "FigureManagerTk.resize", "type": "codeblock", "score": 3.157870292663574, "line": 583, "text": "class FigureManagerTk(FigureManagerBase):\n\n    def resize(self, width, height):\n        max_size = 1_400_000  # the measured max on xorg 1.20.8 was 1_409_023\n\n        if (width > max_size or height > max_size) and sys.platform == 'linux':\n            raise ValueError(\n                'You have requested to resize the '\n                f'Tk window to ({width}, {height}), one of which '\n                f'is bigger than {max_size}.  At larger sizes xorg will '\n                'either exit with an error on newer versions (~1.20) or '\n                'cause corruption on older version (~1.19).  We '\n                'do not expect a window over a million pixel wide or tall '\n                'to be intended behavior.')\n        self.canvas._tkcanvas.configure(width=width, height=height)\n\n    def show(self):\n        with _restore_foreground_window_at_end():\n            if not self._shown:\n                def destroy(*args):\n                    Gcf.destroy(self)\n                self.window.protocol(\"WM_DELETE_WINDOW\", destroy)\n                self.window.deiconify()\n                self.canvas._tkcanvas.focus_set()\n            else:\n                self.canvas.draw_idle()\n            if mpl.rcParams['figure.raise_window']:\n                self.canvas.manager.window.attributes('-topmost', 1)\n                self.canvas.manager.window.attributes('-topmost', 0)\n            self._shown = True"}, {"file": "lib/matplotlib/__init__.py", "name": "_get_executable_info", "type": "codeblock", "score": 3.0818774700164795, "line": 435, "text": "@functools.cache\ndef _get_executable_info(name):\n    # ... other code\n\n    if name == \"dvipng\":\n        return impl([\"dvipng\", \"-version\"], \"(?m)^dvipng(?: .*)? (.+)\", \"1.6\")\n    elif name == \"gs\":\n        execs = ([\"gswin32c\", \"gswin64c\", \"mgs\", \"gs\"]  # \"mgs\" for miktex.\n                 if sys.platform == \"win32\" else\n                 [\"gs\"])\n        for e in execs:\n            try:\n                return impl([e, \"--version\"], \"(.*)\", \"9\")\n            except ExecutableNotFoundError:\n                pass\n        message = \"Failed to find a Ghostscript installation\"\n        raise ExecutableNotFoundError(message)\n    elif name == \"inkscape\":\n        try:\n            # Try headless option first (needed for Inkscape version < 1.0):\n            return impl([\"inkscape\", \"--without-gui\", \"-V\"],\n                        \"Inkscape ([^ ]*)\")\n        except ExecutableNotFoundError:\n            pass  # Suppress exception chaining.\n        # If --without-gui is not accepted, we may be using Inkscape >= 1.0 so\n        # try without it:\n        return impl([\"inkscape\", \"-V\"], \"Inkscape ([^ ]*)\")\n    elif name == \"magick\":\n        if sys.platform == \"win32\":\n            # Check the registry to avoid confusing ImageMagick's convert with\n            # Windows's builtin convert.exe.\n            import winreg\n            binpath = \"\"\n            for flag in [0, winreg.KEY_WOW64_32KEY, winreg.KEY_WOW64_64KEY]:\n                try:\n                    with winreg.OpenKeyEx(\n                            winreg.HKEY_LOCAL_MACHINE,\n                            r\"Software\\Imagemagick\\Current\",\n                            0, winreg.KEY_QUERY_VALUE | flag) as hkey:\n                        binpath = winreg.QueryValueEx(hkey, \"BinPath\")[0]\n                except OSError:\n                    pass\n            path = None\n            if binpath:\n                for name in [\"convert.exe\", \"magick.exe\"]:\n                    candidate = Path(binpath, name)\n                    if candidate.exists():\n                        path = str(candidate)\n                        break\n            if path is None:\n                raise ExecutableNotFoundError(\n                    \"Failed to find an ImageMagick installation\")\n        else:\n            path = \"convert\"\n        # Ignore deprecation warning for \"convert\" on IM>=7.1.1-33.\n        info = impl([path, \"--version\"], r\"(?sm:.*^)Version: ImageMagick (\\S*)\")\n        if info.raw_version == \"7.0.10-34\":\n            # https://github.com/ImageMagick/ImageMagick/issues/2720\n            raise ExecutableNotFoundError(\n                f\"You have ImageMagick {info.version}, which is unsupported\")\n        return info\n    elif name == \"pdftocairo\":\n        return impl([\"pdftocairo\", \"-v\"], \"pdftocairo version (.*)\")\n    elif name == \"pdftops\":\n        info = impl([\"pdftops\", \"-v\"], \"^pdftops version (.*)\",\n                    ignore_exit_code=True)\n        if info and not (\n                3 <= info.version.major or\n                # poppler version numbers.\n                parse_version(\"0.9\") <= info.version < parse_version(\"1.0\")):\n            raise ExecutableNotFoundError(\n                f\"You have pdftops version {info.version} but the minimum \"\n                f\"version supported by Matplotlib is 3.0\")\n        return info\n    else:\n        raise ValueError(f\"Unknown executable: {name!r}\")"}, {"file": "lib/matplotlib/__init__.py", "name": "_get_executable_info", "type": "codeblock", "score": 3.0473573207855225, "line": 398, "text": "@functools.cache\ndef _get_executable_info(name):\n\n    def impl(args, regex, min_ver=None, ignore_exit_code=False):\n        # Execute the subprocess specified by args; capture stdout and stderr.\n        # Search for a regex match in the output; if the match succeeds, the\n        # first group of the match is the version.\n        # Return an _ExecInfo if the executable exists, and has a version of\n        # at least min_ver (if set); else, raise ExecutableNotFoundError.\n        try:\n            output = subprocess.check_output(\n                args, stderr=subprocess.STDOUT,\n                text=True, errors=\"replace\", timeout=30)\n        except subprocess.CalledProcessError as _cpe:\n            if ignore_exit_code:\n                output = _cpe.output\n            else:\n                raise ExecutableNotFoundError(str(_cpe)) from _cpe\n        except subprocess.TimeoutExpired as _te:\n            msg = f\"Timed out running {cbook._pformat_subprocess(args)}\"\n            raise ExecutableNotFoundError(msg) from _te\n        except OSError as _ose:\n            raise ExecutableNotFoundError(str(_ose)) from _ose\n        match = re.search(regex, output)\n        if match:\n            raw_version = match.group(1)\n            version = parse_version(raw_version)\n            if min_ver is not None and version < parse_version(min_ver):\n                raise ExecutableNotFoundError(\n                    f\"You have {args[0]} version {version} but the minimum \"\n                    f\"version supported by Matplotlib is {min_ver}\")\n            return _ExecInfo(args[0], raw_version, version)\n        else:\n            raise ExecutableNotFoundError(\n                f\"Failed to determine the version of {args[0]} from \"\n                f\"{' '.join(args)}, which output {output}\")\n\n    if name in os.environ.get(\"_MPLHIDEEXECUTABLES\", \"\").split(\",\"):\n        raise ExecutableNotFoundError(f\"{name} was hidden\")\n    # ... other code"}, {"file": "doc/conf.py", "name": "docstring", "type": "codeblock", "score": 3.032351493835449, "line": 1, "text": "# Matplotlib documentation build configuration file, created by\n# sphinx-quickstart on Fri May  2 12:33:25 2008.\n#\n# This file is execfile()d with the current directory set to its containing\n# dir.\n#\n# The contents of this file are pickled, so don't put values in the namespace\n# that aren't picklable (module imports are okay, they're removed\n# automatically).\n#\n# All configuration values have a default value; values that are commented out\n# serve to show the default value.\n\nfrom datetime import datetime, timezone\nimport logging\nimport os\nfrom pathlib import Path\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport time\nfrom urllib.parse import urlsplit, urlunsplit\nimport warnings\n\nfrom packaging.version import parse as parse_version\nimport sphinx\nimport yaml\n\nimport matplotlib\n\n# debug that building expected version\nprint(f\"Building Documentation for Matplotlib: {matplotlib.__version__}\")\n\n# Release mode enables optimizations and other related options.\nis_release_build = tags.has('release')  # noqa\n\n# are we running circle CI?\nCIRCLECI = 'CIRCLECI' in os.environ\n# are we deploying this build to matplotlib.org/devdocs?\n# This is a copy of the logic in .circleci/deploy-docs.sh\nDEVDOCS = (\n    CIRCLECI and\n    (os.environ.get(\"CIRCLE_PROJECT_USERNAME\") == \"matplotlib\") and\n    (os.environ.get(\"CIRCLE_BRANCH\") == \"main\") and\n    (not os.environ.get(\"CIRCLE_PULL_REQUEST\", \"\").startswith(\n        \"https://github.com/matplotlib/matplotlib/pull\")))\nwarnings.filterwarnings('default', category=UserWarning,\n                        message=r'Matplotlib currently does not support .+ natively\\.')\nwarnings.filterwarnings('ignore', category=DeprecationWarning,\n                        module='importlib',  # used by sphinx.autodoc.importer\n                        message=r'(\\n|.)*module was deprecated.*')"}, {"file": "galleries/examples/mplot3d/surface3d_radial.py", "name": "docstring", "type": "codeblock", "score": 3.018089532852173, "line": 1, "text": "\"\"\"\n=================================\n3D surface with polar coordinates\n=================================\n\nDemonstrates plotting a surface defined in polar coordinates.\nUses the reversed version of the YlGnBu colormap.\nAlso demonstrates writing axis labels with latex math mode.\n\nExample contributed by Armin Moser.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.25, 50)\np = np.linspace(0, 2*np.pi, 50)\nR, P = np.meshgrid(r, p)\nZ = ((R**2 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap=\"YlGnBu_r\")\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 1)\nax.set_xlabel(r'$\\phi_\\mathrm{real}$')\nax.set_ylabel(r'$\\phi_\\mathrm{im}$')\nax.set_zlabel(r'$V(\\phi)$')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: polar,\n#    level: beginner"}, {"file": "galleries/examples/mplot3d/tricontour3d.py", "name": "docstring", "type": "codeblock", "score": 3.0030360221862793, "line": 1, "text": "\"\"\"\n==========================\nTriangular 3D contour plot\n==========================\n\nContour plots of unstructured triangular grids.\n\nThe data used is the same as in the second plot of :doc:`trisurf3d_2`.\n:doc:`tricontourf3d` shows the filled version of this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontour(triang, z, cmap=\"CMRmap\")\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: specialty,\n#    level: intermediate"}, {"file": "galleries/examples/axes_grid1/inset_locator_demo2.py", "name": "docstring", "type": "codeblock", "score": 2.980039119720459, "line": 1, "text": "\"\"\"\n====================\nInset locator demo 2\n====================\n\nThis demo shows how to create a zoomed inset via `.zoomed_inset_axes`.\nIn the first subplot an `.AnchoredSizeBar` shows the zoom effect.\nIn the second subplot a connection to the region of interest is\ncreated via `.mark_inset`.\n\nA version of the second subplot, not using the toolkit, is available in\n:doc:`/gallery/subplots_axes_and_figures/zoom_inset_axes`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nfrom mpl_toolkits.axes_grid1.inset_locator import mark_inset, zoomed_inset_axes\n\nfig, (ax, ax2) = plt.subplots(ncols=2, figsize=[6, 3])\n\n\n# First subplot, showing an inset with a size bar.\nax.set_aspect(1)\n\naxins = zoomed_inset_axes(ax, zoom=0.5, loc='upper right')\n# fix the number of ticks on the inset Axes\naxins.yaxis.get_major_locator().set_params(nbins=7)\naxins.xaxis.get_major_locator().set_params(nbins=7)\naxins.tick_params(labelleft=False, labelbottom=False)\n\n\ndef add_sizebar(ax, size):\n    asb = AnchoredSizeBar(ax.transData,\n                          size,\n                          str(size),\n                          loc=\"lower center\",\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\nadd_sizebar(ax, 0.5)\nadd_sizebar(axins, 0.5)\n\n\n# Second subplot, showing an image with an inset zoom and a marked inset\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nextent = (-3, 4, -4, 3)\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\n\nax2.imshow(Z2, extent=extent, origin=\"lower\")\n\naxins2 = zoomed_inset_axes(ax2, zoom=6, loc=\"upper right\")\naxins2.imshow(Z2, extent=extent, origin=\"lower\")\n\n# subregion of the original image"}, {"file": "lib/matplotlib/backends/_backend_tk.py", "name": "FigureManagerTk.create_with_canvas", "type": "codeblock", "score": 2.976250171661377, "line": 528, "text": "class FigureManagerTk(FigureManagerBase):\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        with _restore_foreground_window_at_end():\n            if cbook._get_running_interactive_framework() is None:\n                cbook._setup_new_guiapp()\n                _c_internal_utils.Win32_SetProcessDpiAwareness_max()\n            window = tk.Tk(className=\"matplotlib\")\n            window.withdraw()\n\n            # Put a Matplotlib icon on the window rather than the default tk\n            # icon. See https://www.tcl.tk/man/tcl/TkCmd/wm.html#M50\n            #\n            # `ImageTk` can be replaced with `tk` whenever the minimum\n            # supported Tk version is increased to 8.6, as Tk 8.6+ natively\n            # supports PNG images.\n            icon_fname = str(cbook._get_data_path(\n                'images/matplotlib.png'))\n            icon_img = ImageTk.PhotoImage(file=icon_fname, master=window)\n\n            icon_fname_large = str(cbook._get_data_path(\n                'images/matplotlib_large.png'))\n            icon_img_large = ImageTk.PhotoImage(\n                file=icon_fname_large, master=window)\n\n            window.iconphoto(False, icon_img_large, icon_img)\n\n            canvas = canvas_class(figure, master=window)\n            manager = cls(canvas, num, window)\n            if mpl.is_interactive():\n                manager.show()\n                canvas.draw_idle()\n            return manager"}], "total_results": 10}
{"repo": "matplotlib", "query": "backend version information", "top_10": [{"file": "lib/matplotlib/figure.py", "name": "Figure.__setstate__", "type": "codeblock", "score": 5.2644829750061035, "line": 3314, "text": "@_docstring.interpd\nclass Figure(FigureBase):\n\n    def __setstate__(self, state):\n        version = state.pop('__mpl_version__')\n        restore_to_pylab = state.pop('_restore_to_pylab', False)\n\n        if version != mpl.__version__:\n            _api.warn_external(\n                f\"This figure was saved with matplotlib version {version} and \"\n                f\"loaded with {mpl.__version__} so may not function correctly.\"\n            )\n        self.__dict__ = state\n\n        # re-initialise some of the unstored state information\n        FigureCanvasBase(self)  # Set self.canvas.\n\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            backend = plt._get_backend_mod()\n            mgr = backend.new_figure_manager_given_figure(num, self)\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n\n        self.stale = True\n\n    def add_axobserver(self, func):\n        \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n        # Connect a wrapper lambda and not func itself, to avoid it being\n        # weakref-collected.\n        self._axobservers.connect(\"_axes_change_event\", lambda arg: func(arg))"}, {"file": "lib/matplotlib/backends/backend_pgf.py", "name": "PdfPages", "type": "codeblock", "score": 4.41257381439209, "line": 885, "text": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file using the pgf backend\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n    \"\"\"\n\n    def __init__(self, filename, *, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n\n            Note that some versions of LaTeX engines may ignore the 'Producer'\n            key and set it to themselves.\n        \"\"\"\n        self._output_name = filename\n        self._n_figures = 0\n        self._metadata = (metadata or {}).copy()\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n        self._file = BytesIO()"}, {"file": "lib/matplotlib/backends/_backend_tk.py", "name": "imports", "type": "codeblock", "score": 3.6333742141723633, "line": 1, "text": "import uuid\nimport weakref\nfrom contextlib import contextmanager\nimport logging\nimport math\nimport os.path\nimport pathlib\nimport sys\nimport tkinter as tk\nimport tkinter.filedialog\nimport tkinter.font\nimport tkinter.messagebox\nfrom tkinter.simpledialog import SimpleDialog\n\nimport numpy as np\nfrom PIL import Image, ImageTk\n\nimport matplotlib as mpl\nfrom matplotlib import _api, backend_tools, cbook, _c_internal_utils\nfrom matplotlib.backend_bases import (\n    _Backend, FigureCanvasBase, FigureManagerBase, NavigationToolbar2,\n    TimerBase, ToolContainerBase, cursors, _Mode, MouseButton,\n    CloseEvent, KeyEvent, LocationEvent, MouseEvent, ResizeEvent)\nfrom matplotlib._pylab_helpers import Gcf\n\ntry:\n    from . import _tkagg\n    from ._tkagg import TK_PHOTO_COMPOSITE_OVERLAY, TK_PHOTO_COMPOSITE_SET\nexcept ImportError as e:\n    # catch incompatibility of python-build-standalone with Tk\n    cause1 = getattr(e, '__cause__', None)\n    cause2 = getattr(cause1, '__cause__', None)\n    if (isinstance(cause1, ImportError) and\n            isinstance(cause2, AttributeError) and\n            \"'_tkinter' has no attribute '__file__'\" in str(cause2)):\n\n        is_uv_python = \"/uv/python\" in (os.path.realpath(sys.executable))\n        if is_uv_python:\n            raise ImportError(\n                \"Failed to import tkagg backend. You appear to be using an outdated \"\n                \"version of uv's managed Python distribution which is not compatible \"\n                \"with Tk. Please upgrade to the latest uv version, then update \"\n                \"Python with: `uv python upgrade --reinstall`\"\n                ) from e\n        else:\n            raise ImportError(\n                \"Failed to import tkagg backend. This is likely caused by using a \"\n                \"Python executable based on python-build-standalone, which is not \"\n                \"compatible with Tk. Recent versions of python-build-standalone \"\n                \"should be compatible with Tk. Please update your python version \"\n                \"or select another backend.\"\n                ) from e\n    else:\n        raise\n\n\n_log = logging.getLogger(__name__)"}, {"file": "lib/matplotlib/pyplot.py", "name": "switch_backend", "type": "codeblock", "score": 3.58467435836792, "line": 506, "text": "def switch_backend(newbackend: str) -> None:\n    # ... other code\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactive.\n    try:\n        install_repl_displayhook()\n    except NotImplementedError as err:\n        _log.warning(\"Fallback to a different backend\")\n        raise ImportError from err"}, {"file": "lib/matplotlib/backends/backend_ps.py", "name": "_version_and_breakpoints", "type": "codeblock", "score": 3.552954912185669, "line": 256, "text": "def _version_and_breakpoints(loca, fontdata):\n    \"\"\"\n    Read the version number of the font and determine sfnts breakpoints.\n\n    When a TrueType font file is written as a Type 42 font, it has to be\n    broken into substrings of at most 65535 bytes. These substrings must\n    begin at font table boundaries or glyph boundaries in the glyf table.\n    This function determines all possible breakpoints and it is the caller's\n    responsibility to do the splitting.\n\n    Helper function for _font_to_ps_type42.\n\n    Parameters\n    ----------\n    loca : fontTools.ttLib._l_o_c_a.table__l_o_c_a or None\n        The loca table of the font if available\n    fontdata : bytes\n        The raw data of the font\n\n    Returns\n    -------\n    version : tuple[int, int]\n        A 2-tuple of the major version number and minor version number.\n    breakpoints : list[int]\n        The breakpoints is a sorted list of offsets into fontdata; if loca is not\n        available, just the table boundaries.\n    \"\"\"\n    v1, v2, numTables = struct.unpack('>3h', fontdata[:6])\n    version = (v1, v2)\n\n    tables = {}\n    for i in range(numTables):\n        tag, _, offset, _ = struct.unpack('>4sIII', fontdata[12 + i*16:12 + (i+1)*16])\n        tables[tag.decode('ascii')] = offset\n    if loca is not None:\n        glyf_breakpoints = {tables['glyf'] + offset for offset in loca.locations[:-1]}\n    else:\n        glyf_breakpoints = set()\n    breakpoints = sorted({*tables.values(), *glyf_breakpoints, len(fontdata)})\n\n    return version, breakpoints"}, {"file": "lib/matplotlib/backends/backend_pdf.py", "name": "PdfPages.savefig", "type": "codeblock", "score": 3.4755759239196777, "line": 2739, "text": "class PdfPages:\n\n    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        if self._file is not None:\n            self._file.finalize()\n            self._file.close()\n            self._file = None\n\n    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._ensure_file().infoDict\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(f\"No figure {figure}\")\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        figure.savefig(self, format=\"pdf\", backend=\"pdf\", **kwargs)"}, {"file": "lib/matplotlib/backends/backend_ps.py", "name": "_serialize_type42", "type": "codeblock", "score": 3.253972053527832, "line": 208, "text": "def _serialize_type42(font, subset, fontdata):\n    \"\"\"\n    Output a PostScript Type-42 format representation of font\n\n    Parameters\n    ----------\n    font : fontTools.ttLib.ttFont.TTFont\n        The original font object\n    subset : fontTools.ttLib.ttFont.TTFont\n        The subset font object\n    fontdata : bytes\n        The raw font data in TTF format\n\n    Returns\n    -------\n    str\n        The Type-42 formatted font\n    \"\"\"\n    version, breakpoints = _version_and_breakpoints(font.get('loca'), fontdata)\n    post = font['post']\n    name = font['name']\n    chars = _generate_charstrings(subset)\n    sfnts = _generate_sfnts(fontdata, subset, breakpoints)\n    return textwrap.dedent(f\"\"\"\n        %%!PS-TrueTypeFont-{version[0]}.{version[1]}-{font['head'].fontRevision:.7f}\n        10 dict begin\n        /FontType 42 def\n        /FontMatrix [1 0 0 1 0 0] def\n        /FontName /{name.getDebugName(6)} def\n        /FontInfo 7 dict dup begin\n        /FullName ({name.getDebugName(4)}) def\n        /FamilyName ({name.getDebugName(1)}) def\n        /Version ({name.getDebugName(5)}) def\n        /ItalicAngle {post.italicAngle} def\n        /isFixedPitch {'true' if post.isFixedPitch else 'false'} def\n        /UnderlinePosition {post.underlinePosition} def\n        /UnderlineThickness {post.underlineThickness} def\n        end readonly def\n        /Encoding StandardEncoding def\n        /FontBBox [{_nums_to_str(*_bounds(font))}] def\n        /PaintType 0 def\n        /CIDMap 0 def\n        {chars}\n        {sfnts}\n        FontName currentdict end definefont pop\n        \"\"\")"}, {"file": "lib/matplotlib/backend_bases.py", "name": "NavigationToolbar2.save_figure", "type": "codeblock", "score": 3.216219902038574, "line": 3346, "text": "class NavigationToolbar2:\n\n    def save_figure(self, *args):\n        \"\"\"\n        Save the current figure.\n\n        Backend implementations may choose to return\n        the absolute path of the saved file, if any, as\n        a string.\n\n        If no file is created then `None` is returned.\n\n        If the backend does not implement this functionality\n        then `NavigationToolbar2.UNKNOWN_SAVED_STATUS` is returned.\n\n        Returns\n        -------\n        str or `NavigationToolbar2.UNKNOWN_SAVED_STATUS` or `None`\n            The filepath of the saved figure.\n            Returns `None` if figure is not saved.\n            Returns `NavigationToolbar2.UNKNOWN_SAVED_STATUS` when\n            the backend does not provide the information.\n        \"\"\"\n        raise NotImplementedError\n\n    def update(self):\n        \"\"\"Reset the Axes stack.\"\"\"\n        self._nav_stack.clear()\n        self.set_history_buttons()\n\n    def set_history_buttons(self):\n        \"\"\"Enable or disable the back/forward button.\"\"\""}, {"file": "lib/matplotlib/backends/qt_compat.py", "name": "impl:45", "type": "codeblock", "score": 3.1112256050109863, "line": 108, "text": "if QT_API in [QT_API_PYQT6, QT_API_PYQT5, QT_API_PYSIDE6, QT_API_PYSIDE2]:\n    _setup_pyqt5plus()\nelif QT_API is None:  # See above re: dict.__getitem__.\n    if _QT_FORCE_QT5_BINDING:\n        _candidates = [\n            (_setup_pyqt5plus, QT_API_PYQT5),\n            (_setup_pyqt5plus, QT_API_PYSIDE2),\n        ]\n    else:\n        _candidates = [\n            (_setup_pyqt5plus, QT_API_PYQT6),\n            (_setup_pyqt5plus, QT_API_PYSIDE6),\n            (_setup_pyqt5plus, QT_API_PYQT5),\n            (_setup_pyqt5plus, QT_API_PYSIDE2),\n        ]\n    for _setup, QT_API in _candidates:\n        try:\n            _setup()\n        except ImportError:\n            continue\n        break\n    else:\n        raise ImportError(\n            \"Failed to import any of the following Qt binding modules: {}\"\n            .format(\", \".join([QT_API for _, QT_API in _candidates]))\n        )\nelse:  # We should not get there.\n    raise AssertionError(f\"Unexpected QT_API: {QT_API}\")\n_version_info = tuple(QtCore.QLibraryInfo.version().segments())\n\n\nif _version_info < (5, 12):\n    raise ImportError(\n        f\"The Qt version imported is \"\n        f\"{QtCore.QLibraryInfo.version().toString()} but Matplotlib requires \"\n        f\"Qt>=5.12\")\n\n\n# Fixes issues with Big Sur\n# https://bugreports.qt.io/browse/QTBUG-87014, fixed in qt 5.15.2\nif (sys.platform == 'darwin' and\n        parse_version(platform.mac_ver()[0]) >= parse_version(\"10.16\") and\n        _version_info < (5, 15, 2)):\n    os.environ.setdefault(\"QT_MAC_WANTS_LAYER\", \"1\")\n\n\n# Backports.\n\n\ndef _exec(obj):\n    # exec on PyQt6, exec_ elsewhere.\n    obj.exec() if hasattr(obj, \"exec\") else obj.exec_()"}, {"file": "lib/matplotlib/backend_bases.py", "name": "NavigationToolbar2", "type": "codeblock", "score": 3.102924346923828, "line": 2863, "text": "class NavigationToolbar2:\n    \"\"\"\n    Base class for the navigation cursor, version 2.\n\n    Backends must implement a canvas that handles connections for\n    'button_press_event' and 'button_release_event'.  See\n    :meth:`FigureCanvasBase.mpl_connect` for more information.\n\n    They must also define\n\n    :meth:`save_figure`\n        Save the current figure.\n\n    :meth:`draw_rubberband` (optional)\n        Draw the zoom to rect \"rubberband\" rectangle.\n\n    :meth:`set_message` (optional)\n        Display message.\n\n    :meth:`set_history_buttons` (optional)\n        You can change the history back / forward buttons to indicate disabled / enabled\n        state.\n\n    and override ``__init__`` to set up the toolbar -- without forgetting to\n    call the base-class init.  Typically, ``__init__`` needs to set up toolbar\n    buttons connected to the `home`, `back`, `forward`, `pan`, `zoom`, and\n    `save_figure` methods and using standard icons in the \"images\" subdirectory\n    of the data path.\n\n    That's it, we'll do the rest!\n    \"\"\"\n\n    # list of toolitems to add to the toolbar, format is:\n    # (\n    #   text, # the text of the button (often not visible to users)\n    #   tooltip_text, # the tooltip shown on hover (where possible)\n    #   image_file, # name of the image for the button (without the extension)\n    #   name_of_method, # name of the method in NavigationToolbar2 to call\n    # )\n    toolitems = (\n        ('Home', 'Reset original view', 'home', 'home'),\n        ('Back', 'Back to previous view', 'back', 'back'),\n        ('Forward', 'Forward to next view', 'forward', 'forward'),\n        (None, None, None, None),\n        ('Pan',\n         'Left button pans, Right button zooms\\n'\n         'x/y fixes axis, CTRL fixes aspect',\n         'move', 'pan'),\n        ('Zoom', 'Zoom to rectangle\\nx/y fixes axis', 'zoom_to_rect', 'zoom'),\n        ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'),\n        (None, None, None, None),\n        ('Save', 'Save the figure', 'filesave', 'save_figure'),\n      )"}], "total_results": 10}
{"repo": "matplotlib", "query": "setup.py writing version.py", "top_10": [{"file": "doc/conf.py", "name": "generate_ScalarMappable_docs", "type": "codeblock", "score": 5.411220550537109, "line": 915, "text": "# -----------------------------------------------------------------------------\n# Sphinx setup\n# -----------------------------------------------------------------------------\ndef setup(app):\n    if any(st in version for st in ('post', 'dev', 'alpha', 'beta')):\n        bld_type = 'dev'\n    else:\n        bld_type = 'rel'\n    app.add_config_value('skip_sub_dirs', 0, '')\n    app.add_config_value('releaselevel', bld_type, 'env')\n    app.connect('autodoc-process-bases', autodoc_process_bases)\n    if sphinx.version_info[:2] < (7, 1):\n        app.connect('html-page-context', add_html_cache_busting, priority=1000)\n    generate_ScalarMappable_docs()"}, {"file": "lib/matplotlib/sphinxext/roles.py", "name": "setup", "type": "codeblock", "score": 5.289587020874023, "line": 138, "text": "def setup(app):\n    app.add_role(\"rc\", _rcparam_role)\n    app.add_role(\"mpltype\", _mpltype_role)\n    app.add_node(\n        _QueryReference,\n        html=(_visit_query_reference_node, _depart_query_reference_node),\n        latex=(_visit_query_reference_node, _depart_query_reference_node),\n        text=(_visit_query_reference_node, _depart_query_reference_node),\n    )\n    return {\"version\": matplotlib.__version__,\n            \"parallel_read_safe\": True, \"parallel_write_safe\": True}"}, {"file": "lib/matplotlib/animation.py", "name": "AbstractMovieWriter.saving", "type": "codeblock", "score": 5.105864524841309, "line": 205, "text": "class AbstractMovieWriter(abc.ABC):\n\n    @abc.abstractmethod\n    def finish(self):\n        \"\"\"Finish any processing for writing the movie.\"\"\"\n\n    @contextlib.contextmanager\n    def saving(self, fig, outfile, dpi, *args, **kwargs):\n        \"\"\"\n        Context manager to facilitate writing the movie file.\n\n        ``*args, **kw`` are any parameters that should be passed to `setup`.\n        \"\"\"\n        if mpl.rcParams['savefig.bbox'] == 'tight':\n            _log.info(\"Disabling savefig.bbox = 'tight', as it may cause \"\n                      \"frame size to vary, which is inappropriate for \"\n                      \"animation.\")\n\n        # This particular sequence is what contextlib.contextmanager wants\n        self.setup(fig, outfile, dpi, *args, **kwargs)\n        with mpl.rc_context({'savefig.bbox': None}):\n            try:\n                yield self\n            finally:\n                self.finish()"}, {"file": "lib/matplotlib/sphinxext/figmpl_directive.py", "name": "depart_figmpl_latex", "type": "codeblock", "score": 5.078592777252197, "line": 255, "text": "def visit_figmpl_latex(self, node):\n\n    if node['srcset'] is not None:\n        imagedir, srcset = _copy_images_figmpl(self, node)\n        maxmult = -1\n        # choose the highest res version for latex:\n        maxmult = max(srcset, default=-1)\n        node['uri'] = PurePath(srcset[maxmult]).name\n\n    self.visit_figure(node)\n\n\ndef depart_figmpl_html(self, node):\n    pass\n\n\ndef depart_figmpl_latex(self, node):\n    self.depart_figure(node)\n\n\ndef figurempl_addnode(app):\n    app.add_node(figmplnode,\n                 html=(visit_figmpl_html, depart_figmpl_html),\n                 latex=(visit_figmpl_latex, depart_figmpl_latex))\n\n\ndef setup(app):\n    app.add_directive(\"figure-mpl\", FigureMpl)\n    figurempl_addnode(app)\n    metadata = {'parallel_read_safe': True, 'parallel_write_safe': True,\n                'version': matplotlib.__version__}\n    return metadata"}, {"file": "lib/matplotlib/__init__.py", "name": "_init_tests", "type": "codeblock", "score": 5.031738758087158, "line": 1343, "text": "def _init_tests():\n    # The version of FreeType to install locally for running the tests. This must match\n    # the value in `meson.build`.\n    LOCAL_FREETYPE_VERSION = '2.6.1'\n\n    from matplotlib import ft2font\n    if (ft2font.__freetype_version__ != LOCAL_FREETYPE_VERSION or\n            ft2font.__freetype_build_type__ != 'local'):\n        _log.warning(\n            \"Matplotlib is not built with the correct FreeType version to run tests.  \"\n            \"Rebuild without setting system-freetype=true in Meson setup options.  \"\n            \"Expect many image comparison failures below.  \"\n            \"Expected freetype version %s.  \"\n            \"Found freetype version %s.  \"\n            \"Freetype build type is %slocal.\",\n            LOCAL_FREETYPE_VERSION,\n            ft2font.__freetype_version__,\n            \"\" if ft2font.__freetype_build_type__ == 'local' else \"not \")"}, {"file": "lib/matplotlib/animation.py", "name": "AbstractMovieWriter.setup", "type": "codeblock", "score": 5.022751808166504, "line": 153, "text": "class AbstractMovieWriter(abc.ABC):\n\n    @abc.abstractmethod\n    def setup(self, fig, outfile, dpi=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure object that contains the information for frames.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The DPI (or resolution) for the file.  This controls the size\n            in pixels of the resulting movie file.\n        \"\"\"\n        # Check that path is valid\n        Path(outfile).parent.resolve(strict=True)\n        self.outfile = outfile\n        self.fig = fig\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi"}, {"file": "lib/matplotlib/animation.py", "name": "MovieWriter.setup", "type": "codeblock", "score": 4.783743858337402, "line": 307, "text": "class MovieWriter(AbstractMovieWriter):\n\n    def setup(self, fig, outfile, dpi=None):\n        # docstring inherited\n        super().setup(fig, outfile, dpi=dpi)\n        self._w, self._h = self._adjust_frame_size()\n        # Run here so that grab_frame() can write the data to a pipe. This\n        # eliminates the need for temp files.\n        self._run()\n\n    def _run(self):\n        # Uses subprocess to call the program for assembling frames into a\n        # movie file.  *args* returns the sequence of command line arguments\n        # from a few configuration options.\n        command = self._args()\n        _log.info('MovieWriter._run: running command: %s',\n                  cbook._pformat_subprocess(command))\n        PIPE = subprocess.PIPE\n        self._proc = subprocess.Popen(\n            command, stdin=PIPE, stdout=PIPE, stderr=PIPE,\n            creationflags=subprocess_creation_flags)"}, {"file": "lib/matplotlib/animation.py", "name": "FileMovieWriter.setup", "type": "codeblock", "score": 4.6946120262146, "line": 375, "text": "class FileMovieWriter(MovieWriter):\n    \"\"\"\n    `MovieWriter` for writing to individual files and stitching at the end.\n\n    This must be sub-classed to be useful.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.frame_format = mpl.rcParams['animation.frame_format']\n\n    def setup(self, fig, outfile, dpi=None, frame_prefix=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure to grab the rendered frames from.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The dpi of the output file. This, with the figure size,\n            controls the size in pixels of the resulting movie file.\n        frame_prefix : str, optional\n            The filename prefix to use for temporary files.  If *None* (the\n            default), files are written to a temporary directory which is\n            deleted by `finish`; if not *None*, no temporary files are\n            deleted.\n        \"\"\"\n        # Check that path is valid\n        Path(outfile).parent.resolve(strict=True)\n        self.fig = fig\n        self.outfile = outfile\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi\n        self._adjust_frame_size()\n\n        if frame_prefix is None:\n            self._tmpdir = TemporaryDirectory()\n            self.temp_prefix = str(Path(self._tmpdir.name, 'tmp'))\n        else:\n            self._tmpdir = None\n            self.temp_prefix = frame_prefix\n        self._frame_counter = 0  # used for generating sequential file names\n        self._temp_paths = list()\n        self.fname_format_str = '%s%%07d.%s'"}, {"file": "lib/matplotlib/animation.py", "name": "AbstractMovieWriter.__init__", "type": "codeblock", "score": 4.2718048095703125, "line": 125, "text": "writers = MovieWriterRegistry()\n\n\nclass AbstractMovieWriter(abc.ABC):\n    \"\"\"\n    Abstract base class for writing movies, providing a way to grab frames by\n    calling `~AbstractMovieWriter.grab_frame`.\n\n    `setup` is called to start the process and `finish` is called afterwards.\n    `saving` is provided as a context manager to facilitate this process as ::\n\n        with moviewriter.saving(fig, outfile='myfile.mp4', dpi=100):\n            # Iterate over frames\n            moviewriter.grab_frame(**savefig_kwargs)\n\n    The use of the context manager ensures that `setup` and `finish` are\n    performed as necessary.\n\n    An instance of a concrete subclass of this class can be given as the\n    ``writer`` argument of `Animation.save()`.\n    \"\"\"\n\n    def __init__(self, fps=5, metadata=None, codec=None, bitrate=None):\n        self.fps = fps\n        self.metadata = metadata if metadata is not None else {}\n        self.codec = mpl._val_or_rc(codec, 'animation.codec')\n        self.bitrate = mpl._val_or_rc(bitrate, 'animation.bitrate')"}, {"file": "tools/cache_zenodo_svg.py", "name": "impl", "type": "codeblock", "score": 4.034342288970947, "line": 64, "text": "if __name__ == \"__main__\":\n    data = {\n        \"v3.10.7\": \"17298696\",\n        \"v3.10.6\": \"16999430\",\n        \"v3.10.5\": \"16644850\",\n        \"v3.10.3\": \"15375714\",\n        \"v3.10.1\": \"14940554\",\n        \"v3.10.0\": \"14464227\",\n        \"v3.9.4\": \"14436121\",\n        \"v3.9.3\": \"14249941\",\n        \"v3.9.2\": \"13308876\",\n        \"v3.9.1\": \"12652732\",\n        \"v3.9.0\": \"11201097\",\n        \"v3.8.4\": \"10916799\",\n        \"v3.8.3\": \"10661079\",\n        \"v3.8.2\": \"10150955\",\n        \"v3.8.1\": \"10059757\",\n        \"v3.8.0\": \"8347255\",\n        \"v3.7.3\": \"8336761\",\n        \"v3.7.2\": \"8118151\",\n        \"v3.7.1\": \"7697899\",\n        \"v3.7.0\": \"7637593\",\n        \"v3.6.3\": \"7527665\",\n        \"v3.6.2\": \"7275322\",\n        \"v3.6.1\": \"7162185\",\n        \"v3.6.0\": \"7084615\",\n        \"v3.5.3\": \"6982547\",\n        \"v3.5.2\": \"6513224\",\n        \"v3.5.1\": \"5773480\",\n        \"v3.5.0\": \"5706396\",\n        \"v3.4.3\": \"5194481\",\n        \"v3.4.2\": \"4743323\",\n        \"v3.4.1\": \"4649959\",\n        \"v3.4.0\": \"4638398\",\n        \"v3.3.4\": \"4475376\",\n        \"v3.3.3\": \"4268928\",\n        \"v3.3.2\": \"4030140\",\n        \"v3.3.1\": \"3984190\",\n        \"v3.3.0\": \"3948793\",\n        \"v3.2.2\": \"3898017\",\n        \"v3.2.1\": \"3714460\",\n        \"v3.2.0\": \"3695547\",\n        \"v3.1.3\": \"3633844\",\n        \"v3.1.2\": \"3563226\",\n        \"v3.1.1\": \"3264781\",\n        \"v3.1.0\": \"2893252\",\n        \"v3.0.3\": \"2577644\",\n        \"v3.0.2\": \"1482099\",\n        \"v3.0.1\": \"1482098\",\n        \"v2.2.5\": \"3633833\",\n        \"v3.0.0\": \"1420605\",\n        \"v2.2.4\": \"2669103\",\n        \"v2.2.3\": \"1343133\",\n        \"v2.2.2\": \"1202077\",\n        \"v2.2.1\": \"1202050\",\n        \"v2.2.0\": \"1189358\",\n        \"v2.1.2\": \"1154287\",\n        \"v2.1.1\": \"1098480\",\n        \"v2.1.0\": \"1004650\",\n        \"v2.0.2\": \"573577\",\n        \"v2.0.1\": \"570311\",\n        \"v2.0.0\": \"248351\",\n        \"v1.5.3\": \"61948\",\n        \"v1.5.2\": \"56926\",\n        \"v1.5.1\": \"44579\",\n        \"v1.5.0\": \"32914\",\n        \"v1.4.3\": \"15423\",\n        \"v1.4.2\": \"12400\",\n        \"v1.4.1\": \"12287\",\n        \"v1.4.0\": \"11451\",\n    }\n    doc_dir = Path(__file__).parent.parent.absolute() / \"doc\"\n    target_dir = doc_dir / \"_static/zenodo_cache\"\n    citing = doc_dir / \"project/citing.rst\"\n    target_dir.mkdir(exist_ok=True, parents=True)\n    header = []\n    footer = []\n    with open(citing) as fin:\n        target = header\n        for ln in fin:\n            if target is not None:\n                target.append(ln.rstrip())\n            if ln.strip() == \".. START OF AUTOGENERATED\":\n                target.extend([\"\", \"\"])\n                target = None\n            if ln.strip() == \".. END OF AUTOGENERATED\":\n                target = footer\n                target.append(ln.rstrip())\n\n    with open(citing, \"w\") as fout:\n        fout.write(\"\\n\".join(header))\n        for version, doi in data.items():\n            svg_path = target_dir / f\"{doi}.svg\"\n            if not svg_path.exists():\n                url = f\"https://zenodo.org/badge/doi/10.5281/zenodo.{doi}.svg\"\n                payload = download_or_cache(url, f\"{doi}.svg\")\n                with open(svg_path, \"xb\") as svgout:\n                    svgout.write(payload.read())\n            fout.write(\n                f\"\"\"\n{version}\n   .. image:: ../_static/zenodo_cache/{doi}.svg\n      :target:  https://doi.org/10.5281/zenodo.{doi}\"\"\"\n            )\n        fout.write(\"\\n\\n\")\n        fout.write(\"\\n\".join(footer))\n        fout.write(\"\\n\")"}], "total_results": 10}
{"repo": "matplotlib", "query": "pyproject version hooks", "top_10": [{"file": "lib/matplotlib/pyplot.py", "name": "install_repl_displayhook", "type": "codeblock", "score": 4.841198921203613, "line": 301, "text": "def install_repl_displayhook() -> None:\n    \"\"\"\n    Connect to the display hook of the current shell.\n\n    The display hook gets called when the read-evaluate-print-loop (REPL) of\n    the shell has finished the execution of a command. We use this callback\n    to be able to automatically update a figure in interactive mode.\n\n    This works both with IPython and with vanilla python shells.\n    \"\"\"\n    global _REPL_DISPLAYHOOK\n\n    if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n        return\n\n    # See if we have IPython hooks around, if so use them.\n    # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n    # entries can also have been explicitly set to None.\n    mod_ipython = sys.modules.get(\"IPython\")\n    if not mod_ipython:\n        _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n        return\n    ip = mod_ipython.get_ipython()\n    if not ip:\n        _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n        return\n\n    ip.events.register(\"post_execute\", _draw_all_if_interactive)\n    _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON\n\n    if mod_ipython.version_info[:2] < (8, 24):\n        # Use of backend2gui is not needed for IPython >= 8.24 as that functionality\n        # has been moved to Matplotlib.\n        # This code can be removed when Python 3.12, the latest version supported by\n        # IPython < 8.24, reaches end-of-life in late 2028.\n        from IPython.core.pylabtools import backend2gui\n        ipython_gui_name = backend2gui.get(get_backend())\n    else:\n        _, ipython_gui_name = backend_registry.resolve_backend(get_backend())\n    # trigger IPython's eventloop integration, if available\n    if ipython_gui_name:\n        ip.enable_gui(ipython_gui_name)"}, {"file": "galleries/examples/user_interfaces/mplcvd.py", "name": "docstring", "type": "codeblock", "score": 4.550679683685303, "line": 1, "text": "\"\"\"\nmplcvd -- an example of figure hook\n===================================\n\nTo use this hook, ensure that this module is in your ``PYTHONPATH``, and set\n``rcParams[\"figure.hooks\"] = [\"mplcvd:setup\"]``.  This hook depends on\nthe ``colorspacious`` third-party module.\n\"\"\"\n\nimport functools\nfrom pathlib import Path\n\nimport colorspacious\n\nimport numpy as np\n\n_BUTTON_NAME = \"Filter\"\n_BUTTON_HELP = \"Simulate color vision deficiencies\"\n_MENU_ENTRIES = {\n    \"None\": None,\n    \"Greyscale\": \"greyscale\",\n    \"Deuteranopia\": \"deuteranomaly\",\n    \"Protanopia\": \"protanomaly\",\n    \"Tritanopia\": \"tritanomaly\",\n}"}, {"file": "lib/matplotlib/backends/registry.py", "name": "BackendRegistry._read_entry_points", "type": "codeblock", "score": 4.452549457550049, "line": 128, "text": "class BackendRegistry:\n\n    def _read_entry_points(self):\n        # Read entry points of modules that self-advertise as Matplotlib backends.\n        # Expects entry points like this one from matplotlib-inline (in pyproject.toml\n        # format):\n        #   [project.entry-points.\"matplotlib.backend\"]\n        #   inline = \"matplotlib_inline.backend_inline\"\n        import importlib.metadata as im\n\n        entry_points = im.entry_points(group=\"matplotlib.backend\")\n        entries = [(entry.name, entry.value) for entry in entry_points]\n\n        # For backward compatibility, if matplotlib-inline and/or ipympl are installed\n        # but too old to include entry points, create them. Do not import ipympl\n        # directly as this calls matplotlib.use() whilst in this function.\n        def backward_compatible_entry_points(\n                entries, module_name, threshold_version, names, target):\n            from matplotlib import _parse_to_version_info\n            try:\n                module_version = im.version(module_name)\n                if _parse_to_version_info(module_version) < threshold_version:\n                    for name in names:\n                        entries.append((name, target))\n            except im.PackageNotFoundError:\n                pass\n\n        names = [entry[0] for entry in entries]\n        if \"inline\" not in names:\n            backward_compatible_entry_points(\n                entries, \"matplotlib_inline\", (0, 1, 7), [\"inline\"],\n                \"matplotlib_inline.backend_inline\")\n        if \"ipympl\" not in names:\n            backward_compatible_entry_points(\n                entries, \"ipympl\", (0, 9, 4), [\"ipympl\", \"widget\"],\n                \"ipympl.backend_nbagg\")\n\n        return entries"}, {"file": "lib/matplotlib/pyplot.py", "name": "switch_backend", "type": "codeblock", "score": 3.879070281982422, "line": 506, "text": "def switch_backend(newbackend: str) -> None:\n    # ... other code\n    if (show is None\n            or (manager_pyplot_show is not None\n                and manager_pyplot_show != base_pyplot_show)):\n        if not manager_pyplot_show:\n            raise ValueError(\n                f\"Backend {newbackend} defines neither FigureCanvas.manager_class nor \"\n                f\"a toplevel show function\")\n        _pyplot_show = cast('Any', manager_class).pyplot_show\n        backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n\n    _log.debug(\"Loaded backend %s version %s.\",\n               newbackend, backend_mod.backend_version)\n\n    if newbackend in (\"ipympl\", \"widget\"):\n        # ipympl < 0.9.4 expects rcParams[\"backend\"] to be the fully-qualified backend\n        # name \"module://ipympl.backend_nbagg\" not short names \"ipympl\" or \"widget\".\n        import importlib.metadata as im\n        from matplotlib import _parse_to_version_info  # type: ignore[attr-defined]\n        try:\n            module_version = im.version(\"ipympl\")\n            if _parse_to_version_info(module_version) < (0, 9, 4):\n                newbackend = \"module://ipympl.backend_nbagg\"\n        except im.PackageNotFoundError:\n            pass\n\n    rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n    _backend_mod = backend_mod\n    for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n        globals()[func_name].__signature__ = inspect.signature(\n            getattr(backend_mod, func_name))\n\n    # Need to keep a global reference to the backend for compatibility reasons.\n    # See https://github.com/matplotlib/matplotlib/issues/6092\n    matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n\n    # Make sure the repl display hook is installed in case we become interactive.\n    try:\n        install_repl_displayhook()\n    except NotImplementedError as err:\n        _log.warning(\"Fallback to a different backend\")\n        raise ImportError from err"}, {"file": "lib/matplotlib/backend_bases.py", "name": "ToolContainerBase.toggle_toolitem", "type": "codeblock", "score": 3.7838504314422607, "line": 3523, "text": "class ToolContainerBase:\n\n    def toggle_toolitem(self, name, toggled):\n        \"\"\"\n        A hook to toggle a toolitem without firing an event.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to silently toggle a toolbar element.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolManager.trigger_tool` or `.ToolContainerBase.trigger_tool`\n            (which are equivalent).\n\n        Parameters\n        ----------\n        name : str\n            Id of the tool to toggle.\n        toggled : bool\n            Whether to set this tool as toggled or not.\n        \"\"\"\n        raise NotImplementedError"}, {"file": "lib/matplotlib/backend_bases.py", "name": "ToolContainerBase.set_message", "type": "codeblock", "score": 3.549576759338379, "line": 3545, "text": "class ToolContainerBase:\n\n    def remove_toolitem(self, name):\n        \"\"\"\n        A hook to remove a toolitem from the container.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to remove an element from the toolbar; it is\n        called when `.ToolManager` emits a ``tool_removed_event``.\n\n        Because some tools are present only on the `.ToolManager` but not on\n        the `ToolContainerBase`, this method must be a no-op when called on a tool\n        absent from the container.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolManager.remove_tool`.\n\n        Parameters\n        ----------\n        name : str\n            Name of the tool to remove.\n        \"\"\"\n        raise NotImplementedError\n\n    def set_message(self, s):\n        \"\"\"\n        Display a message on the toolbar.\n\n        Parameters\n        ----------\n        s : str\n            Message text.\n        \"\"\"\n        raise NotImplementedError"}, {"file": "doc/conf.py", "name": "impl:138", "type": "codeblock", "score": 3.537447452545166, "line": 471, "text": "# Options for HTML output\n# -----------------------\n\ndef add_html_cache_busting(app, pagename, templatename, context, doctree):\n    \"\"\"\n    Add cache busting query on CSS and JavaScript assets.\n\n    This adds the Matplotlib version as a query to the link reference in the\n    HTML, if the path is not absolute (i.e., it comes from the `_static`\n    directory) and doesn't already have a query.\n\n    .. note:: Sphinx 7.1 provides asset checksums; so this hook only runs on\n              Sphinx 7.0 and earlier.\n    \"\"\"\n    from sphinx.builders.html import Stylesheet, JavaScript\n\n    css_tag = context['css_tag']\n    js_tag = context['js_tag']\n\n    def css_tag_with_cache_busting(css):\n        if isinstance(css, Stylesheet) and css.filename is not None:\n            url = urlsplit(css.filename)\n            if not url.netloc and not url.query:\n                url = url._replace(query=SHA)\n                css = Stylesheet(urlunsplit(url), priority=css.priority,\n                                 **css.attributes)\n        return css_tag(css)\n\n    def js_tag_with_cache_busting(js):\n        if isinstance(js, JavaScript) and js.filename is not None:\n            url = urlsplit(js.filename)\n            if not url.netloc and not url.query:\n                url = url._replace(query=SHA)\n                js = JavaScript(urlunsplit(url), priority=js.priority,\n                                **js.attributes)\n        return js_tag(js)\n\n    context['css_tag'] = css_tag_with_cache_busting\n    context['js_tag'] = js_tag_with_cache_busting"}, {"file": "lib/matplotlib/figure.py", "name": "Figure.show", "type": "codeblock", "score": 3.4160678386688232, "line": 2759, "text": "@_docstring.interpd\nclass Figure(FigureBase):\n\n    def show(self, warn=True):\n        \"\"\"\n        If using a GUI backend with pyplot, display the figure window.\n\n        If the figure was not created using `~.pyplot.figure`, it will lack\n        a `~.backend_bases.FigureManagerBase`, and this method will raise an\n        AttributeError.\n\n        .. warning::\n\n            This does not manage an GUI event loop. Consequently, the figure\n            may only be shown briefly or not shown at all if you or your\n            environment are not managing an event loop.\n\n            Use cases for `.Figure.show` include running this from a GUI\n            application (where there is persistently an event loop running) or\n            from a shell, like IPython, that install an input hook to allow the\n            interactive shell to accept input while the figure is also being\n            shown and interactive.  Some, but not all, GUI toolkits will\n            register an input hook on import.  See :ref:`cp_integration` for\n            more details.\n\n            If you're in a shell without input hook integration or executing a\n            python script, you should use `matplotlib.pyplot.show` with\n            ``block=True`` instead, which takes care of starting and running\n            the event loop for you.\n\n        Parameters\n        ----------\n        warn : bool, default: True\n            If ``True`` and we are not running headless (i.e. on Linux with an\n            unset DISPLAY), issue warning when called on a non-GUI backend.\n\n        \"\"\"\n        if self.canvas.manager is None:\n            raise AttributeError(\n                \"Figure.show works only for figures managed by pyplot, \"\n                \"normally created by pyplot.figure()\")\n        try:\n            self.canvas.manager.show()\n        except NonGuiException as exc:\n            if warn:\n                _api.warn_external(str(exc))"}, {"file": "tools/stubtest.py", "name": "impl:7", "type": "codeblock", "score": 3.35642147064209, "line": 85, "text": "existing_allowed = []\nwith (root / 'ci/mypy-stubtest-allowlist.txt').open() as f:\n    for line in f:\n        line, _, _ = line.partition('#')\n        line = line.strip()\n        if line:\n            existing_allowed.append(re.compile(line))\n\n\nwith tempfile.TemporaryDirectory() as d:\n    p = pathlib.Path(d) / \"allowlist.txt\"\n    with p.open(\"wt\") as f:\n        for path in mpl.glob(\"**/*.py\"):\n            v = Visitor(path, f, existing_allowed)\n            tree = ast.parse(path.read_text())\n\n            # Assign parents to tree so they can be backtraced\n            for node in ast.walk(tree):\n                for child in ast.iter_child_nodes(node):\n                    child.parent = node\n\n            v.visit(tree)\n    proc = subprocess.run(\n        [\n            \"stubtest\",\n            \"--mypy-config-file=pyproject.toml\",\n            \"--ignore-disjoint-bases\",\n            \"--allowlist=ci/mypy-stubtest-allowlist.txt\",\n            f\"--allowlist={p}\",\n            \"matplotlib\",\n        ],\n        cwd=root,\n        env=os.environ | {\"MPLBACKEND\": \"agg\"},\n    )\n    try:\n        os.unlink(f.name)\n    except OSError:\n        pass\n\nsys.exit(proc.returncode)"}, {"file": "lib/matplotlib/backend_bases.py", "name": "ToolContainerBase.add_toolitem", "type": "codeblock", "score": 3.0773847103118896, "line": 3476, "text": "class ToolContainerBase:\n\n    def trigger_tool(self, name):\n        \"\"\"\n        Trigger the tool.\n\n        Parameters\n        ----------\n        name : str\n            Name (id) of the tool triggered from within the container.\n        \"\"\"\n        self.toolmanager.trigger_tool(name, sender=self)\n\n    def add_toolitem(self, name, group, position, image, description, toggle):\n        \"\"\"\n        A hook to add a toolitem to the container.\n\n        This hook must be implemented in each backend and contains the\n        backend-specific code to add an element to the toolbar.\n\n        .. warning::\n            This is part of the backend implementation and should\n            not be called by end-users.  They should instead call\n            `.ToolContainerBase.add_tool`.\n\n        The callback associated with the button click event\n        must be *exactly* ``self.trigger_tool(name)``.\n\n        Parameters\n        ----------\n        name : str\n            Name of the tool to add, this gets used as the tool's ID and as the\n            default label of the buttons.\n        group : str\n            Name of the group that this tool belongs to.\n        position : int\n            Position of the tool within its group, if -1 it goes at the end.\n        image : str\n            Filename of the image for the button or `None`.\n        description : str\n            Description of the tool, used for the tooltips.\n        toggle : bool\n            * `True` : The button is a toggle (change the pressed/unpressed\n              state between consecutive clicks).\n            * `False` : The button is a normal button (returns to unpressed\n              state after release).\n        \"\"\"\n        raise NotImplementedError"}], "total_results": 10}
